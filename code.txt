Introduction

It is true that for some projects, other languages and environments can be better. But Processing is really darn good for a lot of stuﬀ, especially media-related and screen-based work. A common misconception is that Processing is just for ﬁddling around; this is not the case. People (myself included) are out there using Processing from day number 1 to day number 365 of their project. It is used for web applications, art projects in museums and galleries, and exhibits and installations in public spaces. Most recently, I used Processing to develop a real-time graphics video wall system (http://www.mostpixelsever.com) that can display content on a 120 by 12 foot (yes, feet!) video wall in the lobby of InterActive Corps’ New York City headquarters. Not only is Processing great for actually doing stuﬀ, but for learning, there really isn’t much out there better. It is free and open source. It is simple. It is visual. It is fun. It is object-oriented (we will get to this later.) And it does actually work on Macs, PCs, and Linux machines (no talking dogs though, sorry). So I would suggest to you that you stop worrying about what it is you should be using and focus on learning the fundamentals with Processing. That knowledge will take you above and beyond this book to any language you want to tackle.

Write in this book! Let’s say you are a novelist. Or a screenwriter. Is the only time you spend writing the time spent sitting and typing at a computer? Or (gasp) a typewriter? Most likely, this is not the case. Perhaps ideas swirl in your mind as you lie in bed at night. Or maybe you like to sit on a bench in the park, feed the pigeons, and play out dialogue in your head. And one late night, at the local pub, you ﬁnd yourself scrawling out a brilliant plot twist on a napkin. Well, writing software, programming, and creating code is no diﬀerent. It is really easy to forget this since the work itself is so inherently tied to the computer. But you must ﬁnd time to let your mind wander, think about logic, and brainstorm ideas away from the chair, the desk, and the computer. Personally, I do all my best programming while jogging. Sure, the actual typing on the computer part is pretty important. I mean, you will not end up with a lifechanging, working application just by laying out by the pool. But thinking you always need to be hunched over the glare of an LCD screen will not be enough. Writing all over this book is a step in the right direction, ensuring you will practice thinking through code away from the keyboard. I have included many exercises in the book that incorporate a “ﬁll in the blanks” approach. (All of these ﬁll in the blanks exercises have answers on the book’s Web site, http://www.learningprocessing.com, so you can check your work.) Use these pages! When an idea inspires you, make a note and write it down. Think of the book as a workbook and sketchbook for your computational ideas. (You can of course use your own sketchbook, too.) I would suggest you spend half your time reading this book away from the computer and the other half, side by side with your machine, experimenting with example code along the way.

How should I read this book? It is best to read this book in order. Chapter 1, Chapter 2, Chapter 3, and so on. You can get a bit more relaxed about this after the end of Chapter 9 but in the beginning it is pretty important.

Introduction

xiii

The book is designed to teach you programming in a linear fashion. A more advanced text might operate more like a reference where you read bits and pieces here and there, moving back and forth throughout the book. But here, the ﬁrst half of the book is dedicated to making one example, and building the features of that example one step at a time (more on this in a moment). In addition, the fundamental elements of computer programming are presented in a particular order, one that comes from several years of trial and error with a group of patient and wonderful students in New York University’s Interactive Telecommunications Program (“ITP ”) at the Tisch School of the Arts (http://itp.nyu.edu). The chapters of the book (23 total) are grouped into lessons (10 total). The ﬁrst nine chapters introduce computer graphics, and cover the fundamental principles behind computer programming. Chapters 10 through 12 take a break from learning new material to examine how larger projects are developed with an incremental approach. Chapters 13 through 23 expand on the basics and oﬀer a selection of more advanced topics ranging from 3D, to incorporating live video, to data visualization. The “Lessons” are oﬀered as a means of dividing the book into digestible chunks. The end of a lesson marks a spot at which I suggest you take a break from reading and attempt to incorporate that lesson’s chapters into a project. Suggestions for these projects are oﬀered (but they are really just that: suggestions).

Is this a textbook? This book is designed to be used either as a textbook for an introductory level programming course or for self-instruction. I should mention that the structure of this book comes directly out of the course “Introduction to Computational Media” at ITP. Without the help my fellow teachers of this class (Dan O’Sullivan, Danny Rozin, Chris Kairalla, Shawn Van Every, Nancy Lewis, Mark Napier, and James Tu) and hundreds of students (I wish I could name them all here), I don’t think this book would even exist. To be honest, though, I am including a bit more material than can be taught in a beginner level one semester course. Out of the 23 chapters, I probably cover about 18 of them in detail in my class (but make reference to everything in the book at some point). Nevertheless, whether or not you are reading the book for a course or learning on your own, it is reasonable that you could consume the book in a period of a few months. Sure, you can read it faster than that, but in terms of actually writing code and developing projects that incorporate all the material here, you will need a fairly signiﬁcant amount of time. As tempting as it is to call this book “Learn to Program with 10 Lessons in 10 Days!” it is just not realistic. Here is an example of how the material could play out in a 14 week semester course. Week 1

Lesson 1: Chapters 1–3

Week 2

Lesson 2: Chapters 4–6

Week 3

Lesson 3: Chapters 7–8

Week 4

Lesson 4: Chapter 9

Week 5

Lesson 5: Chapter 10–11

Week 6

Midterm! (Also, continue Lesson 5: Chapter 12)

xiv

Introduction

Week 7

Lesson 6: Chapter 13–14

Week 8

Lesson 7: Chapter 15–16

Week 9

Lesson 8: Chapters 17–19

Week 10

Lesson 9: Chapters 20–21

Week 11

Lesson 10: Chapters 22–23

Week 12

Final Project Workshop

Week 13

Final Project Workshop

Week 14

Final Project Presentations

Will this be on the test? A book will only take you so far. The real key is practice, practice, practice. Pretend you are 10 years old and taking violin lessons. Your teacher would tell you to practice every day. And that would seem perfectly reasonable to you. Do the exercises in this book. Practice every day if you can. Sometimes when you are learning, it can be diﬃcult to come up with your own ideas. These exercises are there so that you do not have to. However, if you have an idea for something you want to develop, you should feel free to twist and tweak the exercises to ﬁt with what you are doing. A lot of the exercises are tiny little drills that can be answered in a few minutes. Some are a bit harder and might require up to an hour. Along the way, however, it is good to stop and work on a project that takes longer, a few hours, a day, or a week. As I just mentioned, this is what the “ lesson” structure is for. I suggest that in between each lesson, you take a break from reading and work on making something in Processing. A page with project suggestions is provided for each lesson. All of the answers to all of the exercises can be found on this book’s web site. Speaking of which …

Do you have a web site? The Web site for this book is: http://www.learningprocessing.com There you will ﬁnd the following things: • • • • • •

Answers to all exercises in the book. Downloadable versions of all code in the book. Online versions of the examples (that can be put online) in the book. Corrections of any errors in the book. Additional tips and tutorials beyond material in the book. Questions and comments page.

Since many of the examples in this book use color and are animated, the black and white, static screenshots provided in the pages here will not give you the whole picture. As you are reading, you can refer to the web site to view the examples running in your browser as well as download them to run locally on your computer.

Introduction

xv

This book’s web site is not a substitute for the amazing resource that is the oﬃcial Processing web site: http://www.processing.org. There, you will ﬁnd the Processing reference, many more examples, and a lively forum.

Take It One Step at a Time The Philosophy of Incremental Development There is one more thing we should discuss before we embark on this journey together. It is an important driving force behind the way I learned to program and will contribute greatly to the style of this book. As coined by a former professor of mine, it is called the “philosophy of incremental development.” Or perhaps, more simply, the “one-step-at-a-time approach.” Whether you are a total novice or a coder with years of experience, with any programming project, it is crucial not to fall into the trap of trying to do too much all at once. Your dream might be to create the uber-Processing program that, say, uses Perlin noise to procedurally generate textures for 3D vertex shapes that evolve via the artiﬁcial intelligence of a neural network that crawls the web mining for today’s news stories, displaying the text of these stories onscreen in colors taken from a live video feed of a viewer in front of the screen who can control the interface with live microphone input by singing. There is nothing wrong with having grand visions, but the most important favor you can do for yourself is to learn how to break those visions into small parts and attack each piece slowly, one at a time. The previous example is a bit silly; nevertheless, if you were to sit down and attempt to program its features all at once, I am pretty sure you would end up using a cold compress to treat your pounding headache. To demonstrate, let’s simplify and say that you aspire to program the game Space Invaders (see: http:// en.wikipedia.org/wiki/Space_Invaders). While this is not explicitly a game programming book, the skills to accomplish this goal will be found here. Following our newfound philosophy, however, we know we need to develop one step at a time, breaking down the problem of programming Space Invaders into small parts. Here is a quick attempt: 1. Program the spaceship. 2. Program the invaders. 3. Program the scoring system. Great, we divided our program into three steps! Nevertheless, we are not at all ﬁnished. The key is to divide the problem into the smallest pieces possible, to the point of absurdity, if necessary. You will learn to scale back into larger chunks when the time comes, but for now, the pieces should be so small that they seem ridiculously oversimpliﬁed. After all, if the idea of developing a complex game such as Space Invaders seems overwhelming, this feeling will go away if you leave yourself with a list of steps to follow, each one simple and easy. With that in mind, let’s try a little harder, breaking Step 1 from above down into smaller parts. The idea here is that you would write six programs, the ﬁrst being the simplest: display a triangle. With each step, we add a small improvement: move the triangle. As the program gets more and more advanced, eventually we will be ﬁnished.

xvi

1.1 1.2 1.3 1.4 1.5 1.6

Introduction

Draw a triangle onscreen. The triangle will be our spaceship. Position the triangle at the bottom of the screen. Position the triangle slightly to the right of where it was before. Animate the triangle so that it moves from position left to right. Animate the triangle from left to right only when the right-arrow key is pressed. Animate the triangle right to left when the left-arrow key is pressed.

Of course, this is only a small fraction of all of the steps we need for a full Space Invaders game, but it demonstrates a vital way of thinking. The beneﬁts of this approach are not simply that it makes programming easier (which it does), but that it also makes “debugging” easier. Debugging1 refers to the process of ﬁnding defects in a computer program and ﬁxing them so that the program behaves properly. You have probably heard about bugs in, say, the Windows operating system: miniscule, arcane errors deep in the code. For us, a bug is a much simpler concept: a mistake. Each time you try to program something, it is very likely that something will not work as you expected, if at all. So if you start out trying to program everything all at once, it will be very hard to ﬁnd these bugs. The onestep-at-a-time methodology, however, allows you to tackle these mistakes one at a time, squishing the bugs. In addition, incremental development lends itself really well to object-oriented programming, a core principle of this book. Objects, which will be introduced in Lesson 3, Chapter 8, will help us to develop projects in modular pieces as well as provide an excellent means for organizing (and sharing) code. Reusability will also be key. For example, if you have programmed a spaceship for Space Invaders and want to start working on asteroids, you can grab the parts you need (i.e., the moving spaceship code), and develop the new pieces around them.

Algorithms When all is said and done, computer programming is all about writing algorithms. An algorithm is a sequential list of instructions that solves a particular problem. And the philosophy of incremental development (which is essentially an algorithm for you, the human being, to follow) is designed to make it easier for you to write an algorithm that implements your idea. As an exercise, before you get to Chapter 1, try writing an algorithm for something you do on a daily basis, such as brushing your teeth. Make sure the instructions seem comically simple (as in “Move the toothbrush one centimeter to the left ”). Imagine that you had to provide instructions on how to accomplish this task to someone entirely unfamiliar with toothbrushes, toothpaste, and teeth. That is how it is to write a program. A computer is nothing more than a machine that is brilliant at following precise instructions, but knows nothing about the world at large. And this is where we begin our journey, our story, our new life as a programmer. We begin with learning how to talk to our friend, the computer. 1 The term “debugging” comes from the apocryphal story of a moth getting stuck in the relay circuits of one of computer scientist Grace Murray Hopper’s computers.

Introduction

Introductory Exercise: Write instructions for brushing your teeth. Some suggestions: • Do you do different things based on conditions? How might you use the words “if ” or “otherwise” in your instructions? (For example: if the water is too cold, increase the warm water. Otherwise, increase cold water.) • Use the word “repeat ” in your instructions. For example: Move the brush up and down. Repeat 5 times. Also, note that we are starting with Step # 0. In programming, we often like to count starting from 0 so it is good for us to get used to this idea right oﬀ the bat! How to brush your teeth by ___________________________________________ Step 0. ___________________________________________________________ Step 1. ___________________________________________________________ Step 2. ___________________________________________________________ Step 3. ___________________________________________________________ Step 4. ___________________________________________________________ Step 5. ___________________________________________________________ Step 6. ___________________________________________________________ Step 7. ___________________________________________________________ Step 8. ___________________________________________________________ Step 9. ___________________________________________________________

xvii

This page intentionally left blank

Lesson One The Beginning

1 Pixels 2 Processing 3 Interaction

This page intentionally left blank

Pixels

3

1 Pixels “A journey of a thousand miles begins with a single step.” —Lao-tzu In this chapter: – Specifying pixel coordinates. – Basic shapes: point, line, rectangle, ellipse. – Color: grayscale, “RGB.” – Color transparency.

Note that we are not doing any programming yet in this chapter! We are just dipping our feet in the water and getting comfortable with the idea of creating onscreen graphics with text-based commands, that is, “code”!

1.1 Graph Paper This book will teach you how to program in the context of computational media, and it will use the development environment Processing (http://www.processing.org) as the basis for all discussion and examples. But before any of this becomes relevant or interesting, we must ﬁrst channel our eighth grade selves, pull out a piece of graph paper, and draw a line. The shortest distance between two points is a good old fashioned line, and this is where we begin, with two points on that graph paper. x-axis

Point B (4,5) 5 4 3 2 1 0

Point A (1,0) ﬁg. 1.1

0 1 2 3 4

y-axis

Figure 1.1 shows a line between point A (1,0) and point B (4,5). If you wanted to direct a friend of yours to draw that same line, you would give them a shout and say “draw a line from the point one-zero to the point four-ﬁve, please.” Well, for the moment, imagine your friend was a computer and you wanted to instruct this digital pal to display that same line on its screen. The same command applies (only this time you can skip the pleasantries and you will be required to employ a precise formatting). Here, the instruction will look like this: line(1,0,4,5);

Congratulations, you have written your ﬁrst line of computer code! We will get to the precise formatting of the above later, but for now, even without knowing too much, it should make a fair amount of sense. We are providing a command (which we will refer to as a “function”) for the machine to follow entitled “ line.” In addition, we are specifying some arguments for how that line should be drawn, from point

4

Learning Processing

A (0,1) to point B (4,5). If you think of that line of code as a sentence, the function is a verb and the arguments are the objects of the sentence. The code sentence also ends with a semicolon instead of a period. Draw a line from 0,1 to 4,5

Verb

Object

Object

ﬁg. 1.2

The key here is to realize that the computer screen is nothing more than a fancier piece of graph paper. Each pixel of the screen is a coordinate—two numbers, an “x” (horizontal) and a “y” (vertical)—that determine the location of a point in space. And it is our job to specify what shapes and colors should appear at these pixel coordinates. Nevertheless, there is a catch here. The graph paper from eighth grade (“Cartesian coordinate system”) placed (0,0) in the center with the y-axis pointing up and the x-axis pointing to the right (in the positive direction, negative down and to the left). The coordinate system for pixels in a computer window, however, is reversed along the y-axis. (0,0) can be found at the top left with the positive direction to the right horizontally and down vertically. See Figure 1.3. x-axis

x-axis



(0,0)

 y-axis

 

 y-axis



(0,0)

Eighth grade

Computer

ﬁg. 1.3

Exercise 1-1: Looking at how we wrote the instruction for line “line(1,0,4,5);” how would you guess you would write an instruction to draw a rectangle? A circle? A triangle? Write out the instructions in English and then translate it into “code.” English: _________________________________________________________________ Code:

_________________________________________________________________

English: _________________________________________________________________ Code:

_________________________________________________________________

English: _________________________________________________________________ Code:

_________________________________________________________________

Come back later and see how your guesses matched up with how Processing actually works.

Pixels

5

1.2 Simple Shapes The vast majority of the programming examples in this book will be visual in nature. You may ultimately learn to develop interactive games, algorithmic art pieces, animated logo designs, and (insert your own category here) with Processing, but at its core, each visual program will involve setting pixels. The simplest way to get started in understanding how this works is to learn to draw primitive shapes. This is not unlike how we learn to draw in elementary school, only here we do so with code instead of crayons. Let’s start with the four primitive shapes shown in Figure 1.4.

Point ﬁg. 1.4

Line

Rectangle

Ellipse

For each shape, we will ask ourselves what information is required to specify the location and size (and later color) of that shape and learn how Processing expects to receive that information. In each of the diagrams below (Figures 1.5 through 1.11), assume a window with a width of 10 pixels and height of 10 pixels. This isn’t particularly realistic since when we really start coding we will most likely work with much larger windows (10  10 pixels is barely a few millimeters of screen space). Nevertheless for demonstration purposes, it is nice to work with smaller numbers in order to present the pixels as they might appear on graph paper (for now) to better illustrate the inner workings of each line of code. 0

1

2

3

x-axis 4 5 6

7

8

9

0 1 2 3 4 y-axis 5 6 7 8 9

x

y

Point (4,5);

ﬁg. 1.5

A point is the easiest of the shapes and a good place to start. To draw a point, we only need an x and y coordinate as shown in Figure 1.5. A line isn’t terribly diﬃcult either. A line requires two points, as shown in Figure 1.6. 0

1

2

0 1 2 3 4 y-axis 5 6 7 8 9

x-axis 4 5 6

7

8

9

Point B (8,3) Point A x y

Point B x y

line (1,3,8,3);

Point A (1,3)

ﬁg. 1.6

3

6

Learning Processing

Once we arrive at drawing a rectangle, things become a bit more complicated. In Processing, a rectangle is speciﬁed by the coordinate for the top left corner of the rectangle, as well as its width and height (see Figure 1.7).

x-axis 4 5 6

Top left 0

1

2

3

7

8

9

0 1 2 3 4 y-axis 5 6 7 8 9

width height

height

rect (2,3,5,4); top left x

top left y

width

ﬁg. 1.7

However, a second way to draw a rectangle involves specifying the centerpoint, along with width and height as shown in Figure 1.8. If we prefer this method, we ﬁrst indicate that we want to use the “CENTER” mode before the instruction for the rectangle itself. Note that Processing is case-sensitive. Incidentally, the default mode is “CORNER,” which is how we began as illustrated in Figure 1.7.

0

1

2

3

x-axis 4 5 6

0 1 2 3 4 y-axis 5 6 7 8 9

7

8

9

rectMode (CENTER); rect (3,3,5,5); height width center center x y

center (3,3)

ﬁg. 1.8

Finally, we can also draw a rectangle with two points (the top left corner and the bottom right corner). The mode here is “CORNERS” (see Figure 1.9).

Pixels

7

top left (5,5) 0

1

2

3

4

5

6

7

8

9

0 1 2 3 4 5 6 7 8 9

rectMode (CORNERS) rect (5,5,8,7); bottom right y top left top left x y

bottom right x

bottom right (8,7)

ﬁg. 1.9

Once we have become comfortable with the concept of drawing a rectangle, an ellipse is a snap. In fact, it is identical to rect( ) with the diﬀerence being that an ellipse is drawn where the bounding box1 (as shown in Figure 1.11) of the rectangle would be. The default mode for ellipse( ) is “CENTER”, rather than “CORNER” as with rect( ). See Figure 1.10. 0

1

2

3

4

5

6

7

8

9

0 1 2 3 4 5 6 7 8 9

0

ellipseMode (CENTER); ellipse (3,3,5,5);

0 0 1 2 3 4 5 6 7 8 9

1

2

3

4

5

6

7

8

0 1 2 3 4 5 6 7 8 9

1

2

3

4

5

6

7

8

9

ellipseMode (CORNER); ellipse (3,3,4,4);

9

ellipseMode (CORNERS); ellipse (5,5,8,7);

ﬁg. 1.10

It is important to acknowledge that in Figure 1.10, the ellipses do not look particularly circular. Processing has a built-in methodology for selecting which pixels should be used to create a circular shape. Zoomed in like this, we get a bunch of squares in a circle-like pattern, but zoomed out on a computer screen, we get a nice round ellipse. Later, we will see that Processing gives us the power to develop our own 1 A bounding box of a shape in computer graphics is the smallest rectangle that includes all the pixels of that shape. For example, the bounding box of a circle is shown in Figure 1.11.

8

Learning Processing Circle’s bounding box

ﬁg. 1.11

algorithms for coloring in individual pixels (in fact, we can already imagine how we might do this using “point ” over and over again), but for now, we are content with allowing the “ellipse” statement to do the hard work. Certainly, point, line, ellipse, and rectangle are not the only shapes available in the Processing library of functions. In Chapter 2, we will see how the Processing reference provides us with a full list of available drawing functions along with documentation of the required arguments, sample syntax, and imagery. For now, as an exercise, you might try to imagine what arguments are required for some other shapes (Figure 1.12): triangle( ) arc( ) quad( ) curve( )

Triangle

Arc

Quad

Curve

ﬁg. 1.12

Exercise 1-2: Using the blank graph below, draw the primitive shapes speciﬁed by the code. line(0,0,9,6); 0

point(0,2); point(0,4); rectMode(CORNER); rect(5,0,4,3); ellipseMode(CENTER); ellipse(3,7,4,4);

0 1 2 3 4 y-axis 5 6 7 8 9

1

2

3

x-axis 4 5 6

7

8

9

Pixels

9

Exercise 1-3: Reverse engineer a list of primitive shape drawing instructions for the diagram below. 0

1

2

3

4

5

6

7

0 1 2 3 4 5 6 7 8 9

8

9

Note: There is more than one correct answer!

__________________________________________________________________ __________________________________________________________________ __________________________________________________________________ __________________________________________________________________ __________________________________________________________________

1.3 Grayscale Color As we learned in Section 1.2, the primary building block for placing shapes onscreen is a pixel coordinate. You politely instructed the computer to draw a shape at a speciﬁc location with a speciﬁc size. Nevertheless, a fundamental element was missing—color. In the digital world, precision is required. Saying “Hey, can you make that circle bluish-green?” will not do. Therefore, color is deﬁned with a range of numbers. Let’s start with the simplest case: black and white or grayscale. In grayscale terms, we have the following: 0 means black, 255 means white. In between, every other number—50, 87, 162, 209, and so on—is a shade of gray ranging from black to white. See Figure 1.13.

0 ﬁg. 1.13

50

87

162

209

255

Does 0–255 seem arbitary to you? Color for a given shape needs to be stored in the computer’s memory. This memory is just a long sequence of 0’s and 1’s (a whole bunch of on or oﬀ switches.) Each one of these switches is a

10

Learning Processing

bit, eight of them together is a byte. Imagine if we had eight bits (one byte) in sequence—how many ways can we conﬁgure these switches? The answer is (and doing a little research into binary numbers will prove this point) 256 possibilities, or a range of numbers between 0 and 255. We will use eight bit color for our grayscale range and 24 bit for full color (eight bits for each of the red, green, and blue color components; see Section 1.4).

Understanding how this range works, we can now move to setting speciﬁc grayscale colors for the shapes we drew in Section 1.2. In Processing, every shape has a stroke( ) or a ﬁll( ) or both. The stroke( ) is the outline of the shape, and the ﬁll( ) is the interior of that shape. Lines and points can only have stroke( ), for obvious reasons. If we forget to specify a color, Processing will use black (0) for the stroke( ) and white (255) for the ﬁll( ) by default. Note that we are now using more realistic numbers for the pixel locations, assuming a larger window of size 200  200 pixels. See Figure 1.14.

The background color is gray. The outline of the rectangle is black The interior of the rectangle is white

ﬁg. 1.14 rect(50,40,75,100);

By adding the stroke( ) and ﬁll( ) functions before the shape is drawn, we can set the color. It is much like instructing your friend to use a speciﬁc pen to draw on the graph paper. You would have to tell your friend before he or she starting drawing, not after. There is also the function background( ), which sets a background color for the window where shapes will be rendered.

Example 1-1: Stroke and ﬁll background(255); stroke(0); fill(150); rect(50,50,75,100);

stroke( ) or ﬁll( ) can be eliminated with the noStroke( ) or noFill( ) functions. Our instinct might be to say “stroke(0)” for no outline, however, it is important to remember that 0 is not “nothing”, but rather denotes the color black. Also, remember not to eliminate both—with noStroke( ) and noFill( ), nothing will appear!

ﬁg. 1.15

Pixels Example 1-2: noFill ( ) background(255); stroke(0); noFill(); ellipse(60,60,100,100);

noﬁll( ) leaves the shape with only an outline

If we draw two shapes at one time, Processing will always use the most recently speciﬁed stroke( ) and ﬁll( ), reading the code from top to bottom. See Figure 1.17. ﬁg. 1.16 background(150); stroke(0); line(0,0,100,100); stroke(255); noFill(); rect(25,25,50,50); ﬁg. 1.17

Exercise 1-4: Try to guess what the instructions would be for the following screenshot.

__________________________________________________________________ __________________________________________________________________ __________________________________________________________________ __________________________________________________________________ __________________________________________________________________ __________________________________________________________________ __________________________________________________________________ __________________________________________________________________

11

12

Learning Processing

1.4 RGB Color A nostalgic look back at graph paper helped us learn the fundamentals for pixel locations and size. Now that it is time to study the basics of digital color, we search for another childhood memory to get us started. Remember ﬁnger painting? By mixing three “primary ” colors, any color could be generated. Swirling all colors together resulted in a muddy brown. The more paint you added, the darker it got. Digital colors are also constructed by mixing three primary colors, but it works diﬀerently from paint. First, the primaries are diﬀerent: red, green, and blue (i.e., “RGB” color). And with color on the screen, you are mixing light, not paint, so the mixing rules are diﬀerent as well. • • • • •

Red Red Green Red No colors

   

green blue blue green  blue

    

yellow purple cyan (blue-green) white black

This assumes that the colors are all as bright as possible, but of course, you have a range of color available, so some red plus some green plus some blue equals gray, and a bit of red plus a bit of blue equals dark purple. While this may take some getting used to, the more you program and experiment with RGB color, the more it will become instinctive, much like swirling colors with your ﬁngers. And of course you can’t say “Mix some red with a bit of blue,” you have to provide an exact amount. As with grayscale, the individual color elements are expressed as ranges from 0 (none of that color) to 255 (as much as possible), and they are listed in the order R, G, and B. You will get the hang of RGB color mixing through experimentation, but next we will cover some code using some common colors. Note that this book will only show you black and white versions of each Processing sketch, but everything is documented online in full color at http://www.learningprocessing.com with RGB color diagrams found speciﬁcally at: http://learningprocessing.com/color.

Example 1-3: RGB color background(255); noStroke(); fill(255,0,0); ellipse(20,20,16,16);

Bright red ﬁg. 1.18

fill(127,0,0); ellipse(40,20,16,16);

Dark red

fill(255,200,200); ellipse(60,20,16,16);

Pink (pale red).

Processing also has a color selector to aid in choosing colors. Access this via TOOLS (from the menu bar) → COLOR SELECTOR. See Figure 1.19.

Pixels

13

ﬁg. 1.19

Exercise 1-5: Complete the following program. Guess what RGB values to use (you will be able to check your results in Processing after reading the next chapter). You could also use the color selector, shown in Figure 1.19. fill(________,________,________);

Bright blue

ellipse(20,40,16,16); fill(________,________,________);

Dark purple

ellipse(40,40,16,16); fill(________,________,________);

Yellow

ellipse(60,40,16,16);

Exercise 1-6: What color will each of the following lines of code generate? fill(0,100,0);

______________________________________

fill(100);

______________________________________

stroke(0,0,200);

______________________________________

stroke(225);

______________________________________

stroke(255,255,0); ______________________________________ stroke(0,255,255); ______________________________________ stroke(200,50,50); ______________________________________

14

Learning Processing

1.5 Color Transparency In addition to the red, green, and blue components of each color, there is an additional optional fourth component, referred to as the color’s “alpha.” Alpha means transparency and is particularly useful when you want to draw elements that appear partially see-through on top of one another. The alpha values for an image are sometimes referred to collectively as the “alpha channel” of an image. It is important to realize that pixels are not literally transparent, this is simply a convenient illusion that is accomplished by blending colors. Behind the scenes, Processing takes the color numbers and adds a percentage of one to a percentage of another, creating the optical perception of blending. (If you are interested in programming “rose-colored” glasses, this is where you would begin.) Alpha values also range from 0 to 255, with 0 being completely transparent (i.e., 0% opaque) and 255 completely opaque (i.e., 100% opaque). Example 1-4 shows a code example that is displayed in Figure 1.20.

Example 1-4: Alpha transparency background(0); noStroke( ); fill(0,0,255); rect(0,0,100,200);

No fourth argument means 100% opacity.

fill(255,0,0,255); rect(0,0,200,40);

255 means 100% opacity.

fill(255,0,0,191); rect(0,50,200,40);

75% opacity

fill(255,0,0,127); rect(0,100,200,40);

50% opacity

fill(255,0,0,63); rect(0,150,200,40);

25% opacity

ﬁg. 1.20

1.6 Custom Color Ranges RGB color with ranges of 0 to 255 is not the only way you can handle color in Processing. Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits (or 32 in the case of colors with an alpha). However, Processing will let us think about color any way we like, and translate our values into numbers the computer understands. For example, you might prefer to think of color as ranging from 0 to 100 (like a percentage). You can do this by specifying a custom colorMode( ).

Pixels colorMode(RGB,100);

15

With colorMode( ) you can set your own color range.

The above function says: “OK, we want to think about color in terms of red, green, and blue. The range of RGB values will be from 0 to 100.” Although it is rarely convenient to do so, you can also have diﬀerent ranges for each color component: colorMode(RGB,100,500,10,255);

Now we are saying “Red values go from 0 to 100, green from 0 to 500, blue from 0 to 10, and alpha from 0 to 255.” Finally, while you will likely only need RGB color for all of your programming needs, you can also specify colors in the HSB (hue, saturation, and brightness) mode. Without getting into too much detail, HSB color works as follows: • Hue—The color type, ranges from 0 to 360 by default (think of 360° on a color “wheel”). • Saturation—The vibrancy of the color, 0 to 100 by default. • Brightness—The, well, brightness of the color, 0 to 100 by default.

Exercise 1-7: Design a creature using simple shapes and colors. Draw the creature by hand using only points, lines, rectangles, and ellipses. Then attempt to write the code for the creature, using the Processing commands covered in this chapter: point( ), lines( ), rect( ), ellipse( ), stroke( ), and ﬁll( ). In the next chapter, you will have a chance to test your results by running your code in Processing. ________________________________________ ________________________________________ ________________________________________ ________________________________________ ________________________________________ ________________________________________ ________________________________________ ________________________________________ ________________________________________

16

Learning Processing

Example 1-5 shows my version of Zoog, with the outputs shown in Figure 1.21. Example 1-5: Zoog

ellipseMode(CENTER); rectMode(CENTER); stroke(0); ﬁll(150); rect(100,100,20,100); ﬁll(255); ellipse(100,70,60,60); ﬁll(0); ellipse(81,70,16,32); ellipse(119,70,16,32); stroke(0); line(90,150,80,160); line(110,150,120,160);

ﬁg. 1.21

The sample answer is my Processing-born being, named Zoog. Over the course of the ﬁrst nine chapters of this book, we will follow the course of Zoog’s childhood. The fundamentals of programming will be demonstrated as Zoog grows up. We will ﬁrst learn to display Zoog, then to make an interactive Zoog and animated Zoog, and ﬁnally to duplicate Zoog in a world of many Zoogs. I suggest you design your own “thing” (note that there is no need to limit yourself to a humanoid or creature-like form; any programmatic pattern will do) and recreate all of the examples throughout the ﬁrst nine chapters with your own design. Most likely, this will require you to only change a small portion (the shape rendering part) of each example. This process, however, should help solidify your understanding of the basic elements required for computer programs—Variables, Conditionals, Loops, Functions, Objects, and Arrays—and prepare you for when Zoog matures, leaves the nest, and ventures oﬀ into the more advanced topics from Chapter 10 on in this book.

Processing

17

2 Processing “Computers in the future may weigh no more than 1.5 tons.” —Popular Mechanics, 1949 “ Take me to your leader.” —Zoog, 2008 In this chapter: – Downloading and installing Processing. – Menu options. – A Processing “sketchbook.” – Writing code. – Errors. – The Processing reference. – The “Play” button. – Your ﬁrst sketch. – Publishing your sketch to the web.

2.1 Processing to the Rescue Now that we conquered the world of primitive shapes and RGB color, we are ready to implement this knowledge in a real world programming scenario. Happily for us, the environment we are going to use is Processing, free and open source software developed by Ben Fry and Casey Reas at the MIT Media Lab in 2001. (See this book’s introduction for more about Processing’s history.) Processing’s core library of functions for drawing graphics to the screen will provide for immediate visual feedback and clues as to what the code is doing. And since its programming language employs all the same principles, structures, and concepts of other languages (speciﬁcally Java), everything you learn with Processing is real programming. It is not some pretend language to help you get started; it has all the fundamentals and core concepts that all languages have. After reading this book and learning to program, you might continue to use Processing in your academic or professional life as a prototyping or production tool. You might also take the knowledge acquired here and apply it to learning other languages and authoring environments. You may, in fact, discover that programming is not your cup of tea; nonetheless, learning the basics will help you become a betterinformed technology citizen as you work on collaborative projects with other designers and programmers. It may seem like overkill to emphasize the why with respect to Processing. After all, the focus of this book is primarily on learning the fundamentals of computer programming in the context of computer graphics and design. It is, however, important to take some time to ponder the reasons behind selecting a programming language for a book, a class, a homework assignment, a web application, a software suite, and so forth. After all, now that you are going to start calling yourself a computer programmer at cocktail parties, this question will come up over and over again. I need programming in order to accomplish project X, what language and environment should I use? I say, without a shadow of doubt, that for you, the beginner, the answer is Processing. Its simplicity is ideal for a beginner. At the end of this chapter, you will be up and running with your ﬁrst computational design and ready to learn the fundamental concepts of programming. But simplicity is not where Processing

18

Learning Processing

ends. A trip through the Processing online exhibition (http://processing.org/exhibition/ ) will uncover a wide variety of beautiful and innovative projects developed entirely with Processing. By the end of this book, you will have all the tools and knowledge you need to take your ideas and turn them into real world software projects like those found in the exhibition. Processing is great both for learning and for producing, there are very few other environments and languages you can say that about.

2.2 How do I get Processing? For the most part, this book will assume that you have a basic working knowledge of how to operate your personal computer. The good news, of course, is that Processing is available for free download. Head to http://www.processing.org/ and visit the download page. If you are a Windows user, you will see two options: “ Windows (standard)” and “ Windows (expert).” Since you are reading this book, it is quite likely you are a beginner, in which case you will want the standard version. The expert version is for those who have already installed Java themselves. For Mac OS X, there is only one download option. There is also a Linux version available. Operating systems and programs change, of course, so if this paragraph is obsolete or out of date, visit the download page on the site for information regarding what you need. The Processing software will arrive as a compressed ﬁle. Choose a nice directory to store the application (usually “c:\Program Files\” on Windows and in “Applications” on Mac), extract the ﬁles there, locate the “Processing” executable, and run it.

Exercise 2-1: Download and install Processing.

2.3 The Processing Application The Processing development environment is a simpliﬁed environment for writing computer code, and is just about as straightforward to use as simple text editing software (such as TextEdit or Notepad) combined with a media player. Each sketch (Processing programs are referred to as “sketches”) has a ﬁlename, a place where you can type code, and some buttons for saving, opening, and running sketches. See Figure 2.1. Stop New

Export

Run

Sketch name

Open

Save

Type code here

Message window

ﬁg. 2.1

Processing

19

To make sure everything is working, it is a good idea to try running one of the Processing examples. Go to FILE → EXAMPLES → (pick an example, suggested: Topics → Drawing → ContinuousLines) as shown in Figure 2.2.

ﬁg. 2.2

Once you have opened the example, click the “run” button as indicated in Figure 2.3. If a new window pops open running the example, you are all set! If this does not occur, visit the online FAQ “Processing won’t start!” for possible solutions. The page can be found at this direct link: http://www.processing.org/faq/ bugs.html#wontstart.

Exercise 2-2: Open a sketch from the Processing examples and run it. ﬁg. 2.3

Processing programs can also be viewed full-screen (known as “present mode” in Processing). This is available through the menu option: Sketch → Present (or by shift-clicking the run button). Present will not resize your screen resolution. If you want the sketch to cover your entire screen, you must use your screen dimensions in size( ).

2.4 The Sketchbook Processing programs are informally referred to as sketches, in the spirit of quick graphics prototyping, and we will employ this term throughout the course of this book. The folder where you store your sketches is called your “sketchbook.” Technically speaking, when you run a sketch in processing, it runs as a local application on your computer. As we will see both in this Chapter and in Chapter 18, Processing also allows you to export your sketches as web applets (mini-programs that run embedded in a browser) or as platform-speciﬁc stand-alone applications (that could, for example, be made available for download). Once you have conﬁrmed that the Processing examples work, you are ready to start creating your own sketches. Clicking the “new ” button will generate a blank new sketch named by date. It is a good idea to “Save as” and create your own sketch name. (Note: Processing does not allow spaces or hyphens, and your sketch name cannot start with a number.)

20

Learning Processing

When you ﬁrst ran Processing, a default “Processing” directory was created to store all sketches in the “My Documents” folder on Windows and in “Documents” on OS X. Although you can select any directory on your hard drive, this folder is the default. It is a pretty good folder to use, but it can be changed by opening the Processing preferences (which are available under the FILE menu). Each Processing sketch consists of a folder (with the same name as your sketch) and a ﬁle with the extension “pde.” If your Processing sketch is named MyFirstProgram, then you will have a folder named MyFirstProgram with a ﬁle MyFirstProgram.pde inside. The “pde” ﬁle is a plain text ﬁle that contains the source code. (Later we will see that Processing sketches can have multiple pde’s, but for now one will do.) Some sketches will also contain a folder called “data” where media elements used in the program, such as image ﬁles, sound clips, and so on, are stored.

Exercise 2-3: Type some instructions from Chapter 1 into a blank sketch. Note how certain words are colored. Run the sketch. Does it do what you thought it would?

2.5 Coding in Processing It is ﬁnally time to start writing some code, using the elements discussed in Chapter 1. Let’s go over some basic syntax rules. There are three kinds of statements we can write: • Function calls • Assignment operations • Control structures For now, every line of code will be a function call. See Figure 2.4. We will explore the other two categories in future chapters. Functions have a name, followed by a set of arguments enclosed in parentheses. Recalling Chapter 1, we used functions to describe how to draw shapes (we just called them “commands” or “instructions”). Thinking of a function call as a natural language sentence, the function name is the verb (“draw ”) and the arguments are the objects (“point 0,0”) of the sentence. Each function call must always end with a semicolon. See Figure 2.5.

Line (0,0,200,200);

Function name

Ends with semi-colon

Arguments in parentheses

ﬁg. 2.4

We have learned several functions already, including background( ), stroke( ), ﬁll( ), noFill ( ), noStroke( ), point( ), line( ), rect( ), ellipse( ), rectMode( ), and ellipseMode( ). Processing will execute a sequence of functions one by one and ﬁnish by displaying the drawn result in a window. We forgot to learn one very important function in Chapter 1, however—size( ). size( ) speciﬁes the dimensions of the window you want to create and takes two arguments, width and height. The size( ) function should always be ﬁrst. size(320,240);

Opens a window of width 320 and height 240.

Processing

21

Let’s write a ﬁrst example (see Figure 2.5).

Code

Output window

Print messages ﬁg. 2.5

There are a few additional items to note. • The Processing text editor will color known words (sometimes referred to as “reserved” words or “keywords”). These words, for example, are the drawing functions available in the Processing library, “built-in” variables (we will look closely at the concept of variables in Chapter 3) and constants, as well as certain words that are inherited from the Java programming language. • Sometimes, it is useful to display text information in the Processing message window (located at the bottom). This is accomplished using the println( ) function. println( ) takes one argument, a String of characters enclosed in quotes (more about Strings in Chapter 14). When the program runs, Processing displays that String in the message window (as in Figure 2.5) and in this case the String is “ Take me to your leader!” This ability to print to the message window comes in handy when attempting to debug the values of variables (see Chapter 12, Debugging). • The number in the bottom left corner indicates what line number in the code is selected. • You can write “comments” in your code. Comments are lines of text that Processing ignores when the program runs. You should use them as reminders of what the code means, a bug you intend to fix, or a to do list of items to be inserted, and so on. Comments on a single line are created with two forward slashes, //. Comments over multiple lines are marked by /* followed by the comments and ending with */.

22

Learning Processing

// This is a comment on one line /* This is a comment that spans several lines of code */

A quick word about comments. You should get in the habit right now of writing comments in your code. Even though our sketches will be very simple and short at ﬁrst, you should put comments in for everything. Code is very hard to read and understand without comments. You do not need to have a comment for every line of code, but the more you include, the easier a time you will have revising and reusing your code later. Comments also force you to understand how code works as you are programming. If you do not know what you are doing, how can you write a comment about it? Comments will not always be included in the text here. This is because I ﬁnd that, unlike in an actual program, code comments are hard to read in a book. Instead, this book will often use code “hints” for additional insight and explanations. If you look at the book’s examples on the web site, though, comments will always be included. So, I can’t emphasize it enough, write comments! // A comment about this code line(0,0,100,100);

A hint about this code!

Exercise 2-4: Create a blank sketch. Take your code from the end of Chapter 1 and type it in the Processing window. Add comments to describe what the code is doing. Add a println( ) statement to display text in the message window. Save the sketch. Press the “run” button. Does it work or do you get an error?

2.6 Errors The previous example only works because we did not make any errors or typos. Over the course of a programmer’s life, this is quite a rare occurrence. Most of the time, our ﬁrst push of the play button will not be met with success. Let’s examine what happens when we make a mistake in our code in Figure 2.6. Figure 2.6 shows what happens when you have a typo—“elipse” instead of “ellipse” on line 9. If there is an error in the code when the play button is pressed, Processing will not open the sketch window, and will instead display the error message. This particular message is fairly friendly, telling us that we probably meant to type “ellipse.” Not all Processing error messages are so easy to understand, and we will continue to look at other errors throughout the course of this book. An Appendix on common errors in Processing is also included at the end of the book.

Processing

23

Line 9 highlighted

Error message

Error message again! Line 9

ﬁg. 2.6

Processing is case sensitive! If you type Ellipse instead of ellipse, that will also be considered an error.

In this instance, there was only one error. If multiple errors occur, Processing will only alert you to the ﬁrst one it ﬁnds (and presumably, once that error is corrected, the next error will be displayed at run time). This is somewhat of an unfortunate limitation, as it is often useful to have access to an entire list of errors when ﬁxing a program. This is simply one of the trade-oﬀs we get in a simpliﬁed environment such as Processing. Our life is made simpler by only having to look at one error at a time, nevertheless we do not have access to a complete list. This fact only further emphasizes the importance of incremental development discussed in the book’s introduction. If we only implement one feature at a time, we can only make one mistake at a time.

Exercise 2-5: Try to make some errors happen on purpose. Are the error messages what you expect?

24

Learning Processing

Exercise 2-6: Fix the errors in the following code. size(200,200);

_______________________________________

background();

_______________________________________

stroke 255;

_______________________________________

fill(150)

_______________________________________

rectMode(center);

_______________________________________

rect(100,100,50);

_______________________________________

2.7 The Processing Reference The functions we have demonstrated—ellipse( ), line( ), stroke( ), and so on—are all part of Processing’s library. How do we know that “ellipse” isn’t spelled “elipse”, or that rect( ) takes four arguments (an “x coordinate,” a “y coordinate,” a “width,” and a “height ”)? A lot of these details are intuitive, and this speaks to the strength of Processing as a beginner’s programming language. Nevertheless, the only way to know for sure is by reading the online reference. While we will cover many of the elements from the reference throughout this book, it is by no means a substitute for the reference and both will be required for you to learn Processing. The reference for Processing can be found online at the oﬃcial web site (http://www.processing.org) under the “reference” link. There, you can browse all of the available functions by category or alphabetically. If you were to visit the page for rect( ), for example, you would ﬁnd the explanation shown in Figure 2.7. As you can see, the reference page oﬀers full documentation for the function rect( ), including: • • • • •

Name—The name of the function. Examples—Example code (and visual result, if applicable). Description—A friendly description of what the function does. Syntax—Exact syntax of how to write the function. Parameters—These are the elements that go inside the parentheses. It tells you what kind of data you put in (a number, character, etc.) and what that element stands for. (This will become clearer as we explore more in future chapters.) These are also sometimes referred to as “arguments.” • Returns—Sometimes a function sends something back to you when you call it (e.g., instead of asking a function to perform a task such as draw a circle, you could ask a function to add two numbers and return the answer to you). Again, this will become more clear later. • Usage—Certain functions will be available for Processing applets that you publish online (“ Web”) and some will only be available as you run Processing locally on your machine (“Application”). • Related Methods—A list of functions often called in connection with the current function. Note that “functions” in Java are often referred to as “methods.” More on this in Chapter 6.

Processing

25

ﬁg. 2.7

Processing also has a very handy “ﬁnd in reference” option. Double-click on any keyword to select it and go to to HELP → FIND IN REFERENCE (or select the keyword and hit SHIFTCNTRLF).

Exercise 2-7: Using the Processing reference, try implementing two functions that we have not yet covered in this book. Stay within the “Shape” and “Color (setting)” categories. Exercise 2-8: Using the reference, ﬁnd a function that allows you to alter the thickness of a line. What arguments does the function take? Write example code that draws a line one pixel wide, then ﬁve pixels wide, then 10 pixels wide.

2.8 The “Play” Button One of the nice qualities of Processing is that all one has to do to run a program is press the “play ” button. It is a nice metaphor and the assumption is that we are comfortable with the idea of playing animations,

26

Learning Processing

movies, music, and other forms of media. Processing programs output media in the form of real-time computer graphics, so why not just play them too? Nevertheless, it is important to take a moment and consider the fact that what we are doing here is not the same as what happens on an iPod or TiVo. Processing programs start out as text, they are translated into machine code, and then executed to run. All of these steps happen in sequence when the play button is pressed. Let’s examine these steps one by one, relaxed in the knowledge that Processing handles the hard work for us.

Step 1. Translate to Java. Processing is really Java (this will become more evident in a detailed discussion in Chapter 23). In order for your code to run on your machine, it must ﬁrst be translated to Java code. Step 2. Compile into Java byte code. The Java code created in Step 1 is just another text ﬁle (with the .java extension instead of .pde). In order for the computer to understand it, it needs to be translated into machine language. This translation process is known as compilation. If you were programming in a diﬀerent language, such as C, the code would compile directly into machine language speciﬁc to your operating system. In the case of Java, the code is compiled into a special machine language known as Java byte code. It can run on diﬀerent platforms (Mac, Windows, cellphones, PDAs, etc.) as long as the machine is running a “Java Virtual Machine.” Although this extra layer can sometimes cause programs to run a bit slower than they might otherwise, being cross-platform is a great feature of Java. For more on how this works, visit http://java.sun.com or consider picking up a book on Java programming (after you have ﬁnished with this one). Step 3. Execution. The compiled program ends up in a JAR ﬁle. A JAR is a Java archive ﬁle that contains compiled Java programs (“classes”), images, fonts, and other data ﬁles. The JAR ﬁle is executed by the Java Virtual Machine and is what causes the display window to appear.

2.9 Your First Sketch Now that we have downloaded and installed Processing, understand the basic menu and interface elements, and have gotten familiar with the online reference, we are ready to start coding. As I brieﬂy mentioned in Chapter 1, the ﬁrst half of this book will follow one example that illustrates the foundational elements of programming: variables, arrays, conditionals, loops, functions, and objects. Other examples will be included along the way, but following just one will reveal how the basic elements behind computer programming build on each other.

The example will follow the story of our new friend Zoog, beginning with a static rendering with simple shapes. Zoog’s development will include mouse interaction, motion, and cloning into a population of many Zoogs. While you are by no means required to complete every exercise of this book with your own alien form, I do suggest that you start with a design and after each chapter, expand the functionality of that design with the programming concepts that are explored. If you are at a loss for an idea, then just draw your own little alien, name it Gooz, and get programming! See Figure 2.8.

Processing

27

Example 2-1: Zoog again size(200,200); // Set the size of the window background(255); // Draw a black background smooth();

// Set ellipses and rects to CENTER mode ellipseMode(CENTER); rectMode(CENTER);

// Draw Zoog’s body stroke(0); fill(150); rect(100,100,20,100);

Zoog’s body.

// Draw Zoog’s head fill(255); ellipse(100,70,60,60);

Zoog’s head.

// Draw Zoog’s eyes fill(0); ellipse(81,70,16,32); ellipse(119,70,16,32);

// Draw Zoog’s legs stroke(0); line(90,150,80,160); line(110,150,120,160);

Zoog’s eyes.

The function smooth() enables “anti-aliasing” which smooths the edges of the shapes. no smooth() disables anti-aliasing.

ﬁg. 2.8

Zoog’s legs.

Let’s pretend, just for a moment, that you ﬁnd this Zoog design to be so astonishingly gorgeous that you just cannot wait to see it displayed on your computer screen. (Yes, I am aware this may require a fairly signiﬁcant suspension of disbelief.) To run any and all code examples found in this book, you have two choices: • Retype the code manually. • Visit the book’s web site (http://www.learningprocessing.com), find the example by its number, and copy/paste (or download) the code. Certainly option #2 is the easier and less time-consuming one and I recommend you use the site as a resource for seeing sketches running in real-time and grabbing code examples. Nonetheless, as you start learning, there is real value in typing the code yourself. Your brain will sponge up the syntax and logic as you type and you will learn a great deal by making mistakes along the way. Not to mention simply running the sketch after entering each new line of code will eliminate any mystery as to how the sketch works. You will know best when you are ready for copy /paste. Keep track of your progress and if you start running a lot of examples without feeling comfortable with how they work, try going back to manual typing.

28

Learning Processing

Exercise 2-9: Using what you designed in Chapter 1, implement your own screen drawing, using only 2D primitive shapes—arc( ), curve( ), ellipse( ), line( ), point( ), quad( ), rect( ), triangle( )—and basic color functions—background( ), colorMode( ), ﬁll( ), noFill( ), noStroke( ), and stroke( ). Remember to use size( ) to specify the dimensions of your window. Suggestion: Play the sketch after typing each new line of code. Correct any errors or typos along the way.

2.10 Publishing Your Program After you have completed a Processing sketch, you can publish it to the web as a Java applet. This will become more exciting once we are making interactive, animated applets, but it is good to practice with a simple example. Once you have ﬁnished Exercise 2-9 and determined that your sketch works, select FILE → EXPORT. Note that if you have errors in your program, it will not export properly, so always test by running ﬁrst! A new directory named “applet ” will be created in the sketch folder and displayed, as shown in Figure 2.9.

ﬁg. 2.9

You now have the necessary ﬁles for publishing your applet to the web. • index.html—The HTML source for a page that displays the applet. • loading.gif—An image to be displayed while the user loads the applet (Processing will supply a default one, but you can create your own). • zoog.jar—The compiled applet itself. • zoog.java—The translated Java source code (looks like your Processing code, but has a few extra things that Java requires. See Chapter 20 for details.) • zoog.pde—Your Processing source.

Processing

29

To see the applet working, double-click the “index.html” ﬁle which should launch a page in your default web browser. See Figure 2.10. To get the applet online, you will need web server space and FTP software (or you can also use a Processing sketch sharing site such as http://www.openprocessing.org). You can ﬁnd some tips for getting started at this book’s web site.

ﬁg. 2.10

Exercise 2-10: Export your sketch as an applet. View the sketch in the browser (either locally or by uploading).0000200002

This page intentionally left blank

Interaction

31

3 Interaction “Always remember that this whole thing was started with a dream and a mouse.” —Walt Disney “ The quality of the imagination is to ﬂow and not to freeze.” —Ralph Waldo Emerson In this chapter: – The “ﬂow” of a program. – The meaning behind setup( ) and draw( ). – Mouse interaction. – Your ﬁrst “dynamic” Processing program. – Handling events, such as mouse clicks and key presses.

3.1 Go with the ﬂow. If you have ever played a computer game, interacted with a digital art installation, or watched a screensaver at three in the morning, you have probably given very little thought to the fact that the software that runs these experiences happens over a period of time. The game starts, you save princess so-and-so from the evil lord who-zee-ma-whats-it, achieve a high score, and the game ends. What I want to focus on in this chapter is that very “ﬂow ” over time. A game begins with a set of initial conditions: you name your character, you start with a score of zero, and you start on level one. Let’s think of this part as the program’s SETUP. After these conditions are initialized, you begin to play the game. At every instant, the computer checks what you are doing with the mouse, calculates all the appropriate behaviors for the game characters, and updates the screen to render all the game graphics. This cycle of calculating and drawing happens over and over again, ideally 30 or more times per second for a smooth animation. Let’s think of this part as the program’s DRAW. This concept is crucial to our ability to move beyond static designs (as in Chapter 2) with Processing. Step 1. Set starting conditions for the program one time. Step 2. Do something over and over and over and over (and over …) again until the program quits. Consider how you might go about running a race. Step 1. Put on your sneakers and stretch. Just do this once, OK? Step 2. Put your right foot forward, then your left foot. Repeat this over and over as fast as you can. Step 3. After 26 miles, quit.

32

Learning Processing

Exercise 3-1: In English, write out the “ﬂow” for a simple computer game, such as Pong. If you are not familiar with Pong, visit: http://en.wikipedia.org/wiki/Pong. _______________________________________________________________ _______________________________________________________________ _______________________________________________________________ _______________________________________________________________

3.2 Our Good Friends, setup( ) and draw( ) Now that we are good and exhausted from running marathons in order to better learn programming, we can take this newfound knowledge and apply it to our ﬁrst “dynamic” Processing sketch. Unlike Chapter 2’s static examples, this program will draw to the screen continuously (i.e., until the user quits). This is accomplished by writing two “ blocks of code” setup( ) and draw( ). Technically speaking setup( ) and draw( ) are functions. We will get into a longer discussion of writing our own functions in a later chapter; for now, we understand them to be two sections where we write code.

What is a block of code? A block of code is any code enclosed within curly brackets. { A block of code }

Blocks of code can be nested within each other, too. { A block of code { A block inside a block of code } }

This is an important construct as it allows us to separate and manage our code as individual pieces of a larger puzzle. A programming convention is to indent the lines of code within each block to make the code more readable. Processing will do this for you via the Auto-Format option (Tools → Auto-Format). Blocks of code will reveal themselves to be crucial in developing more complex logic, in terms of variables, conditionals, iteration, objects, and functions, as discussed in future chapters. For now, we only need to look at two simple blocks: setup( ) and draw( ).

Interaction

33

Let’s look at what will surely be strange-looking syntax for setup( ) and draw( ). See Figure 3.1.

What’s this?

What are these for?

void setup() { // Initialization code goes here } Curly brackets open and close a block of code. void draw() { // Code that runs forever goes here } ﬁg. 3.1

Admittedly, there is a lot of stuﬀ in Figure 3.1 that we are not entirely ready to learn about. We have covered that the curly brackets indicate the beginning and end of a “ block of code,” but why are there parentheses after “setup” and “draw ”? Oh, and, my goodness, what is this “void” all about? It makes me feel sad inside! For now, we have to decide to feel comfortable with not knowing everything all at once, and that these important pieces of syntax will start to make sense in future chapters as more concepts are revealed. For now, the key is to focus on how Figure 3.1’s structures control the ﬂow of our program. This is shown in Figure 3.2.

void // // // }

setup() { Step 1a Step 1b Step 1c

Do once!

Skip to draw. void draw() { // Step 2a // Step 2b }

Loop over and over!

ﬁg. 3.2

How does it work? When we run the program, it will follow our instructions precisely, executing the steps in setup( ) ﬁrst, and then move on to the steps in draw( ). The order ends up being something like: 1a, 1b, 1c, 2a, 2b, 2a, 2b, 2a, 2b, 2a, 2b, 2a, 2b, 2a, 2b … Now, we can rewrite the Zoog example as a dynamic sketch. See Example 3–1.

34

Learning Processing Example 3-1: Zoog as dynamic sketch void setup(){ // Set the size of the window size(200,200); }

setup() runs ﬁrst one time. size() should always be ﬁrst line of setup() since Processing will not be able to do anything before the window size if speciﬁed.

void draw() { // Draw a white background background(255);

draw() loops continuously until you close the sketch window.

// Set CENTER mode ellipseMode(CENTER); rectMode(CENTER);

// Draw Zoog's body stroke(0); fill(150); rect(100,100,20,100);

// Draw Zoog's head stroke(0); fill(255); ellipse(100,70,60,60);

ﬁg. 3.3

// Draw Zoog's eyes fill(0); ellipse(81,70,16,32); ellipse(119,70,16,32);

// Draw Zoog's legs stroke(0); line(90,150,80,160); line(110,150,120,160); }

Take the code from Example 3-1 and run it in Processing. Strange, right? You will notice that nothing in the window changes. This looks identical to a static sketch! What is going on? All this discussion for nothing? Well, if we examine the code, we will notice that nothing in the draw( ) function varies. Each time through the loop, the program cycles through the code and executes the identical instructions. So, yes, the program is running over time redrawing the window, but it looks static to us since it draws the same thing each time!

Exercise 3-2: Redo the drawing you created at the end of Chapter 2 as a dynamic program. Even though it will look the same, feel good about your accomplishment!

Interaction

35

3.3 Variation with the Mouse Consider this. What if, instead of typing a number into one of the drawing functions, you could type “the mouse’s X location” or “the mouse’s Y location.” line(the mouse's X location, the mouse's Y location, 100, 100);

In fact, you can, only instead of the more descriptive language, you must use the keywords mouseX and mouseY, indicating the horizontal or vertical position of the mouse cursor. Example 3-2: mouseX and mouseY void setup() { size(200,200); } void draw() { background(255);

Try moving background() to setup() and see the difference! (Exercise 3–3)

// Body stroke(0); fill(175); rectMode(CENTER); rect(mouseX,mouseY,50,50); }

ﬁg. 3.4

mouseX is a keyword that the sketch replaces with the horizontal position of the mouse. mouseY is a keyword that the sketch replaces with the vertical position of the mouse.

Exercise 3-3: Explain why we see a trail of rectangles if we move background( ) to setup( ), leaving it out of draw( ). _____________________________________________________ _____________________________________________________ _____________________________________________________ _____________________________________________________ _____________________________________________________

An Invisible Line of Code If you are following the logic of setup( ) and draw( ) closely, you might arrive at an interesting question: When does Processing actually display the shapes in the window? When do the new pixels appear?

36

Learning Processing

On ﬁrst glance, one might assume the display is updated for every line of code that includes a drawing function. If this were the case, however, we would see the shapes appear onscreen one at a time. This would happen so fast that we would hardly notice each shape appearing individually. However, when the window is erased every time background( ) is called, a somewhat unfortunate and unpleasant result would occur: ﬂicker. Processing solves this problem by updating the window only at the end of every cycle through draw( ). It is as if there were an invisible line of code that renders the window at the end of the draw( ) function. void draw() { // All of your code // Update Display Window -- invisible line of code we don’t see }

This process is known as double-buﬀering and, in a lower-level environment, you may ﬁnd that you have to implement it yourself. Again, we take the time to thank Processing for making our introduction to programming friendlier and simpler by taking care of this for us.

We could push this idea a bit further and create an example where a more complex pattern (multiple shapes and colors) is controlled by mouseX and mouseY position. For example, we can rewrite Zoog to follow the mouse. Note that Zoog’s body is located at the exact location of the mouse (mouseX, mouseY), however, other parts of Zoog’s body are drawn relative to the mouse. Zoog’s head, for example, is located at (mouseX, mouseY-30). The following example only moves Zoog’s body and head, as shown in Figure 3.5.

Example 3-3: Zoog as dynamic sketch with variation void setup() { size(200,200); // Set the size of the window smooth(); } void draw() { background(255); // Draw a white background ﬁg. 3.5 // Set ellipses and rects to CENTER mode ellipseMode(CENTER); rectMode(CENTER); // Draw Zoog's body stroke(0); fill(175); rect(mouseX,mouseY,20,100); // Draw Zoog's head stroke(0); fill(255); ellipse(mouseX,mouseY-30,60,60);

Zoog’s body is drawn at the location (mouseX, mouseY). Zoog’s head is drawn above the body at the location (mouseX, mouseY-30).

Interaction

37

// Draw Zoog's eyes fill(0); ellipse(81,70,16,32); ellipse(119,70,16,32); // Draw Zoog's legs stroke(0); line(90,150,80,160); line(110,150,120,160); }

Exercise 3-4: Complete Zoog so that the rest of its body moves with the mouse. // Draw Zoog's eyes fill(0); ellipse(_______,_______ ,16,32); ellipse(_______,_______ ,16,32); // Draw Zoog's legs stroke(0); line(_______,_______,_______,_______); line(_______,_______,_______,_______);

Exercise 3-5: Recode your design so that shapes respond to the mouse (by varying color and location). In addition to mouseX and mouseY, you can also use pmouseX and pmouseY. These two keywords stand for the “previous” mouseX and mouseY locations, that is, where the mouse was the last time we cycled through draw( ). This allows for some interesting interaction possibilities. For example, let’s consider what happens if we draw a line from the previous mouse location to the current mouse location, as illustrated in the diagram in Figure 3.6. 100  100 window 20

75

50

25 50 90 mouseX  20 mouseY  50

1st time through draw() ﬁg. 3.6

pmouseX  20 pmouseY  50 mouseX  75 mouseY  25 2nd time through draw()

pmouseX  20 pmouseY  50 mouseX  50 mouseY  90 3rd time through draw()

38

Learning Processing

Exercise 3-6: Fill in the blank in Figure 3.6.

By connecting the previous mouse location to the current mouse location with a line each time through draw( ), we are able to render a continuous line that follows the mouse. See Figure 3.7.

Example 3-4: Drawing a continuous line void setup() { size(200,200); background(255); smooth(); }

Draw a line from previous mouse location to current mouse location.

void draw() { stroke(0); line(pmouseX,pmouseY,mouseX,mouseY); }

ﬁg. 3.7

Exercise 3-7: The formula for calculating the speed of the mouse’s horizontal motion is the absolute value of the diﬀerence between mouseX and pmouseX. The absolute value of a number is deﬁned as that number without its sign: • The absolute value of –2 is 2. • The absolute value of 2 is 2. In Processing, we can get the absolute value of the number by placing it inside the abs( ) function, that is, • abs(5) → 5 The speed at which the mouse is moving is therefore: • abs(mouseX-pmouseX ) Update Exercise 3-7 so that the faster the user moves the mouse, the wider the drawn line. Hint: look up strokeWeight( ) in the Processing reference. stroke(255); _____________________________ (______________); line(pmouseX,pmouseY,mouseX,mouseY);

Interaction

39

3.4 Mouse Clicks and Key Presses We are well on our way to creating dynamic, interactive Processing sketches through the use the setup( ) and draw( ) framework and the mouseX and mouseY keywords. A crucial form of interaction, however, is missing—clicking the mouse! In order to learn how to have something happen when the mouse is clicked, we need to return to the ﬂow of our program. We know setup( ) happens once and draw( ) loops forever. When does a mouse click occur? Mouse presses (and key presses) as considered events in Processing. If we want something to happen (such as “the background color changes to red”) when the mouse is clicked, we need to add a third block of code to handle this event. This event “function” will tell the program what code to execute when an event occurs. As with setup( ), the code will occur once and only once. That is, once and only once for each occurrence of the event. An event, such as a mouse click, can happen multiple times of course! These are the two new functions we need: • mousePressed( )—Handles mouse clicks. • keyPressed( )—Handles key presses. The following example uses both event functions, adding squares whenever the mouse is pressed and clearing the background whenever a key is pressed.

Example 3-5: mousePressed( ) and keyPressed( ) void setup() { size(200,200); background(255); } void draw() {

Nothing happens in draw() in this example! }

ﬁg. 3.8

Whenever a user clicks the mouse the code void mousePressed() { written inside mousePressed() is executed. stroke(0); fill(175); rectMode(CENTER); rect(mouseX,mouseY,16,16); } void keyPressed() { background(255); }

Whenever a user presses a key the code written inside keyPressed() is executed.

In Example 3-5, we have four functions that describe the program’s ﬂow. The program starts in setup( ) where the size and background are initialized. It continues into draw( ), looping endlessly. Since draw( ) contains no code, the window will remain blank. However, we have added two new functions: mousePressed( ) and

40

Learning Processing

keyPressed( ). The code inside these functions sits and waits. When the user clicks the mouse (or presses a key), it springs into action, executing the enclosed block of instructions once and only once.

Exercise 3-8: Add “background(255);” to the draw( ) function. Why does the program stop working? We are now ready to bring all of these elements together for Zoog. • • • •

Zoog’s entire body will follow the mouse. Zoog’s eye color will be determined by mouse location. Zoog’s legs will be drawn from the previous mouse location to the current mouse location. When the mouse is clicked, a message will be displayed in the message window: “ Take me to your leader!”

Note the addition in Example 3–6 of the function frameRate( ). frameRate( ), which requires an integer between 1 and 60, enforces the speed at which Processing will cycle through draw( ). frameRate (30), for example, means 30 frames per second, a traditional speed for computer animation. If you do not include frameRate( ), Processing will attempt to run the sketch at 60 frames per second. Since computers run at diﬀerent speeds, frameRate( ) is used to make sure that your sketch is consistent across multiple computers. This frame rate is just a maximum, however. If your sketch has to draw one million rectangles, it may take a long time to ﬁnish the draw cycle and run at a slower speed.

Example 3-6: Interactive Zoog void setup() { // Set the size of the window size(200,200); smooth(); frameRate(30);

The frame rate is set to 30 frames per second.

} void draw() { // Draw a black background background(255); // Set ellipses and rects to CENTER mode ellipseMode(CENTER); rectMode(CENTER); // Draw Zoog's body stroke(0); fill(175); rect(mouseX,mouseY,20,100); // Draw Zoog's head stroke(0); fill(255); ellipse(mouseX,mouseY-30,60,60);

ﬁg. 3.9

Interaction // Draw Zoog's eyes fill(mouseX,0,mouseY); ellipse(mouseX-19,mouseY-30,16,32); ellipse(mouseX+19,mouseY-30,16,32);

The eye color is determined by the mouse location.

// Draw Zoog's legs stroke(0); line(mouseX-10,mouseY+50,pmouseX-10,pmouseY+60); line(mouseX+10,mouseY+50,pmouseX+10,pmouseY+60); } void mousePressed() { println("Take me to your leader!"); }

The legs are drawn according to the mouse location and the previous mouse location.

41

42

Learning Processing

Lesson One Project (You may have completed much of this project already via the exercises in Chapters 1–3. This project brings all of the elements together. You could either start from scratch with a new design or use elements from the exercises.) Step 1. Design a static screen drawing using RGB color and primitive shapes. Step 2. Make the static screen drawing dynamic by having it interact with the mouse. This might include shapes following the mouse, changing their size according to the mouse, changing their color according to the mouse, and so on. Use the space provided below to sketch designs, notes, and pseudocode for your project.

Lesson Two Everything You Need to Know

4 Variables 5 Conditionals 6 Loops

This page intentionally left blank

Variables

45

4 Variables “All of the books in the world contain no more information than is broadcast as video in a single large American city in a single year. Not all bits have equal value.” —Carl Sagan “Believing oneself to be perfect is often the sign of a delusional mind.” —Lieutenant Commander Data In this chapter: – Variables: What are they? – Declaring and initializing variables. – Common uses for variables. – Variables you get “for free” in Processing (AKA “built-in” variables). – Using random values for variables.

4.1 What is a Variable? I admit it. When I teach programming, I launch into a diatribe of analogies in an attempt to explain the concept of a variable in an intuitive manner. On any given day, I might say “A variable is like a bucket.” You put something in the bucket, carry it around with you, and retrieve it whenever you feel inspired. “A variable is like a storage locker.” Deposit some information in the locker where it can live safely, readily available at a moment’s notice. “A variable is a lovely, yellow post-it note, on which is written the message: I am a variable. Write your information on me.”

9

3

Variable locker

Variable post-it

6 Variable bucket ﬁg. 4.1

I could go on. But I won’t. I think you get the idea. And I am not entirely sure we really need an analogy since the concept itself is rather simple. Here’s the deal. The computer has memory. Why do we call it memory? Because it is what the computer uses to remember stuﬀ it needs. Technically speaking, a variable is a named pointer to a location in the computer’s memory (“memory address”) where data is stored. Since computers only process information one instruction at a time, a variable allows a programmer to save information from one point in the program and refer back to it at a later time. For a Processing programmer, this is incredibly useful; variables can keep track of information related to shapes: color, size, location. Variables are exactly what you need to make a triangle change from blue to purple, a circle ﬂy across the screen, and a rectangle shrink into oblivion.

46

Learning Processing

Out of all the available analogies, I tend to prefer the piece of paper approach: graph paper. Imagine that the computer’s memory is a sheet of graph paper and each cell on the graph paper has an address. With pixels, we learned how to refer to those cells by column and row numbers. Wouldn’t it be nice if we could name those cells? With variables, we can. Let’s name one “Billy’s Score” (we will see why we are calling it that in the next section) and give it the value 100. That way, whenever we want to use Billy’s score in a program, we do not have to remember the value 100. It is there in memory and we can ask for it by name. See Figure 4.2. Billy’s score

100

ﬁg 4.2

The power of a variable does not simply rest with the ability to remember a value. The whole point of a variable is that those values vary, and more interesting situations arise as we periodically alter that value. Consider a game of Scrabble between Billy and Jane. To keep track of the score, Jane takes out paper and pencil, and scrawls down two column names: “Billy’s Score” and “Jane’s Score.” As the two play, a running tally is kept of each player’s points below the headings. If we imagine this game to be virtual Scrabble programmed on a computer, we suddenly can see the concept of a variable that varies emerge. That piece of paper is the computer’s memory and on that paper, information is written—“Billy’s Score” and “Jane’s Score” are variables, locations in memory where each player’s total points are stored and that change over time. See Figure 4.3.

Jane’s Score

Billy’s Score

5

10

30

25

53

47

65

68

87

91

101

98

ﬁg. 4.3

In our Scrabble example, the variable has two elements—a name (e.g., “Jane’s Score”) and a value (e.g., 101). In Processing, variables can hold diﬀerent kinds of values and we are required to explicitly deﬁne the type of value before we can use a given variable.

Variables

47

Exercise 4-1: Consider the game Pong. What variables would you need to program the game? (If you are not familiar with Pong, see http://en.wikipedia.org/wiki/Pong).

4.2 Variable Declaration and Initialization Variables can hold primitive values or references to objects and arrays. For now, we are just going to worry about primitives—we will get to objects and arrays in a later chapter. Primitive values are the building blocks of data on the computer and typically involve a singular piece of information, like a number or character.

Variables are declared by ﬁrst stating the type, followed by the name. Variable names must be one word (no spaces) and must start with a letter (they can include numbers, but cannot start with a number). They cannot include any punctuation or special characters, with the exception of the underscore: “_”. A type is the kind of data stored in that variable. This could be a whole number, a decimal number, or a character. Here are data types you will commonly use: • Whole numbers, such as 0, 1, 2, 3, 1, 2, and so on are stored as “integers” and the type keyword for integer is “int”. • Decimal numbers, such as 3.14159, 2.5, and –9.95 are typically stored as “floating point values” and the type keyword for floating point is “float”. • Characters, such as the letters ‘a’, ‘ b’, ‘c’, and so on are stored in variables of type “char” and are declared as a letter enclosed in single quotes, that is, ‘a’. Characters are useful when determining what letter on the keyboard has been pressed, and for other uses involving Strings of text (see Chapter 17).

int

count

type ﬁg. 4.4

name

;

In Figure 4.4, we have a variable named “count ” of type “int,” which stands for integer. Other possible data types are listed below.

48

Learning Processing

Don’t Forget • Variables must have a type. Why? This is how the computer knows exactly how much memory should be allocated to store that variable’s data. • Variables must have a name.

All Primitive Types • • • • • • • •

boolean: true or false char: a character, ‘a’,‘b’,‘c’, etc. byte: a small number, –128 to 127 short: a larger number, –32768 to 32767 int: a big number, –2147483648 to 2147483647 long: a really huge number ﬂoat: a decimal number, such as 3.14159 double: a decimal number with a lot more decimal places (only necessary for advanced programs requiring mathematical precision).

Once a variable is declared, we can then assign it a value by setting it equal to something. In most cases, if we forget to initialize a variable, Processing will give it a default value, such as 0 for integers, 0.0 for ﬂoating points, and so on. However, it is good to get into the habit of always initializing variables in order to avoid confusion. int count; count = 50;

Declare and initialize a variable in two lines of code.

To be more concise, we can combine the above two statements into one. int count = 50;

Declare and initialize a variable in one lines of code.

What’s in a name? Tips for choosing good variable names • Avoid using words that appear elsewhere in the Processing language. In other words, do not call your variable mouseX, there already is one! • Use names that mean something. This may seem obvious, but it is an important point. For example, if you are using a variable to keep track of score, call it “score” and not, say, “cat.” • Start your variable with a lowercase letter and join together words with capitals. Words that start with capitals are reserved for classes (Chapter 8). For example: “frogColor” is good, “Frogcolor” is not. this canTake some gettingUsedTo but it will comeNaturally soonEnough.

Variables

49

A variable can also be initialized by another variable (x equals y), or by evaluating a mathematical expression (x equals y plus z, etc.). Here are some examples: Example 4-1: Variable declaration and initialization examples int count = 0; char letter = 'a'; double d = 132.32; boolean happy = false; float x = 4.0; float y; y = x + 5.2; float z = x*y + 15.0;

// // // // // // // // //

Declare an int named count, assigned the value 0 Declare a char named letter, assigned the value 'a' Declare a double named d, assigned the value 132.32 Declare a boolean named happy, assigned the value false Declare a float named x, assigned the value 4.0 Declare a float named y (no assignment) Assign the value of x plus 5.2 to the previously declared y Declare a variable named z, assign it the value which is x times y plus 15.0.

Exercise 4-2: Write out variable declaration and initialization for the game Pong. ____________________________________________________________ ____________________________________________________________ ____________________________________________________________ ____________________________________________________________ ____________________________________________________________ ____________________________________________________________

4.3 Using a Variable Though it may initially seem more complicated to have words standing in for numbers, variables make our lives easier and more interesting. Let’s take a simple example of a program that draws a circle onscreen. In a moment, we’ll add variables at the top here. void setup() { size(200,200); } void draw() { background(255); stroke(0); fill(175); ellipse(100,100,50,50); }

50

Learning Processing

In Chapter 3, we learned how to take this simple example one step further, changing the location of a shape to mouseX, mouseY in order to assign its location according to the mouse. ellipse(mouseX,mouseY,50,50);

Can you see where this is going? mouseX and mouseY are named references to the horizonal and vertical location of the mouse. They are variables! However, because they are built into the Processing environment (note how they are colored red when you type them in your code), they can be used without being declared. Built-in variables (AKA “System” variables) are discussed further in the next section. What we want to do now is create our own variables by following the syntax for declaring and initializing outlined above, placing the variables at the top of our code. You can declare variables elsewhere in your code and we will get into this later. For now to avoid any confusion, all variables should be at the top.

Rule of Thumb: When to Use a Variable There are no hard and fast rules in terms of when to use a variable. However, if you ﬁnd yourself hard-coding in a bunch of numbers as you program, take a few minutes, review your code, and change these values to variables. Some programmers say that if a number appears three or more times, it should be a variable. Personally, I would say if a number appears once, use a variable. Always use variables!

Example 4-2: Using variables int circleX = 100; int circleY = 100;

Declare and initialize two integer variables at the top of the code.

void setup() { size(200,200); } void draw() { background(100); stroke(255); fill(0); ellipse(circleX,circleY,50,50); }

Use the variables to specify the location of an ellipse.

Running this code, we achieve the same result as in the ﬁrst example: a circle appears in the middle of the screen. Nevertheless, we should open our hearts and remind ourselves that a variable is not simply a placeholder for one constant value. We call it a variable because it varies. To change its value, we write an assignment operation, which assigns a new value. Up until now, every single line of code we wrote called a function: line( ), ellipse( ), stroke( ), etc. Variables introduce assignment operations to the mix. Here is what one looks like (it is the same as how we initialize a variable, only the variable does not need to be declared). variable name  expression

Variables x x x x

= = = =

5; a + b; y - 10 * 20; x * 5;

51

Examples of assigning a new value to a variables.

A common example is incrementation. In the above code, circleX starts with a value of 100. If we want to increment circleX by one, we say circleX equals itself plus one. In code, this amounts to “circleX  circleX  1;”. Let’s try adding that to our program (and let’s start circleX with the value of 0).

Example 4-3: Varying variables int circleX = 0; int circleY = 100; void setup() { size(200,200); } void draw() { background(255); stroke(0); fill(175); ellipse(circleX,circleY,50,50); circleX = circleX + 1; }

An assignment operation that increments the value of circleX by 1.

What happens? If you run Example 4-3 in Processing, you will notice that the circle moves from left to right. Remember, draw( ) loops over and over again, all the while retaining the value of circleX in memory. Let’s pretend we are the computer for a moment. (This may seem overly simple and obvious, but it is key to our understanding of the principles of programming motion.) 1. Remember circleX circle  0 and circleY circle  100 2. Run setup(). setup() Open a window 200  200 3. Run draw(). • Draw circle at (circle (circleX, circleY circle ) → (0,100) • Add one to circleX circle circleX circle  0  1  1 4. Run draw() • Draw circle at (circle (circleX, circleY circle ) → (1,100) • Add one to circleX circle circleX circle  1  1  2 5. Run draw() draw( • Draw circle at (circle (circleX, circleY circle ) → (2,100) • Add one to circleX circle circleX circle  2  1  3 6. And so on and so forth!

ﬁg. 4.5

Practicing how to follow the code step-by-step will lead you to the questions you need to ask before writing your own sketches. Be one with the computer.

52

Learning Processing

• What data do you and the computer need to remember for your sketch? • How do you and the computer use that data to draw shapes on the screen? • How do you and the computer alter that data to make your sketch interactive and animated?

Exercise 4-3: Change Example 4-3 so that instead of the circle moving from left to right, the circle grows in size. What would you change to have the circle follow the mouse as it grows? How could you vary the speed at which the circle grows? int circleSize = 0; int circleX = 100; int circleY = 100; void setup() { size(200,200); } void draw() { background(0); stroke(255); fill(175); _____________________________________ _____________________________________ }

4.4 Many Variables Let’s take the example one step further and use variables for every piece of information we can think of. We will also use ﬂoating point values to demonstrate greater precision in adjusting variable values. Example 4-4: Many variables float float float float float float float float

circleX = 0; circleY = 0; circleW = 50; circleH = 100; circleStroke = 255; circleFill = 0; backgroundColor = 255; change = 0.5;

// Your basic setup void setup() { size(200,200); smooth(); }

We’ve got eight variables now! All of type ﬂoat.

ﬁg. 4.6

Variables void draw() { // Draw the background and the ellipse background(backgroundColor); stroke(circleStroke); fill(circleFill); ellipse(circleX,circleY,circleW,circleH); // Change the values of all variables circleX = circleX + change; circleY = circleY + change; circleW = circleW + change; circleH = circleH - change; circleStroke = circleStroke - change; circleFill = circleFill + change;

53

Variables are used for everything: background, stroke, ﬁll, location, and size.

The variable change is used to increment and decrement the other variables.

}

Exercise 4-4 Step 1: Write code that draws the following screenshots with hard-coded values. (Feel free to use colors instead of grayscale.) Step 2: Replace all of the hard-coded numbers with variables. Step 3: Write assignment operations in draw( ) that change the value of the variables. For example, “variable1  variable1  2;”. Try diﬀerent expressions and see what happens!

4.5 System Variables As we saw with mouseX and mouseY, Processing has a set of convenient system variables freely available. These are commonly needed pieces of data associated with all sketches (such as the width of the window, the key pressed on the keyboard, etc.). When naming your own variables, it is best to avoid system variable names, however, if you inadvertently use one, your variable will become primary and override the system one. Here is a list of commonly used system variables (there are more, which you can ﬁnd in the Processing reference). • width—Width (in pixels) of sketch window. • height—Height (in pixels) of sketch window. • frameCount—Number of frames processed.

54

Learning Processing

• • • • • • • •

frameRate—Rate that frames are processed (per second). screen.width—Width (in pixels) of entire screen. screen.height—Height (in pixels) of entire screen. key—Most recent key pressed on the keyboard. keyCode—Numeric code for key pressed on keyboard. keyPressed—True or false? Is a key pressed? mousePressed—True or false? Is the mouse pressed? mouseButton—Which button is pressed? Left, right, or center?

Following is an example that makes use of some of the above variables; we are not ready to use them all yet, as we will need some more advanced concepts to make use of many features. Example 4-5: Using system variables void setup() { size(200,200); frameRate(30); } void draw() { background(100); stroke(255); fill(frameCount/2); frameCount is used to color a rectangle. rectMode(CENTER); rect(width/2,height/2,mouseX+10,mouseY+10); } void keyPressed() { println(key); }

The rectangle will always be in the middle of the window if it is located at (width/2, height/2).

Exercise 4-5: Using width and height, recreate the following screenshot. Here’s the catch: the shapes must resize themselves relative to the window size. (In other words, no matter what you specify for size( ), the result should look identical.)

Variables

55

4.6 Random: Variety is the spice of life. So, you may have noticed that the examples in this book so far are a bit, say, humdrum. A circle here. A square here. A grayish color. Another grayish color. There is a method to the madness (or lack of madness in this case). It all goes back to the driving principle behind this book: incremental development. It is much easier to learn the fundamentals by looking at the individual pieces, programs that do one and only one thing. We can then begin to add functionality on top, step by step. Nevertheless, we have waited patiently through four chapters and we have arrived at the time where we can begin to have a bit of fun. And this fun will be demonstrated via the use of the function random( ). Consider, for a moment, Example 4-6, whose output is shown in Figure 4.7.

Example 4-6: Ellipse with variables float float float float

r g b a

= = = =

100; 150; 200; 200;

float diam = 20; float x = 100; float y = 100; void setup() { size(200,200); background(255); smooth(); }

Declare and initialize your variables

ﬁg. 4.7

void draw() { // Use those variables to draw an ellipse stroke(0); fill(r,g,b,a); Use those variables! (Remember, the fourth ellipse(x,y,diam,diam); argument for a color is transparency). }

There it is, our dreary circle. Sure, we can adjust variable values and move the circle, grow its size, change its color, and so on. However, what if every time through draw( ), we could make a new circle, one with a random size, color, and position? The random( ) function allows us to do exactly that. random( ) is a special kind of function, it is a function that returns a value. We have encountered this before. In Exercise 3-7 we used the function abs( ) to calculate the absolute value of a number. The idea of a function that calculates a value and returns it will be explored fully in Chapter 7, but we are going to take some time to introduce the idea now and let it sink in a bit. Unlike most of the functions we are comfortable with (e.g., line( ), ellipse( ), and rect( )), random( ) does not draw or color a shape on the screen. Instead, random( ) answers a question; it returns that answer to us. Here is a bit of dialogue. Feel free to rehearse it with your friends.

56

Learning Processing

Me: Hey random, what’s going on? Hope you’re well. Listen, I was wondering, could you give me a random number between 1 and 100? Random: Like, no problem. How about the number 63? Me: That’s awesome, really great, thank you. OK, I’m oﬀ. Gotta draw a rectangle 63 pixels wide, OK?

Now, how would this sequence look in our slightly more formal, Processing environment? The code below the part of “me” is played by the variable “w ”. float w = random(1,100); rect(100,100,w,50);

A random ﬂoat between 1 and 100.

The random( ) function requires two arguments and returns a random ﬂoating point number ranging from the ﬁrst argument to the second. The second argument must be larger than the ﬁrst for it to work properly. The function random( ) also works with one argument by assuming a range between zero and that argument. In addition, random( ) only returns ﬂoating point numbers. This is why we declared “w ” above as a ﬂoat. However, if you want a random integer, you can convert the result of the random function to an int. int w = int(random(1,100)); rect(100,100,w,50);

A random integer between 1 and 100.

Notice the use of nested parentheses. This is a nice concept to get used to as it will be quite convenient to call functions inside of functions as we go. The random( ) function returns a ﬂoat, which is then passed to the int( ) function that converts it to an integer. If we wanted to go nuts nesting functions, we could even condense the above code into one line: rect(100,100,int(random(1,100)),50);

Incidentally, the process of converting one data type to another is referred to as “casting.” In Java (which Processing is based on) casting a ﬂoat to an integer can also be written this way:

int w = (int) random(1,100);

The result of random (1,100) is a ﬂoat. It can be converted to an integer by “casting.”

OK, we are now ready to experiment with random( ). Example 4-7 shows what happens if we take every variable associated with drawing the ellipse (ﬁll, location, size) and assign it to a random number each cycle through draw( ). The output is shown in Figure 4.8.

Variables

57

Example 4-7: Filling variables with random values float float float float

r; g; b; a;

float diam; float x; float y; void setup() { size(200,200); background(0); smooth(); }

ﬁg. 4.8

void draw() { // Fill all variables with random values r = random(255); g = random(255); b = random(255); Each time through draw(), new random a = random(255); numbers are picked for a new ellipse. diam = random(20); x = random(width); y = random(height); // Use values to draw an ellipse noStroke(); fill(r,g,b,a); ellipse(x,y,diam,diam); }

4.7 Variable Zoog We are now ready to revisit Zoog, our alien friend, who was happily following the mouse around the screen when we last checked in. Here, we will add two pieces of functionality to Zoog. • New feature #1—Zoog will rise from below the screen and fly off into space (above the screen). • New feature #2—Zoog’s eyes will be colored randomly as Zoog moves. Feature #1 is solved by simply taking the previous program that used mouseX and mouseY and substituting our own variables in their place. Feature #2 is implemented by creating three additional variables eyeRed, eyeGreen, and eyeBlue that will be used for the ﬁll( ) function before displaying the eye ellipses. Example 4-8: Variable Zoog float zoogX; float zoogY;

Declaring variables. zoogX and zoogY are for feature #1. eyeR, eyeG, eyeB are for feature #2.

float eyeR; float eyeG; float eyeB; void setup() { size(200,200); ﬁg. 4.9

58

Learning Processing zoogX = width/2; // Zoog always starts in the middle zoogY = height + 100; // Zoog starts below the screen smooth(); }

Feature #1. zoogX and zoogY are initialized based on the size of the window. Note we cannot initialize these variables before the size () function is called since we are using the built-in variables width and height.

void draw() { background(255);

// Set ellipses and rects to CENTER mode ellipseMode(CENTER); rectMode(CENTER); // Draw Zoog's body stroke(0); fill(150); rect(zoogX,zoogY,20,100);

Feature #1. zoogX and zoogY are used for the shape locations.

// Draw Zoog's head stroke(0); fill(255); ellipse(zoogX,zoogY-30,60,60); // Draw Zoog's eyes eyeR = random(255); eyeG = random(255); eyeB = random(255); fill(eyeR,eyeG,eyeB);

Feature #2. eyeR, eyeG, and eye B are given random values and used in the ﬁll() function.

ellipse(zoogX-19,zoogY-30,16,32); ellipse(zoogX+19,zoogY-30,16,32); // Draw Zoog's legs stroke(150); line(zoogX-10,zoogY+50,zoogX-10,height); line(zoogX+10,zoogY+50,zoogX+10,height); // Zoog moves up zoogY = zoogY - 1; }

Feature #1. zoogY is decreased by one so that zoog moves upward on the screen.

Exercise 4-6: Revise Example 4-8 so that Zoog shakes left and right as Zoog moves upward. Hint: this requires the use of random( ) in combination with zoogX. zoogX = _____________________________;

Exercise 4-7: Using variables and the random( ) function, revise your design from the Lesson One Project to move around the screen, change color, size, location, and so on.

Conditionals

59

5 Conditionals “ That language is an instrument of human reason, and not merely a medium for the expression of thought, is a truth generally admitted.” —George Boole “ The way I feel about music is that there is no right and wrong. Only true and false.” —Fiona Apple In this chapter: – Boolean expressions. – Conditional statements: How a program produces different results based on varying circumstances. – If, Else If, Else.

5.1 Boolean Expressions What’s your favorite kind of test? Essay format? Multiple choice? In the world of computer programming, we only take one kind of test: a boolean test—true or false. A boolean expression (named for mathematician George Boole) is an expression that evaluates to either true or false. Let’s look at some common language examples: • I am hungry. • I am afraid of computer programming. • This book is a hilarious read.

→ true → false → false

In the formal logic of computer science, we test relationships between numbers. • 15 is greater than 20 • 5 equals 5 • 32 is less than or equal to 33

→ false → true → true

In this chapter, we will learn how to use a variable in a boolean expression, allowing our sketch to take diﬀerent paths depending on the current value stored in the variable. • x  20 • y  5 • z  33

→ depends on current value of x → depends on current value of y → depends on current value of z

The following operators can be used in a boolean expression.

Relational Operators   

greater than less than greater than or equal to

  !

less than or equal to equality inequality

60

Learning Processing

5.2 Conditionals: If, Else, Else If Boolean expressions (often referred to as “conditionals”) operate within the sketch as questions. Is 15 greater than 20? If the answer is yes (i.e., true), we can choose to execute certain instructions (such as draw a rectangle); if the answer is no (i.e., false), those instructions are ignored. This introduces the idea of branching; depending on various conditions, the program can follow diﬀerent paths. In the physical world, this might amount to instructions like so: If I am hungry then eat some food, otherwise if I am thirsty, drink some water, otherwise, take a nap. In Processing, we might have something more like: If the mouse is on the left side of the screen, draw a rectangle on the left side of the screen. Or, more formally, with the output shown in Figure 5.1, if (mouseX < width/2) { fill(255); rect(0,0,width/2,height); }

The boolean expression and resulting instructions in the above source code is contained within a block of code with the following syntax and structure: ﬁg. 5.1

if (boolean expression) { // code to execute if boolean expression is true } The structure can be expanded with the keyword else to include code that is executed if the boolean expression is false. This is the equivalent of “otherwise, do such and such.” if (boolean expression) { // code to execute if boolean expression is true } else { // code to execute if boolean expression is false } For example, we could say the following, with the output shown in Figure 5.2. If the mouse is on the left side of the screen, draw a white background, otherwise draw a black background. if (mouseX < width/2) { background(255); } else { background(0); }

ﬁg. 5.2

Conditionals

Finally, for testing multiple conditions, we can employ an “else if.” When an else if is used, the conditional statements are evaluated in the order presented. As soon as one boolean expression is found to be true, the corresponding code is executed and the remaining boolean expressions are ignored. See Figure 5.3. if (boolean expression #1) { // code to execute if boolean expression #1 is true } else if (boolean expression #2) { // code to execute if boolean expression #2 is true } else if (boolean expression #n) { // code to execute if boolean expression #n is true } else { // code to execute if none of the above // boolean expressions are true } Taking our simple mouse example a step further, we could say the following, with results shown in Figure 5.4.

if (A is true) No

Yes

Do this. And this. else if (B is true) No

Yes

Do this. And this. else if (C is true) No

Yes Do this. And this.

else Do this. And this.

If the mouse is on the left third of the window, draw a white background, if it is in the middle third, draw a gray background, otherwise, draw a black background. if (mouseX < width/3) { background(255); } else if (mouseX < 2*width/3) { background(127); } else { background(0); }

Now on to something else.... ﬁg. 5.3

ﬁg. 5.4

Exercise 5-1: Consider a grading system where numbers are turned into letters. Fill in the blanks in the following code to complete the boolean expression. float grade = random(0,100); if (_______) { println("Assign letter grade A."); } else if (________) { println (________);

61

In one conditional statement, you can only ever have one if and one else. However, you can have as many else if ’s as you like!

62

Pixels, Patterns, and Processing

} else if (________) { println(________); } else if (________) { println(________); } else { println(________); }

Exercise 5-2: Examine the following code samples and determine what will appear in the message window. Write down your answer and then execute the code in Processing to compare. Problem #1: Determine if a number is between 0 and 25, 26 and 50, or greater than 50. int x = 75;

int x = 75;

if (x > 50) {

if(x > 25) { println(x + " is greater

println(x + " is greater than

than 25!");

50!"); } else if (x > 25) {

} else if (x > 50) { println(x + " is greater

println(x + " is greater than

than 50!");

25!"); } else {

} else { println(x + " is 25 or

println(x + " is 25 or

less!");

less!"); }

} OUTPUT:____________________

OUTPUT:____________________

Although the syntax is correct, what is problematic about the code in column two above?

Conditionals

63

Problem #2: If a number is 5, change it to 6. If a number is 6, change it to ﬁve. int x = 5;

int x = 5; println("x is now: " + x);

println("x is now: " + x);

if (x == 5) {

if (x == 5) { x = 6;

x = 6;

} else if (x == 6) {

}

x = 5;

if (x == 6) { }

x = 5;

println("x is now: " + x);

} println("x is now: " + x); OUTPUT:____________________

OUTPUT:____________________

Although the syntax is correct, what is problematic about the code in column one above?

It is worth pointing out that in Exercise 5-2 when we test for equality we must use two equal signs. This is because, when programming, asking if something is equal is diﬀerent from assigning a value to a variable. if (x == y) {

“Is x equal to y?” Use double equals!

x = y;

“Set x equal to y.” Use single equals!

5.3 Conditionals in a Sketch Let’s look at a very simple example of a program that performs diﬀerent tasks based on the result of certain conditions. Our pseudocode is below. Step 1. Create variables to hold on to red, green, and blue color components. Call them r, g, and b. Step 2. Continuously draw the background based on those colors. Step 3. If the mouse is on the right-hand side of the screen, increment the value of r, if it is on the left-hand side decrement the value of r. Step 4. Constrain the value r to be within 0 and 255. This pseudocode is implemented in Processing in Example 5-1.

64

Learning Processing Example 5-1: Conditionals float r = 150; float g = 0; float b = 0;

1. Variables.

void setup() { size(200,200); } void draw() { 2. Draw stuff. background(r,g,b); stroke(255); line(width/2,0,width/2,height); if(mouseX > width/2) { r = r + 1; } else { r = r - 1; }

3. “If the mouse is on the right side of the screen” is equivalent to “if mouseX is greater than width divided by 2.”

if (r > 255) { r = 255; } else if (r < 0) { r = 0; }

4. If r is greater than 255, set it to 255. If r is less than 0, set it to 0.

ﬁg. 5.5

}

Constraining the value of a variable, as in Step 4, is a common problem. Here, we do not want color values to increase to unreasonable extremes. In other examples, we might want to constrain the size or location of a shape so that it does not get too big or too small, or wander oﬀ the screen. While using if statements is a perfectly valid solution to the constrain problem, Processing does oﬀer a function entitled constrain( ) that will get us the same result in one line of code.

if (r > 255) { r = 255; } else if (r < 0) { r = 0; }

Constrain with an “if” statement.

r = constrain(r,0,255);

Constrain with the constrain( ) function.

constrain( ) takes three arguments: the value we intend to constrain, the minimum limit, and the maximum limit. The function returns the “constrained” value and is assigned back to the variable r. (Remember what it means for a function to return a value? See our discussion of random( ).)

Conditionals

Getting into the habit of constraining values is a great way to avoid errors; no matter how sure you are that your variables will stay within a given range, there are no guarantees other than constrain( ) itself. And someday, as you work on larger software projects with multiple programmers, functions such as constrain( ) can ensure that sections of code work well together. Handling errors before they happen in code is emblematic of good style. Let’s make our ﬁrst example a bit more advanced and change all three color components according to the mouse location and click state. Note the use of constrain( ) for all three variables. The system variable mousePressed is true or false depending on whether the user is holding down the mouse button.

Example 5-2: More conditionals float r = 0; float b = 0; float g = 0;

Three variables for the background color.

void setup() { size(200,200); } void draw() { background(r,g,b); stroke(0);

Color the background and draw lines to divide the window into quadrants.

line(width/2,0,width/2,height); line(0,height/2,width,height/2); if(mouseX > width/2) { r = r + 1; } else { r = r - 1; }

If the mouse is on the right-hand side of the window, increase red. Otherwise, it is on the left-hand side and decrease red.

if (mouseY > height/2) { b = b + 1; } else { b = b - 1; }

If the mouse is on the bottom of the window, increase blue. Otherwise, it is on the top and decrease blue.

if (mousePressed) { g = g + 1; } else { g = g - 1; } r = constrain(r,0,255); g = constrain(g,0,255); b = constrain(b,0,255); }

If the mouse is pressed (using the system variable mousePressed) increase green.

Constrain all color values to between 0 and 255.

ﬁg. 5.6

65

66

Learning Processing

Exercise 5-3: Move a rectangle across a window by incrementing a variable. Start the shape at x coordinate 0 and use an if statement to have it stop at coordinate 100. Rewrite the sketch to use constrain( ) instead of the if statement. Fill in the missing code. // Rectangle starts at location x float x = 0; void setup() { size(200,200); } void draw() { background(255); // Display object fill(0); rect(x,100,20,20); // Increment x x = x + 1; ______________________________________________ ______________________________________________ ______________________________________________ }

5.4 Logical Operators We have conquered the simple if statement: If my temperature is greater than 98.6, then take me to see the doctor. Sometimes, however, simply performing a task based on one condition is not enough. For example: If my temperature is greater than 98.6 OR I have a rash on my arm, take me to see the doctor. If I am stung by a bee AND I am allergic to bees, take me to see the doctor. We will commonly want to do the same thing in programming from time to time. If the mouse is on the right side of the screen AND the mouse is on the bottom of the screen, draw a rectangle in the bottom right corner.

Conditionals

67

Our ﬁrst instinct might be to write the above code using a nested if statement, like so: if (mouseX > width/2) { if (mouseY > height/2) { fill(255); rect(width/2,height/2,width/2,height/2); } }

In other words, we would have to bypass two if statements before we can reach the code we want to execute. This works, yes, but can be accomplished in a simpler way using what we will call a “ logical and,” written as two ampersands (“&&”). A single ampersand (“&”) means something else1 in Processing so make sure you include two!

|| (logical OR) && (logical AND) ! (logical NOT)

A “ logical or” is two vertical bars (AKA two “pipes”) “||”. If you can’t ﬁnd the pipe, it is typically on the keyboard as shift-backslash. if (mouseX > width/2 && mouseY > height/2) { fill(255); rect(width/2,height/2,width/2,height/2); }

If the mouse is on the right side and on the bottom.

In addition to && and ||, we also have access to the logical operator “not,” written as an exclamation point: ! If my temperature is NOT greater than 98.6, I won’t call in sick to work. If I am stung by a bee AND I am NOT allergic to bees, do not worry! A Processing example is: If the mouse is NOT pressed, draw a circle, otherwise draw a square. if (!mousePressed) { ellipse(width/2,height/2,100,100); } else { rect(width/2,height/2,100,100); }

! means not. “mousePressed” is a boolean variable that acts as its own boolean expression. Its value is either true or false (depending on whether or not the mouse is currently pressed). Boolean variables will be explored in greater detail in Section 5.6.

Notice this example could also be written omitting the not, saying: If the mouse is pressed, draw a square, otherwise draw a circle.

1

“&” or “|” are reserved for bitwise operations in Processing. A bitwise operation compares each bit (0 or 1) of the binary representations of two numbers. It is used in rare circumstances where you require low-level access to bits.

68

Learning Processing

Exercise 5-4: Are the following boolean expressions true or false? Assume variables x  5 and y  6. !(x > 6)

_____________________________________

(x==6 && x==5)_____________________________________ (x==6 || x==5)_____________________________________ (x>-1 && y 10

&&

x < 5)________________________________

Exercise 5-5: Write a program that implements a simple rollover. In other words, if the

mouse is over a rectangle, the rectangle changes color. Here is some code to get you started. int x = 50; int y = 50; int w = 100; int h = 75; void setup() { size(200,200); } void draw() { background(0); stroke(255); if (_______ && _______ && _______ && _______) { _______ } _______ { _______ } rect(x,y,w,h); }

Conditionals

5.5 Multiple Rollovers Let’s solve a simple problem together, a slightly more advanced version of Exercise 5-5. Consider the four screenshots shown in Figure 5.7 from one single sketch. A white square is displayed in one of four quadrants, according to the mouse location.

ﬁg. 5.7

Let’s ﬁrst write the logic of our program in pseudocode (i.e., English). Setup: 1.

Set up a window of 200  200 pixels.

Draw: 1. 2. 3. 4. 5. 6.

Draw a white background. Draw horizontal and vertical lines to divide the window in four quadrants. If the mouse is in the top left corner, draw a black rectangle in the top left corner. If the mouse is in the top right corner, draw a black rectangle in the top right corner. If the mouse is in the bottom left corner, draw a black rectangle in the bottom left corner. If the mouse is in the bottom right corner, draw a black rectangle in the bottom right corner.

For instructions 3 through 6, we have to ask ourselves the question: “How do we know if the mouse is in a given corner?” To accomplish this, we need to develop a more speciﬁc if statement. For example, we would say: “If the mouse X location is greater than 100 pixels and the mouse Y location is greater than 100 pixels, draw a black rectangle in the bottom right corner. As an exercise, you may want to try writing this program yourself based on the above pseudocode. The answer, for your reference, is given in Example 5-3.

Example 5-3: Rollovers void setup() { size(200,200); } void draw() { background(255); stroke(0); line(100,0,100,200); line(0,100,200,100);

69

70

Learning Processing // Fill a black color noStroke(); fill(0); if (mouseX < 100 && mouseY rect(0,0,100,100); } else if (mouseX > 100 && rect(100,0,100,100); } else if (mouseX < 100 && rect(0,100,100,100); } else if (mouseX > 100 && rect(100,100,100,100); }

< 100) { mouseY < 100) {

Depending on the mouse location, a different rectangle is displayed.

mouseY > 100) { mouseY > 100) {

}

Exercise 5-6: Rewrite Example 5-3 so that the squares fade from white to black when the mouse leaves their area. Hint: you need four variables, one for each rectangle’s color.

5.6 Boolean Variables The natural next step up from programming a rollover is a button. After all, a button is just a rollover that responds when clicked. Now, it may feel ever so slightly disappointing to be programming rollovers and buttons. Perhaps you are thinking: “Can’t I just select ‘Add Button’ from the menu or something?” For us, right now, the answer is no. Yes, we are going to eventually learn how to use code from a library (and you might use a library to make buttons in your sketches more easily), but there is a lot of value in learning how to program GUI (graphical user interface) elements from scratch. For one, practicing programming buttons, rollovers, and sliders is an excellent way to learn the basics of variables and conditionals. And two, using the same old buttons and rollovers that every program has is not terribly exciting. If you care about and are interested in developing new interfaces, understanding how to build an interface from scratch is a skill you will need. OK, with that out of the way, we are going to look at how we use a boolean variable to program a button. A boolean variable (or a variable of type boolean) is a variable that can only be true or false. Think of it as a switch. It is either on or oﬀ. Press the button, turn the switch on. Press the button again, turn it oﬀ. We just used a boolean variable in Example 5-2: the built-in variable mousePressed. mousePressed is true when the mouse is pressed and false when the mouse is not. And so our button example will include one boolean variable with a starting value of false (the assumption being that the button starts in the oﬀ state). boolean button = false;

A boolean variables is either true of false.

In the case of a rollover, any time the mouse hovered over the rectangle, it turned white. Our sketch will turn the background white when the button is pressed and black when it is not. if (button) { background(255); } else { background(0); }

If the value of button is true, the background is white. If it is false, black.

Conditionals

71

We can then check to see if the mouse location is inside the rectangle and if the mouse is pressed, setting the value of button to true or false accordingly. Here is the full example:

Example 5-4: Hold down the button boolean button = false; int int int int

x y w h

= = = =

50; 50; 100; 75;

void setup() { size(200,200); } void draw() { if (mouseX > x && mouseX < x+w && mouseY > y && mouseY < y+h && mousePressed) { button = true; } else { The button is pressed if (mouseX, mouseY) is button = false; } inside the rectangle and mousePressed is true. if (button) { background(255); stroke(0); } else { background(0); stroke(255); } fill(175); rect(x,y,w,h); }

This example simulates a button connected to a light that is only on when the button is pressed. As soon as you let go, the light goes oﬀ. While this might be a perfectly appropriate form of interaction for some instances, it is not what we are really going for in this section. What we want is a button that operates like a switch; when you ﬂip the switch (press the button), if the light is oﬀ, it turns on. If it is on, it turns oﬀ. For this to work properly, we must check to see if the mouse is located inside the rectangle inside mousePressed( ) rather than as above in draw( ). By deﬁnition, when the user clicks the mouse, the code inside mousePressed( ) is executed once and only once (see Section 3.4). When the mouse is clicked, we want the switch to turn on or oﬀ (once and only once). We now need to write some code that “toggles” the switch, changes its state from on to oﬀ, or oﬀ to on. This code will go inside mousePressed( ). If the variable “ button” equals true, we should set it to false. If it is false, we should set it to true.

72

Learning Processing if (button) { button = false; } else { button = true; }

The explicit way to toggle a boolean variable. If the value of button is true, set it equal to false. Otherwise, it must be false, so set it equal to true.

There is a simpler way to go which is the following: button = !button;

Not true is false. Not false is true!

Here, the value of button is set to “not ” itself. In other words, if the button is true then we set set it to not true (false). If it is false then we set it to not false (true). Armed with this odd but eﬀective line of code, we are ready to look at the button in action in Example 5-5.

Example 5-5: Button as switch boolean button = false; int int int int

x y w h

= = = =

50; 50; 100; 75;

void setup() { size(200,200); }

ﬁg. 5.8

void draw() { if (button) { background(255); stroke(0); } else { background(0); stroke(255); } fill(175); rect(x,y,w,h); }

When the mouse is pressed, the state of the button is toggled. Try moving this code to draw( ) like in the rollover example. (See Exercise 5–7.)

void mousePressed() { if (mouseX > x && mouseX < x+w && mouseY > y && mouseY < y+h){ button = !button; } }

Exercise 5-7: Why doesn’t the following code work properly when it is moved to draw( )? if (mouseX > x && mouseX < x+w && mouseY > y && mouseY < y+h && mousePressed){ button = !button; }

Conditionals

73

Exercise 5-8: Example 4-3 in the previous chapter moved a circle across the window. Change the sketch so that the circle only starts moving once the mouse has been pressed. Use a boolean variable. boolean __________ = _________; int circleX = 0; int circleY = 100; void setup() { size(200,200); } void draw() { background(100); stroke(255); fill(0); ellipse(circleX,circleY,50,50); ____________________________________ ____________________________________ ____________________________________ } void mousePressed() { ____________________________________ }

5.7 A Bouncing Ball It is time again to return to our friend Zoog. Let’s review what we have done so far. First, we learned to draw Zoog with shape functions available from the Processing reference. Afterward, we realized we could use variables instead of hard-coded values. Having these variables allowed us move Zoog. If Zoog’s location is X, draw it at X, then at X  1, then at X  2, and so on. It was an exciting, yet sad moment. The pleasure we experienced from discovering the motion was quickly replaced by the lonely feeling of watching Zoog leave the screen. Fortunately, conditional statements are here to save the day, allowing us to ask the question: Has Zoog reached the edge of the screen? If so, turn Zoog around! To simplify things, let’s start with a simple circle instead of Zoog’s entire pattern. Write a program where Zoog (a simple circle) moves across the screen horizontally from left to right. When it reaches the right edge it reverses direction.

74

Learning Processing

From the previous chapter on variables, we know we need global variables to keep track of Zoog’s location. int x = 0;

Is this enough? No. In our previous example Zoog always moved one pixel. x = x + 1;

This tells Zoog to move to the right. But what if we want it to move to the left? Easy, right? x = x - 1;

In other words, sometimes Zoog moves with a speed of “1” and sometimes “1.” The speed of Zoog varies. Yes, bells are ringing. In order to switch the direction of Zoog’s speed, we need another variable: speed. int x = 0; int speed = l;

A variable for Zoog’s speed. When speed is positive Zoog moves to the right, when speed is negative Zoog moves to the left.

Now that we have our variables, we can move on to the rest of the code. Assuming setup( ) sets the size of the window, we can go directly to examining the steps required inside of draw( ). We can also refer to Zoog as a ball in this instance since we are just going to draw a circle.

background(0); stroke(255); fill(100); ellipse(x,100,32,32);

For simplicity, Zoog is just a circle.

Elementary stuﬀ. Now, in order for the ball to move, the value of its x location should change each cycle through draw( ). x = x + speed;

If we ran the program now, the circle would start on the left side of the window, move toward the right, and continue oﬀ the edge of the screen—this is the result we achieved in Chapter 4. In order for it to turn around, we need a conditional statement. If the ball goes oﬀ the edge, turn the ball around. Or more formally. . . If x is greater than width, reverse speed. if (x > width) { speed = speed * -1; }

Multiplying by 1 reverses the speed.

Conditionals

75

Reversing the Polarity of a Number When we want to reverse the polarity of a number, we mean that we want a positive number to become negative and a negative number to become positive. This is achieved by multiplying by –1. Remind yourself of the following: • • • •

-5 -5 -1 -1

* -1 = 5 * -1 = -5 * 1 = -1 * -1 = 1

Running the sketch, we now have a circle that turns around when it reaches the right-most edge, but runs oﬀ the left-most edge of the screen. We’ll need to revise the conditional slightly. If the ball goes oﬀ either the right or left edge, turn the ball around. Or more formally. . . If x is greater than width or if x is less than zero, reverse speed. if ((x > width) || (x < 0)) { speed = speed * -1; }

Remember, 储 means “or”.

Example 5-6 puts it all together.

Example 5-6: Bouncing ball int x = 0; int speed = 1; void setup() { size(200,200); smooth(); } void draw() { background(255); x = x + speed; if ((x > width) || (x < 0)){ speed = speed * -1; } // Display circle at x location stroke(0); fill(175); ellipse(x,100,32,32); }

Add the current speed to the x location.

If the object reaches either edge, multiply speed by 1 to turn it around.

76

Learning Processing

Exercise 5-9: Rewrite Example 5-6 so that the ball not only moves horizontally, but vertically as well. Can you implement additional features, such as changing the size or color of the ball based on certain conditions? Can you make the ball speed up or slow down in addition to changing direction? The “ bouncing ball” logic of incrementing and decrementing a variable can be applied in many ways beyond the motion of shapes onscreen. For example, just as a square moves from left to right, a color can go from less red to more red. Example 5-7 takes the same bouncing ball algorithm and applies it to changing color.

Example 5-7: “Bouncing” color float c1 = 0; float c2 = 255; float c1dir = 0.1; float c2dir = -0.1;

Two variables for color.

Start by incrementing c1. Start by decrementing c2.

void setup() { size(200,200); } void draw() { noStroke();

ﬁg. 5.9

// Draw rectangle on left fill(c1,0,c2); rect(0,0,100,200); // Draw rectangle on right fill(c2,0,c1); rect(100,0,100,200); // Adjust color values c1 = c1 + c1dir; c2 = c2 + c2dir; // Reverse direction of color change if (c1 < 0 || c1 > 255) { c1dir *= -1; } if (c2 < 0 || c2 > 255) { c2dir *= -1; }

Instead of reaching the edge of a window, these variables reach the “edge” of color: 0 for no color and 255 for full color. When this happens, just like with the bouncing ball, the direction is reversed.

}

Having the conditional statement in our collection of programming tools allows for more complex motion. For example, consider a rectangle that follows the edges of a window.

Conditionals

77

One way to solve this problem is to think of the rectangle’s motion as having four possible states, numbered 0 through 3. See Figure 5.10. • • • •

State #0: left to right. State #1: top to bottom. State #2: right to left. State #3: bottom to top.

We can use a variable to keep track of the state number and adjust the x, y coordinate of the rectangle according to the state. For example: “If the state is 2, x equals x minus 1.”

ﬁg. 5.10

Once the rectangle reaches the endpoint for that state, we can change the state variable. “If the state is 2: (a) x equals x minus 1. (b) if x less than zero, the state equals 3.” The following example implements this logic.

Example 5-8: Square following edge, uses a “state” variable int x = 0; // x location of square int y = 0; // y location of square int speed = 5; // speed of square int state = 0; void setup() { size(200,200); }

A variable to keep track of the square’s “state.” Depending on the value of its state, it will either move right, down, left, or up. ﬁg. 5.11

void draw(){ background(100); // Display the square noStroke(); fill(255); rect(x,y,10,10); if (state == 0) { x = x + speed; if (x > width-10) { x = width-10; state = 1; } } else if (state == 1) { y = y + speed; if (y > height-10) { y = height-10; state = 2; }

If the state is 0, move to the right. If, while the state is 0, it reaches the right side of the window, change the state to 1. Repeat this same logic for all states!

78

Learning Processing } else if (state == 2) { x = x - speed; if (x < 0) { x = 0; state = 3; } } else if (state == 3) { y = y - speed; if (y < 0) { y = 0; state = 0; } } }

5.8 Physics 101 For me, one of the happiest moments of my programming life was the moment I realized I could code gravity. And in fact, armed with variables and conditionals, you are now ready for this moment. The bouncing ball sketch taught us that an object moves by altering its location according to speed. location  location  speed Gravity is a force of attraction between all masses. When you drop a pen, the force of gravity from the earth (which is overwhelmingly larger than the pen) causes the pen to accelerate toward the ground. What we must add to our bouncing ball is the concept of “acceleration” (which is caused by gravity, but could be caused by any number of forces). Acceleration increases (or decreases) speed. In other words, acceleration is the rate of change of speed. And speed is the rate of change of location. So we just need another line of code: speed  speed  acceleration And now we have a simple gravity simulation.

Example 5-9: Simple gravity float x = 100; // x location of square float y = 0; // y location of square float speed = 0; // speed of square float gravity = 0.1; void setup() { size(200,200); } void draw() { background(255);

A new variable, for gravity (i.e., acceleration). We use a relatively small number (0.1) because this acceleration accumulates over time, increasing the speed. Try changing this number to 2.0 and see what happens.

ﬁg. 5.12

Conditionals // Display the square fill(0); noStroke(); rectMode(CENTER); rect(x,y,10, 10);

}

y = y + speed;

Add speed to location.

speed = speed + gravity;

Add gravity to speed.

// If square reaches the bottom // Reverse speed if (y > height) { speed = speed * -0.95; Multiplying by 0.95 instead of 1 slows the square down } each time it bounces (by decreasing speed). This is known

as a “dampening” effect and is a more realistic simulation of the real world (without it, a ball would bounce forever).

Exercise 5-10: Continue with your design and add some of the functionality demonstrated in this chapter. Some options: • Make parts of your design rollovers that change color when the mouse is over certain areas. • Move it around the screen. Can you make it bounce off all edges of the window? • Fade colors in and out.

Here is a simple version with Zoog.

Example 5-10: Zoog and conditionals float float float float float

x = 100; y = 100; w = 60; h = 60; eyeSize = 16;

float xspeed = 3; float yspeed = 1;

Zoog has variables for speed in the horizontal and vertical direction.

void setup() { size(200,200); smooth(); } void draw() { // Change the location of Zoog by speed x = x + xspeed; y = y + yspeed;

79

80

Learning Processing if ((x > width) 储 (x < 0)) { xspeed = xspeed * -1; }

if ((y > height) 储 (y < 0)) { yspeed = yspeed * -1; }

An IF statements with a logical OR determines if Zoog has reached either the right or left edges of the screen. When this is true, we multiply the speed by 1, reversing Zoog’s direction! Identical logic is applied to the y direction as well.

background(0); ellipseMode(CENTER); rectMode(CENTER); noStroke(); // Draw Zoog's body fill(150); rect(x,y,w/6,h*2); // Draw Zoog's head fill(255); ellipse(x,y-h/2,w,h); // Draw Zoog's eyes fill(0); ellipse(x-w/3,y-h/2,eyeSize,eyeSize*2); ellipse(x+w/3,y-h/2,eyeSize,eyeSize*2); // Draw Zoog's legs stroke(150); line(x-w/12,y+h,x-w/4,y+h+10); line(x+w/12,y+h,x+w/4,y+h+10); }

Loops

81

6 Loops “Repetition is the reality and the seriousness of life.” —Soren Kierkegaard “ What’s the key to comedy? Repetition. What’s the key to comedy? Repetition.” —Anonymous In this chapter: – The concept of iteration. – Two types of loops: “while,” and “for.” When do we use them? – Iteration in the context of computer graphics.

6.1 What is iteration? I mean, what is iteration? Seriously, what is iteration? Iteration is the generative process of repeating a set of rules or steps over and over again. It is a fundamental concept in computer programming and we will soon come to discover that it makes our lives as coders quite delightful. Let’s begin. For the moment, think about legs. Lots and lots of legs on our little Zoog. If we had only read Chapter 1 of this book, we would probably write some code as in Example 6-1.

Example 6-1: Many lines size(200,200); background(255); // Legs stroke(0); line(50,60,50,80); line(60,60,60,80); line(70,60,70,80); line(80,60,80,80); line(90,60,90,80); line(100,60,100,80); line(110,60,110,80); line(120,60,120,80); line(130,60,130,80); line(140,60,140,80); line(150,60,150,80);

ﬁg. 6.1

In the above example, legs are drawn from x = 50 pixels all the way to x  150 pixels, with one leg every 10 pixels. Sure, the code accomplishes this, however, having learned variables in Chapter 4, we can make some substantial improvements and eliminate the hard-coded values. First, we set up variables for each parameter of our system: the legs’ x, y locations, length, and the spacing between the legs. Note that for each leg drawn, only the x value changes. All other variables stay the same (but they could change if we wanted them to!).

82

Learning processing Example 6-2: Many lines with variables size(200,200); background(0); // Legs stroke(255); int int int int

y = 80; x = 50; spacing = 10; len = 20;

line(x,y,x,y+len); x = x + spacing; line(x,y,x,y+len);

// // // //

Vertical location of each line Initial horizontal location for first line How far apart is each line Length of each line

Draw the ﬁrst leg.

Add spacing so the next leg appears 10 pixels to the right.

x = x + spacing; line(x,y,x,y+len); x = x + spacing; line(x,y,x,y+len); x = x + spacing; line(x,y,x,y+len);

Continue this process for each leg, repeating it over and over.

x = x + spacing; line(x,y,x,y+len); x = x + spacing; line(x,y,x,y+len); x = x + spacing; line(x,y,x,y+len); x = x + spacing; line(x,y,x,y+len); x = x + spacing; line(x,y,x,y+len); x = x + spacing; line(x,y,x,y+len);

Not too bad, I suppose. Strangely enough, although this is technically more eﬃcient (we could adjust the spacing variable, for example, by changing only one line of code), we have taken a step backward, having produced twice as much code! And what if we wanted to draw 100 legs? For every leg, we need two lines of code. That’s 200 lines of code for 100 legs! To avoid this dire, carpal-tunnel inducing problem, we want to be able to say something like: Draw one line one hundred times. Aha, only one line of code! Obviously, we are not the ﬁrst programmers to reach this dilemma and it is easily solved with the very commonly used control structure—the loop. A loop structure is similar in syntax to a conditional

Loops

83

(see Chapter 5). However, instead of asking a yes or no question to determine whether a block of code should be executed one time, our code will ask a yes or no question to determine how many times the block of code should be repeated. This is known as iteration.

6.2 “WHILE” Loop, the Only Loop You Really Need There are three types of loops, the while loop, the do-while loop, and the for loop. To get started, we are going to focus on the while loop for a little while (sorry, couldn’t resist). For one thing, the only loop you really need is while. The for loop, as we will see, is simply a convenient alternative, a great shorthand for simple counting operations. Do-while, however, is rarely used (not one example in this book requires it) and so we will ignore it. Just as with conditional (if/else) structures, a while loop employs a boolean test condition. If the test evaluates to true, the instructions enclosed in curly brackets are executed; if it is false, we continue on to the next line of code. The diﬀerence here is that the instructions inside the while block continue to be executed over and over again until the test condition becomes false. See Figure 6.2. WHILE

(BOOLEAN TEST) A. DO THIS

IS TRUE

IS FALSE

B. DO THIS REPEAT

ﬁg. 6.2

Let’s take the code from the legs problem. Assuming the following variables . . . int int int int

y = 80; x = 50; spacing = 10; len = 20;

// // // //

Vertical location of each line Initial horizontal location for first line How far apart is each line Length of each line

… we had to manually repeat the following code: stroke(255); line(x,y,x,y+len);

// Draw the first leg

x = x + spacing; line(x,y,x,y+len);

// Add "spacing" to x // The next leg is 10 pixels to the right

x = x + spacing; line(x,y,x,y+len);

// Add "spacing" to x // The next leg is 10 pixels to the right

x = x + spacing; line(x,y,x,y+len);

// Add ''spacing” to x // The next leg is 10 pixels to the right

// etc. etc. repeating with new legs

84

Learning processing

Now, with the knowledge of the existence of while loops, we can rewrite the code as in Example 6-3, adding a variable that tells us when to stop looping, that is, at what pixel the legs stop.

Example 6-3: While loop int endLegs = 150; stroke(0); while (x width) { xpos = 0; } }

void display() { rectMode(CENTER); fill(c); rect(xpos,ypos,20,10); } void drive() { xpos = xpos + xspeed; if (xpos > width){ xpos = 0; } } }

Functionality

Objects

125

• The Class Name—The name is specified by “class WhateverNameYouChoose”. We then enclose all of the code for the class inside curly brackets after the name declaration. Class names are traditionally capitalized (to distinguish them from variable names, which traditionally are lowercase). • Data—The data for a class is a collection of variables. These variables are often referred to as instance variables since each instance of an object contains this set of variables. • A Constructor—The constructor is a special function inside of a class that creates the instance of the object itself. It is where you give the instructions on how to set up the object. It is just like Processing’s setup( ) function, only here it is used to create an individual object within the sketch, whenever a new object is created from this class. It always has the same name as the class and is called by invoking the new operator: “Car myCar ⴝ new Car( );”. • Functionality—We can add functionality to our object by writing methods. These are done in the same way as described in Chapter 7, with a return type, name, arguments, and a body of code. This code for a class exists as its own block and can be placed anywhere outside of setup( ) and draw( ). A Class Is a New Block of Code! void setup() { } void draw() { } class Car { }

Exercise 8-2: Fill in the blanks in the following Human class deﬁnition. Include a function called sleep( ) or make up your own function. Follow the syntax of the Car example. (There are no right or wrong answers in terms of the actual code itself; it is the structure that is important.) ________ ________ { color hairColor; float height; ________() { ________________________ ________________________ } ________________________ { ________________________ ________________________ } }

126

Learning Processing

8.4 Using an Object: The Details In Section 8.2, we took a quick peek at how an object can greatly simplify the main parts of a Processing sketch (setup( ) and draw( )). Car myCar;

Step 1. Declare an object.

void setup() { myCar = new Car(); }

Step 2. Initialize object.

void draw() { background(0); myCar.move(); myCar.display(); }

Step 3. Call methods on the object.

Let’s look at the details behind the above three steps outlining how to use an object in your sketch. Step 1. Declaring an object variable. If you ﬂip back to Chapter 4, you may recall that a variable is declared by specifying a type and a name. // Variable Declaration int var; // type name

The above is an example of a variable that holds onto a primitive, in this case an integer. As we learned in Chapter 4, primitive data types are singular pieces of information: an integer, a ﬂoat, a character. Declaring a variable that holds onto an object is quite similar. The diﬀerence is that here the type is the class name, something we will make up, in this case “Car.” Objects, incidentally, are not primitives and are considered complex data types. (This is because they store multiple pieces of information: data and functionality. Primitives only store data.) Step 2. Initializing an object. Again, you may recall from Chapter 4 that in order to initialize a variable (i.e., give it a starting value), we use an assignment operation—variable equals something. // Variable Initialization var = 10; // var equals 10

Initializing an object is a bit more complex. Instead of simply assigning it a primitive value, like an integer or ﬂoating point number, we have to construct the object. An object is made with the new operator. // Object Initialization myCar = new Car();

The new operator is used to make a new object.

In the above example, “myCar” is the object variable name and “” indicates we are setting it equal to something, that something being a new instance of a Car object. What we are really doing here is initializing a Car object. When you initialize a primitive variable, such as an integer, you just set it equal to a number. But an object may contain multiple pieces of data. Recalling the Car class from the previous section, we see that this line of code calls the constructor, a special function named Car( ) that initializes all of the object’s variables and makes sure the Car object is ready to go.

Objects

127

One other thing; with the primitive integer “var,” if you had forgotten to initialize it (set it equal to 10), Processing would have assigned it a default value, zero. An object (such as “myCar”), however, has no default value. If you forget to initialize an object, Processing will give it the value null. null means nothing. Not zero. Not negative one. Utter nothingness. Emptiness. If you encounter an error in the message window that says “NullPointerException” (and this is a pretty common error), that error is most likely caused by having forgotten to initialize an object. (See the Appendix for more details.) Step 3. Using an object Once we have successfully declared and initialized an object variable, we can use it. Using an object involves calling functions that are built into that object. A human object can eat, a car can drive, a dog can bark. Functions that are inside of an object are technically referred to as “methods” in Java so we can begin to use this nomenclature (see Section 7.1). Calling a method inside of an object is accomplished via dot syntax: variableName.objectMethod(Method Arguments); In the case of the car, none of the available functions has an argument so it looks like: myCar.draw(); myCar.display();

Functions are called with the “dot syntax”.

Exercise 8-3: Assume the existence of a Human class. You want to write the code to declare a Human object as well as call the function sleep( ) on that human object. Write out the code below: Declare and initialize the Human object: ________________________________ Call the sleep( ) function:

________________________________

8.5 Putting It Together with a Tab Now that we have learned how to deﬁne a class and use an object born from that class, we can take the code from Sections 8.2 and 8.3 and put them together in one program. Example 8-1: A Car class and a Car object Car myCar;

Declare car object as a globle variable.

void setup() { size(200,200); // Initialize Car object myCar = new Car(); } void draw() { background(0); // Operate Car object. myCar.move(); myCar.display(); }

Initialize car object in setup() by calling constructor.

Operate the car object in draw( ) by calling object methods using the dots syntax.

128

Learning Processing class Car { color float float float

c; xpos; ypos; xspeed;

Deﬁne a class below the rest of the program. Variables.

Car() { c = color(255); xpos = width/2; ypos = height/2; xspeed = 1; }

A constructor.

void display() {

Function.

// The car is just a square rectMode(CENTER); fill(c); rect(xpos,ypos,20,10); } void move() {

Function.

xpos = xpos + xspeed; if (xpos > width) { xpos = 0; } } }

You will notice that the code block that contains the Car class is placed below the main body of the program (under draw( )). This spot is identical to where we placed user-deﬁned functions in Chapter 7. Technically speaking, the order does not matter, as long as the blocks of code (contained within curly brackets) remain intact. The Car class could go above setup( ) or it could even go between setup( ) and draw( ). Though any placement is technically correct, when programming, it is nice to place things where they make the most logical sense to our human brains, the bottom of the code being a good starting point. Nevertheless, Processing oﬀers a useful means for separating blocks of code from each other through the use of tabs. In your Processing window, look for the arrow inside a square in the top right-hand corner. If you click that button, you will see that it oﬀers the “New Tab” option shown in Figure 8.1. Upon selecting “New Tab,” you will be prompted to type in a name for the new tab, as shown in Figure 8.2. Although you can pick any name you like, it is probably a good idea to name the tab after the class you intend to put there. You can then type the main body of code on one tab (entitled “objectExample” in Figure 8.2) and type the code for your class in another (entitled “Car”). Toggling between the tabs is simple, just click on the tab name itself, as shown in Figure 8.3. Also, it should be noted that when a new tab is created, a new .pde ﬁle is created inside the sketch folder, as shown in Figure 8.4. The program has both an objectExample.pde ﬁle and Car.pde ﬁle.

Objects

ﬁg. 8.1

ﬁg. 8.2

ﬁg. 8.4

ﬁg. 8.3

129

130

Learning Processing

Exercise 8-4: Create a sketch with multiple tabs. Try to get the Car example to run without any errors.

8.6 Constructor Arguments In the previous examples, the car object was initialized using the new operator followed by the constructor for the class. Car myCar = new Car();

This was a useful simpliﬁcation while we learned the basics of OOP. Nonetheless, there is a rather serious problem with the above code. What if we wanted to write a program with two car objects? // Creating two car objects Car myCar1 = new Car(); Car myCar2 = new Car();

This accomplishes our goal; the code will produce two car objects, one stored in the variable myCar1 and one in myCar2. However, if you study the Car class, you will notice that these two cars will be identical: each one will be colored white, start in the middle of the screen, and have a speed of 1. In English, the above reads: Make a new car. We want to instead say: Make a new red car, at location (0,10) with a speed of 1. So that we could also say: Make a new blue car, at location (0,100) with a speed of 2. We can do this by placing arguments inside of the constructor method. Car myCar = new Car(color(255,0,0),0,100,2);

The constructor must be rewritten to incorporate these arguments: Car(color tempC, float tempXpos, float tempYpos, float tempXspeed) { c = tempC; xpos = tempXpos; ypos = tempYpos; xspeed = tempXspeed; }

In my experience, the use of constructor arguments to initialize object variables can be somewhat bewildering. Please do not blame yourself. The code is strange-looking and can seem awfully redundant: “For every single variable I want to initialize in the constructor, I have to duplicate it with a temporary argument to that constructor?”

Objects

131

Nevertheless, this is quite an important skill to learn, and, ultimately, is one of the things that makes object-oriented programming powerful. But for now, it may feel painful. Let’s brieﬂy revisit parameter passing again to understand how it works in this context. See Figure 8.5. Frog f; void setup () { f = new Frog (100); } Instance variable: This is the variable we care about, the one that stores the frog’s tongue length!

Parameter Passing: 100 goes into tempTongueLength

class Frog { int tongueLength;

Temporary local variable

Frog (int tempTongueLength) {

tongueLength = tempTongueLength; } }

tempTongueLength is used to assign a value to tongueLength. Therefore tongueLength = 100

Translation: Make a new frog with a tongue length of 100. ﬁg. 8.5

Arguments are local variables used inside the body of a function that get ﬁlled with values when the function is called. In the examples, they have one purpose only, to initialize the variables inside of an object. These are the variables that count, the car’s actual car, the car’s actual x location, and so on. The constructor’s arguments are just temporary, and exist solely to pass a value from where the object is made into the object itself. This allows us to make a variety of objects using the same constructor. You might also just write the word temp in your argument names to remind you of what is going on (c vs. tempC). You will also see programmers use an underscore (c vs. c_) in many examples. You can name these whatever you want, of course. However, it is advisable to choose a name that makes sense to you, and also to stay consistent. We can now take a look at the same program with multiple object instances, each with unique properties. Example 8-2: Two Car objects Car myCar1; Car myCar2;

Two objects!

void setup() { size(200,200); myCar1 = new Car(color(255,0,0),0,100,2); myCar2 = new Car(color(0,0,255),0,10,1); } void draw() { background(255);

Parameters go inside the parentheses when the object is constructed.

ﬁg. 8.6

132

Learning Processing myCar1.move(); myCar1.display(); myCar2.move(); myCar2.display(); } class Car { color float float float

Even though there are multiple objects, we still only need one class. No matter how many cookies we make, only one cookie cutter is needed.Isn’t object-oriented programming swell?

c; xpos; ypos; xspeed;

Car(color tempC, float tempXpos, float tempYpos, float tempXspeed) { c = tempC; xpos = tempXpos; ypos = tempYpos; The Constructor is deﬁned with arguments. xspeed = tempXspeed; } void display() { stroke(0); fill(c); rectMode(CENTER); rect(xpos,ypos,20,10); } void move() { xpos = xpos + xspeed; if (xpos > width) { xpos = 0; } } }

Exercise 8-5: Rewrite the gravity example from Chapter 5 using objects with a Ball class. Include two instances of a Ball object. The original example is included here for your reference with a framework to help you get started. _______ _______; Ball ball2; float grav = 0.1; void setup() { size(200,200); ball1 = new _______(50,0,16); _________________(100,50,32); }

Objects

void draw() { background(100); ball1.display(); __________________________

// Simple gravity float x = 100; location float y = 0;

__________________________

// x // y

location

__________________________ float speed = 0;

}

// speed

float gravity = 0.1;// gravity _______________ { float x;

void setup() {

__________________ float speed;

size(200,200); }

float w; ______(______,______,______) {

void draw() { background(100);

x = ______; ___________

// display the square

___________

fill(255);

speed = 0;

noStroke(); rectMode(CENTER);

}

rect(x,y,10,10); void ___________() { _____________________________

// Add speed to y location y = y + speed;

_____________________________

// Add gravity to speed _____________________________

speed = speed + gravity;

} // If square reaches the bottom ______________________________

// Reverse speed

______________________________

if (y > height) { speed = speed * -0.95;

______________________________ } ______________________________ ______________________________ ______________________________ }

}

133

134

Learning Processing

8.7 Objects are data types too! This is our ﬁrst experience with object-oriented programming, so we want to take it easy. The examples in this chapter all use just one class and make, at most, two or three objects from that class. Nevertheless, there are no actual limitations. A Processing sketch can include as many classes as you feel like writing. If you were programming the Space Invaders game, for example, you might create a Spaceship class, an Enemy class, and a Bullet class, using an object for each entity in your game. In addition, although not primitive, classes are data types just like integers and ﬂoats. And since classes are made up of data, an object can therefore contain other objects! For example, let’s assume you had just ﬁnished programming a Fork and Spoon class. Moving on to a PlaceSetting class, you would likely include variables for both a Fork object and a Spoon object inside that class itself. This is perfectly reasonable and quite common in object-oriented programming. class PlaceSetting { Fork fork; Spoon spoon;

A class can include other objects among its variables.

PlaceSetting() { fork = new Fork(); spoon = new Spoon(); } }

Objects, just like any data type, can also be passed in as arguments to a function. In the Space Invaders game example, if the spaceship shoots the bullet at the enemy, we would probably want to write a function inside the Enemy class to determine if the Enemy had been hit by the bullet. void hit(Bullet b) { A function can have an object as its argument. // Code to determine if // the bullet struck the enemy }

In Chapter 7, we showed how when a primitive value (integer, ﬂoat, etc.) is passed in a function, a copy is made. With objects, this is not the case, and the result is a bit more intuitive. If changes are made to an object after it is passed into a function, those changes will aﬀect that object used anywhere else throughout the sketch. This is known as pass by reference since instead of a copy, a reference to the actual object itself is passed into the function. As we move forward through this book and our examples become more advanced, we will begin to see examples that use multiple objects, pass objects into functions, and more. The next chapter, in fact, focuses on how to make lists of objects. And Chapter 10 walks through the development of a project that includes multiple classes. For now, as we close out the chapter with Zoog, we will stick with just one class.

8.8 Object-Oriented Zoog Invariably, the question comes up: “ When should I use object-oriented programming?” For me, the answer is always. Objects allow you to organize the concepts inside of a software application into

Objects

135

modular, reusable packages. You will see this again and again throughout the course of this book. However, it is not always convenient or necessary to start out every project using object-orientation, especially while you are learning. Processing makes it easy to quickly “sketch” out visual ideas with non object-oriented code. For any Processing project you want to make, my advice is to take a step-by-step approach. You do not need to start out writing classes for everything you want to try to do. Sketch out your idea ﬁrst by writing code in setup( ) and draw( ). Nail down the logic of what you want to do as well as how you want it to look. As your project begins to grow, take the time to reorganize your code, perhaps ﬁrst with functions, then with objects. It is perfectly acceptable to dedicate a signiﬁcant chunk of your time to this reorganization process (often referred to as refactoring) without making any changes to the end result, that is, what your sketch looks like and does on screen. This is exactly what we have been doing with cosmonaut Zoog from Chapter 1 until now. We sketched out Zoog’s look and experimented with some motion behaviors. Now that we have something, we can take the time to refactor by making Zoog into an object. This process will give us a leg up in programming Zoog’s future life in more complex sketches. And so it is time to take the plunge and make a Zoog class. Our little Zoog is almost all grown up. The following example is virtually identical to Example 7-5 (Zoog with functions) with one major diﬀerence. All of the variables and all of the functions from Example 7-5 are now incorporated into the Zoog class with setup( ) and draw( ) containing barely any code. Example 8-3 Zoog zoog; void setup() { size(200,200); smooth(); zoog = new Zoog(100,125,60,60,16); }

Zoog is an object!

Zoog is given initial properties via the constructor.

void draw() { background(255); // mouseX position determines speed factor float factor = constrain(mouseX/10,0,5); zoog.jiggle(factor); zoog.display(); Zoog can do stuff with functions! } class Zoog { // Zoog's variables float x,y,w,h,eyeSize; // Zoog constructor Zoog(float tempX, float tempY, float tempW, float tempH, float tempEyeSize) { x = tempX; y = tempY; w = tempW; Everything about Zoog is contained in this one class. h = tempH; Zoog has properties (location, with , height, eye size) eyeSize = tempEyeSize; and Zoog has abilities (jiggle, display). }

136

Learning Processing // Move Zoog void jiggle(float speed) { // Change the location of Zoog randomly x = x + random(-1,1)*speed; y = y + random(-1,1)*speed; // Constrain Zoog to window x = constrain(x,0,width); y = constrain(y,0,height); } ﬁg. 8.7 // Display Zoog void display() { // Set ellipses and rects to CENTER mode ellipseMode(CENTER); rectMode(CENTER); // Draw Zoog's arms with a for loop for (float i = y - h/3; i < y + h/2; i += 10) { stroke(0); line(x-w/4,i,x+w/4,i); } // Draw Zoog's body stroke(0); fill(175); rect(x,y,w/6,h); // Draw Zoog's head stroke(0); fill(255); ellipse(x,y-h,w,h); // Draw Zoog's eyes fill(0); ellipse(x-w/3,y-h,eyeSize,eyeSize*2); ellipse(x+w/3,y–h,eyeSize,eyeSize*2); // Draw Zoog's legs stroke(0); line(x–w/12,y+h/2,x–w/4,y+h/2+10); line(x+w/12,y+h/2,x+w/4,y+h/2+10); } }

Exercise 8-6: Rewrite Example 8-3 to include two Zoogs. Can you vary their appearance? Behavior? Consider adding color as a Zoog variable.

Objects

Lesson Three Project Step 1. Take your Lesson Two Project and reorganize the code using functions. Step 2. Reorganize the code one step further using a class and an object variable. Step 3. Add arguments to the Constructor of your class and try making two or three objects with diﬀerent variables. Use the space provided below to sketch designs, notes, and pseudocode for your project.

137

This page intentionally left blank

Lesson Four More of the Same

9 Arrays

This page intentionally left blank

Arrays

141

9 Arrays “I might repeat to myself slowly and soothingly, a list of quotations beautiful from minds profound—if I can remember any of the damn things.” —Dorothy Parker In this chapter: – What is an array? – Declaring an array. – Initialization. – Array operations—using the “for” loop with an array. – Arrays of objects.

9.1 Arrays, why do we care? Let’s take a moment to revisit the car example from the previous chapter on object-oriented programming. You may remember we spent a great deal of eﬀort on developing a program that contained multiple instances of a class, that is, two objects. Car myCar1; Car myCar2;

This was indeed an exciting moment in the development of our lives as computer programmers. It is likely you are contemplating a somewhat obvious question. How could I take this further and write a program with 100 car objects? With some clever copying and pasting, you might write a program with the following beginning: Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car

myCar1 myCar2 myCar3 myCar4 myCar5 myCar6 myCar7 myCar8 myCar9 myCar10 myCar11 myCar12 myCar13 myCar14 myCar15 myCar16 myCar17 myCar18 myCar19 myCar20 myCar21

142

Learning Processing Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car

myCar22 myCar23 myCar24 myCar25 myCar26 myCar27 myCar28 myCar29 myCar30 myCar31 myCar32 myCar33 myCar34 myCar35 myCar36 myCar37 myCar38 myCar39 myCar40 myCar41 myCar42 myCar43 myCar44 myCar45 myCar46 myCar47 myCar48 myCar49 myCar50 myCar51 myCar52 myCar53 myCar54 myCar55 myCar56 myCar57 myCar58 myCar59 myCar60 myCar61 myCar62 myCar63 myCar64 myCar65 myCar66 myCar67 myCar68 myCar69 myCar70 myCar71 myCar72 myCar73 myCar74 myCar75 myCar76 myCar77 myCar78 myCar79

Arrays Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car Car

143

myCar80 myCar81 myCar82 myCar83 myCar84 myCar85 myCar86 myCar87 myCar88 myCar89 myCar90 myCar91 myCar92 myCar93 myCar94 myCar95 myCar96 myCar97 myCar98 myCar99 myCar100

If you really want to give yourself a headache, try completing the rest of the program modeled after the above start. It will not be a pleasant endeavor. I am certainly not about to leave you any workbook space in this book to practice. An array will allow us to take these 100 lines of code and put them into one line. Instead of having 100 variables, an array is one thing that contains a list of variables. Any time a program requires multiple instances of similar data, it might be time to use an array. For example, an array can be used to store the scores of four players in a game, a selection of 10 colors in a design program, or a list of ﬁsh objects in an aquarium simulation.

Exercise 9-1: Looking at all of the sketches you have created so far, do any merit the use of an array? Why? _______________________________________________________________ _______________________________________________________________ _______________________________________________________________ _______________________________________________________________ _______________________________________________________________

144

Learning Processing

9.2 What is an array? From Chapter 4, you may recall that a variable is a named pointer to a location in memory where data is stored. In other words, variables allow programs to keep track of information over a period of time. An array is exactly the same, only instead of pointing to one singular piece of information, an array points to multiple pieces. See Figure 9.1. Variable

7

Array

4

8

15 16 23 42

ﬁg. 9.1

You can think of an array as a list of variables. A list, it should be noted, is useful for two important reasons. Number one, the list keeps track of the elements in the list themselves. Number two, the list keeps track of the order of those elements (which element is the ﬁrst in the list, the second, the third, etc.). This is a crucial point since in many programs, the order of information is just as important as the information itself. In an array, each element of the list has a unique index, an integer value that designates its position in the list (element #1, element #2, etc.). In all cases, the name of the array refers to the list as a whole, while each element is accessed via its position. Notice how in Figure 9.2, the indices range from 0 to 9. The array has a total of 10 elements, but the ﬁrst element number is 0 and the last element is 9. We might be tempted to stomp our feet and complain: “Hey, why aren’t the elements numbered from 1 to 10? Wouldn’t that be easier?” Array index values

0

1

2

3

4

5

6

7

8

9

ﬁg. 9.2

While at ﬁrst, it might intuitively seem like we should start counting at one (and some programming languages do), we start at zero because technically the ﬁrst element of the array is located at the start of the array, a distance of zero from the beginning. Numbering the elements starting at 0 also makes many array operations (the process of executing a line of code for every element of the list) a great deal more convenient. As we continue through several examples, you will begin to believe in the power of counting from zero.

Arrays

145

Exercise 9-2: If you have an array with 1,000 elements, what is the range of index values for that array? Answer: _______ through _______

9.3 Declaring and Creating an Array In Chapter 4, we learned that all variables must have a name and a data type. Arrays are no diﬀerent. The declaration statement, however, does look diﬀerent. We denote the use of an array by placing empty square brackets (“[]”) after the type declaration. Let’s start with an array of primitive values, for example, integers. (We can have arrays of any data type, and we will soon see how we can make an array of objects.) See Figure 9.3. int [] arrayOfInts;

Name Type Indicates array ﬁg. 9.3

The declaration in Figure 9.3 indicates that “arrayOf Ints” will store a list of integers. The array name “arrayOf Ints” can be absolutely anything you want it to be (we only include the word “array ” here to illustrate what we are learning). One fundamental property of arrays, however, is that they are of ﬁxed size. Once we deﬁne the size for an array, it can never change. A list of 10 integers can never go to 11. But where in the above code is the size of the array deﬁned? It is not. The code simply declares the array; we must also make sure we create the actual instance of the array with a speciﬁed size. To do this, we use the new operator, in a similar manner as we did in calling the constructor of an object. In the object’s case, we are saying “Make a new Car” or “Make a new Zoog.” With an array, we are saying “Make a new array of integers,” or “Make a new array of Car objects,” and so on. See array declaration in Figure 9.4. Array declaration and creation int[] arrayOfInts = new int [42];

The "new" operator means we're making a "new" array.

Type Size of array

ﬁg. 9.4

The array declaration in Figure 9.4 allows us to specify the array size: how many elements we want the array to hold (or, technically, how much memory in the computer we are asking for to store our beloved data). We write this statement as follows: the new operator, followed by the data type, followed by the size of the array enclosed in brackets. This size must be an integer. It can be a hard-coded number, a variable (of type integer), or an expression that evaluates to an integer (like 2  2).

146

Learning Processing Example 9-1: Additional array declaration and creation examples float[] scores = new float[4];

// A list of 4 floating point numbers

Human[] people = new Human[100];

// A list of 100 Human objects

int num = 50; Car[] cars = new Car[num];

// Using a variable to specify size

Spaceship[] ships = new Shapeship[num*2 + 3];

// Using an expression to specify size

Exercise 9-3: Write the declaration statements for the following arrays: 30 integers 100 ﬂoating point numbers 56 Zoog objects

Exercise 9-4: Which of the following array declarations are valid and which are invalid (and why)?

int[] numbers = new int[10]; float[] numbers = new float[5+6]; int num = 5; float[] numbers = new int[num]; float num = 5.2; Car[] cars = new Car[num]; int num = (5 * 6)/2; float[] numbers = new float[num = 5]; int num = 5; Zoog[] zoogs = new Zoog[num * 10];

Things are looking up. Not only did we successfully declare the existence of an array, but we have given it a size and allocated physical memory for the stored data. A major piece is missing, however: the data stored in the array itself !

Arrays

147

9.4 Initializing an Array One way to ﬁll an array is to hard-code the values stored in each spot of the array.

Example 9-2: Initializing the elements of an array one at a time int[] stuff = new int[3]; stuff[0] = 8; stuff[1] = 3; stuff[2] = 1;

// The first element of the array equals 8 // The second element of the array equals 3 // The third element of the array equals 1

As you can see, we refer to each element of the array individually by specifying an index, starting at 0. The syntax for this is the name of the array, followed by the index value enclosed in brackets. arrayName[INDEX] A second option for initializing an array is to manually type out a list of values enclosed in curly braces and separated by commas.

Example 9-3: Initializing the elements of an array all at once int[] arrayOfInts = {1, 5, 8, 9, 4, 5}; float[] floatArray = {1.2, 3.5, 2.0, 3.4123, 9.9};

Exercise 9-5: Declare an array of three Zoog objects. Initialize each spot in the array with a Zoog object via its index. Zoog__ zoogs = new _______ [_______ ]; _______[_______ ] = _______ _______(100, 100, 50, 60, 16); _______[_______ ] = _______ _______(________________); _______[_______ ] = _______ _______(________________);

Both of these approaches are not commonly used and you will not see them in most of the examples throughout the book. In fact, neither initialization method has really solved the problem posed at the beginning of the chapter. Imagine initializing each element individually with a list of 100 or (gasp) 1,000 or (gasp gasp!) 1,000,000 elements. The solution to all of our woes involves a means for iterating through the elements of the array. Ding ding ding. Hopefully a loud bell is ringing in your head. Loops! (If you are lost, revisit Chapter 6.)

148

Learning Processing

9.5 Array Operations Consider, for a moment, the following problem: (A) Create an array of 1,000 ﬂoating point numbers. (B) Initialize every element of that array with a random number between 0 and 10. Part A we already know how to do. float[] values = new float[1000];

What we want to avoid is having to do this for Part B: values[0] values[1] values[2] values[3] values[4] values[5] etc. etc.

= = = = = =

random(0,10); random(0,10); random(0,10); random(0,10); random(0,10); random(0,10);

Let’s describe in English what we want to program: For every number n from 0 to 99, initialize the nth element stored in array as a random value between 0 and 10. Translating into code, we have: int n = 0; values[n] values[n+1] values[n+2] values[n+3] values[n+4] values[n+5]

= = = = = =

random(0,10); random(0,10); random(0,10); random(0,10); random(0,10); random(0,10);

Unfortunately, the situation has not improved. We have, nonetheless, taken a big leap forward. By using a variable (n) to describe an index in the array, we can now employ a while loop to initialize every n element.

Example 9-4: Using a while loop to initialize all elements of an array int n = 0; while (n < 1000) { values[n] = random(0,10); n = n + 1; }

A for loop allows us to be even more concise, as Example 9-5 shows.

Arrays Example 9-5: Using a for loop to initialize all elements of an array for (int n = 0; n < 1000; n++) { values[n] = random(0,10); }

What was once 1,000 lines of code is now three! We can exploit the same technique for any type of array operation we might like to do beyond simply initializing the elements. For example, we could take the array and double the value of each element (we will use i from now on instead of n as it is more commonly used by programmers).

Example 9-6: An array operation for (int i = 0; i < 1000; i++) { values[i] = values[i] * 2; }

There is one problem with Example 9-6: the use of the hard-coded value 1,000. Striving to be better programmers, we should always question the existence of a hard-coded number. In this case, what if we wanted to change the array to have 2,000 elements? If our program was very long with many array operations, we would have to make this change everywhere throughout our code. Fortunately for us, Processing gives us a nice means for accessing the size of an array dynamically, using the dot syntax we learned for objects in Chapter 8. length is a property of every array and we can access it by saying: arrayName dot length Let’s use length while clearing an array. This will involve resetting every value to 0.

Example 9-7: An array operation using dot length for (int i = 0; i < values.length; i++) { values[i] = 0; }

Exercise 9-6: Assuming an array of 10 integers, that is, int[] nums = {5,4,2,7,6,8,5,2,8,14};

write code to perform the following array operations (Note that the number of clues vary, just because a [____] is not explicitly written in does not mean there should not be brackets). Square each number

for (int i ___; i < _____; i++) {

(i.e., multiply each by itself )

____[i] = ______*_____; }

149

150

Learning Processing

Add a random number between zero and 10 to each number.

_________________________________

Add to each number the number that follows in the array. Skip the last value in the array.

for (int i = 0; i < _____; i++) {

Calculate the sum of all the numbers.

_____ += int(________); __

_____ += ______ [____]; }

_____ ________ = ____; for (int i = 0; i < nums.length; i++) { ______ += ________; }

9.6 Simple Array Example: The Snake A seemingly trivial task, programming a trail following the mouse, is not as easy as it might initially appear. The solution requires an array, which will serve to store the history of mouse locations. We will use two arrays, one to store horizontal mouse locations, and one for vertical. Let’s say, arbitrarily, that we want to store the last 50 mouse locations. First, we declare the two arrays. int[] xpos = new int[50]; int[] ypos = new int[50];

Second, in setup( ), we must initialize the arrays. Since at the start of the program there has not been any mouse movement, we will just ﬁll the arrays with 0’s. for (int i = 0; i < xpos.length; i++) { xpos[i] = 0; ypos[i] = 0; }

Each time through the main draw( ) loop, we want to update the array with the current mouse location. Let’s choose to put the current mouse location in the last spot of the array. The length of the array is 50, meaning index values range from 0–49. The the last spot is index 49, or the length of the array minus one. xpos[xpos.length–l] = mouseX; ypos[ypos.length–1] = mouseY;

The last spot in an array is length minus one.

Arrays

151

Now comes the hard part. We want to keep only the last 50 mouse locations. By storing the current mouse location at the end of the array, we are overwriting what was previously stored there. If the mouse is at (10,10) during one frame and (15,15) during another, we want to put (10,10) in the second to last spot and (15,15) in the last spot. The solution is to shift all of the elements of the array down one spot before updating the current location. This is shown in Figure 9.5. 1 moves into 0

Spot 0 is overwritten ﬁg. 9.5

2 moves into 1

3 moves into 2 5

13

9

42

13

9

42

8

New value

New value goes into 3

Element index 49 moves into spot 48, 48 moves into spot 47, 47 into 46, and so on. We can do this by looping through the array and setting each element index i to the value of element i plus one. Note we must stop at the second to last value since for element 49 there is no element 50 (49 plus 1). In other words, instead of having an exit condition i  xpos.length; we must instead say: i  xpos.length – 1; The full code for performing this array shift is as follows: for (int i = 0; i < xpos.length–1; i++) { xpos[i] = xpos[i+1]; ypos[i] = ypos[i+1]; }

Finally, we can use the history of mouse locations to draw a series of circles. For each element of the xpos array and ypos array, draw an ellipse at the corresponding values stored in the array. for (int i = 0; i < xpos.length; i++) { noStroke(); ﬁll(255); ellipse(xpos[i],ypos[i],32,32); }

Making this a bit fancier, we might choose to link the brightness of the circle as well as the size of the circle to the location in the array, that is, the earlier (and therefore older) values will be bright and small and the later (newer) values will be darker and bigger. This is accomplished by using the counting variable i to evaluate color and size.

152

Learning Processing for (int i = 0; i < xpos.length; i++) { noStroke(); fill(255 – i*5); ellipse(xpos[i],ypos[i],i,i); }

Putting all of the code together, we have the following example, with the output shown in Figure 9.6.

Example 9-8: A snake following the mouse // x and y positions int[] xpos = new int[50]; int[] ypos = new int[50];

Declare two arrays with 50 elemets.

void setup() { size(200,200); smooth();

// Initialize for (int i = 0; i < xpos.length; i++) xpos[i] = 0; Initialize all elements of each array to zero. ypos[i] = 0; }

ﬁg. 9.6

}

void draw() { background(255);

// Shift array values for (int i = 0; i < xpos.length-1; i++) { xpos[i] = xpos[i+1]; Shift all elements down one spot. ypos[i] = ypos[i+1]; } xpos[0] = xpos[1], xpos[1] = xpos = [2], and so on.

Stop at the second to last element. // New location xpos[xpos.length–1] = mouseX; ypos[ypos.length–1] = mouseY;

}

Update the last spot in the array with the mouse location.

// Draw everything for (int i = 0; i < xpos.length; i++) { noStroke(); fill(255-i*5); ellipse(xpos[i],ypos[i],i,i); Draw an ellipse for each element in the arrays. } Color and size are tied to the loop’s counter: i.

Arrays

153

Exercise 9-7: Rewrite the snake example in an object-oriented fashion with a Snake class. Can you make snakes with slightly diﬀerent looks (diﬀerent shapes, colors, sizes)? (For an advanced problem, create a Point class that stores an x and y coordinate as part of the sketch. Each snake object will have an array of Point objects, instead of two separate arrays of x and y values. This involves arrays of objects, covered in the next section.)

9.7 Arrays of Objects I know, I know. I still have not fully answered the question. How can we write a program with 100 car objects? One of the nicest features of combining object-oriented programming with arrays is the simplicity of transitioning a program from one object to 10 objects to 10,000 objects. In fact, if we have been careful, we will not have to change the Car class whatsoever. A class does not care how many objects are made from it. So, assuming we keep the identical Car class code, let’s look at how we expand the main program to use an array of objects instead of just one. Let’s revisit the main program for one Car object. Car myCar; void setup() { myCar = new Car(color(255,0,0),0,100,2); } void draw() { background(255); myCar.move(); myCar.display(); }

There are three steps in the above code and we need to alter each one to account for an array. BEFORE

AFTER

Declare the Car

Declare the Car Array

Car myCar;

Car[] cars = new Car[100];

Initialize the Car

Initialize each element of the Car Array

myCar = new Car(color(255),0,100,2);

for (int i = 0; i < cars.length; i++) { cars[i] = new Car(color(i*2),0,i*2,i); }

Run the Car by Calling Methods

Run each element of the Car Array

myCar.move(); myCar.display();

for (int i = 0; i < cars.length; i++) { cars[i].move(); cars[i].display(); }

154

Learning Processing

This leaves us with Example 9–9. Note how changing the number of cars present in the program requires only altering the array deﬁnition. Nothing else anywhere has to change!

Example 9-9: An array of Car objects Car[] cars = new Car[100];

An array of 100 Car objects!

void setup() { size(200,200); smooth(); for (int i = 0; i < cars.length; i++) { cars[i] = new Car(color(i*2),0,i*2,i/20.0); } }

Initialize each Car using a for loop. void draw() { background(255); for (int i = 0; i < cars.length; i++) { cars[i].move(); cars[i].display(); } Run each Car using a for loop. } class Car { color c; float xpos; float ypos; float xspeed;

The Car class does not change whether we are making one car, 100 cars or 1,000 cars!

Car(color c_, float xpos_, float ypos_, float xspeed_) { c = c_; xpos = xpos_; ypos = ypos_; xspeed = xspeed_; } void display() { rectMode(CENTER); stroke(0); fill(c); rect(xpos,ypos,20,10); } void move() { xpos = xpos + xspeed; if (xpos > width) { xpos = 0; } } }

ﬁg. 9.7

Arrays

155

9.8 Interactive Objects When we ﬁrst learned about variables (Chapter 4) and conditionals (Chapter 5), we programmed a simple rollover eﬀect. A rectangle appears in the window and is one color when the mouse is on top and another color when the mouse is not. The following is an example that takes this simple idea and puts it into a “Stripe” object. Even though there are 10 stripes, each one individually responds to the mouse by having its own rollover( ) function. void rollover(int mx, int my) { if (mx > x && mx < x + w) { mouse = true; } else { mouse = false; } }

This function checks to see if a point (mx, my) is contained within the vertical stripe. Is it greater than the left edge and less than the right edge? If so, a boolean variable “mouse” is set to true. When designing your classes, it is often convenient to use a boolean variable to keep track of properties of an object that resemble a switch. For example, a Car object could be running or not running. Zoog could be happy or not happy. This boolean variable is used in a conditional statement inside of the Stripe object’s display( ) function to determine the Stripe’s color. void display() { if (mouse) { fill(255); } else { fill(255,100); } noStroke(); rect(x,0,w,height); }

When we call the rollover( ) function on that object, we can then pass in mouseX and mouseY as arguments. stripes[i].rollover(mouseX,mouseY);

Even though we could have accessed mouseX and mouseY directly inside of the rollover ( ) function, it is better to use arguments. This allows for greater ﬂexibility. The Stripe object can check and determine if any x,y coordinate is contained within its rectangle. Perhaps later, we will want the Stripe to turn white when another object, rather than the mouse, is over it. Here is the full “interactive stripes” example.

156

Learning Processing Example 9-10: Interactive stripes // An array of stripes Stripe[] stripes = new Stripe[10]; void setup() { size(200,200); // Initialize all "stripes" for (int i = 0; i < stripes.length; i++) { stripes[i] = new Stripe(); } } ﬁg. 9.8 void draw() { background(100); // Move and display all "stripes" for (int i = 0; i < stripes.length; i++) { // Check if mouse is over the Stripe stripes[i].rollover(mouseX,mouseY); stripes[i].move(); stripes[i].display(); } } class Stripe { float x; float speed; float w; boolean mouse;

// // // //

Passing the mouse coordinates into an object.

horizontal location of stripe speed of stripe width of stripe state of stripe (mouse is over or not?)

Stripe() { x = 0; speed = random(1); w = random(10,30); mouse = false; } // Draw stripe void display() { if (mouse) { fill(255); } else { fill(255,100); } noStroke(); rect(x,0,w,height); }

A boolean variable keeps track of the object’s state.

// All stripes start at 0 // All stripes have a random positive speed

Boolean variable determines Stripe color.

// Move stripe void move() { x += speed; if (x > width+20) x = –20; }

Arrays // Check if point is inside of Stripe void rollover(int mx, int my) { // Left edge is x, Right edge is x+w if (mx > x && mx < x + w) { mouse = true; } else { mouse = false; } }

157

Check to see if point (mx,my) is inside the Stripe.

}

Exercise 9-8: Write a Button class (see Example 5-5 for a non-object-oriented button). The button class should register when a mouse is pressed over the button and change color. Create button objects of diﬀerent sizes and locations using an array. Before writing the main program, sketch out the Button class. Assume the button is oﬀ when it ﬁrst appears. Here is a code framework: class Button { float x; float y; float w; float h; boolean on; Button(float tempX, float tempY, float tempW, float tempH) { x = tempX; y = tempY; w = tempW; h = tempH; on = __________; } _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________

158

Learning Processing _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________ _____________________________________________________________________ }

9.9 Processing’s Array Functions OK, so I have a confession to make. I lied. Well, sort of. See, earlier in this chapter, I made a very big point of emphasizing that once you set the size of an array, you can never change that size. Once you have made 10 Button objects, you can’t make an 11th. And I stand by those statements. Technically speaking, when you allocate 10 spots in an array, you have told Processing exactly how much space in memory you intend to use. You can’t expect that block of memory to happen to have more space next to it so that you can expand the size of your array. However, there is no reason why you couldn’t just make a new array (one that has 11 spots in it), copy the ﬁrst 10 from your original array, and pop a new Button object in the last spot. Processing, in fact, oﬀers a set of array functions that manipulate the size of an array by managing this process for you. They are: shorten( ), concat( ), subset( ), append( ), splice( ), and expand( ). In addition, there are functions for changing the order in an array, such as sort( ) and reverse( ). Details about all of these functions can be found in the reference. Let’s look at one example that uses append( ) to expand the size of an array. This example (which includes an answer to Exercise 8-5) starts with an array of one object. Each time the mouse is pressed, a new object is created and appended to the end of the original array.

Example 9-11: Resizing an array using append() Ball[] balls = new Ball[1]; float gravity = 0.1; void setup() { size(200,200); smooth(); frameRate(30); // Initialize ball index 0 balls[0] = new Ball(50,0,16); }

We start with an array with just one element.

Whatever the length of that array, update and display all of the objects.

void draw() { background(100); // Update and display all balls for (int i = 0; i < balls.length; i++) {

ﬁg. 9.9

Arrays

159

balls[i].gravity(); balls[i].move(); balls[i].display(); } } void mousePressed() { // A new ball object Ball b = new Ball(mouseX,mouseY,10); // Append to array balls = (Ball[]) append(balls,b); } class Ball { float x; float y; float speed; float w;

Make a new object at the mouse location.

Here, the function, append() adds an element to the end of the array. append() takes two arguments. The ﬁrst is the array you want to append to, and the second is the thing you want to append. You have to reassign the result of the append() function to the original array. In addition, the append() function requires that you explicitly state the type of data in the array again by putting the array data type in parentheses: “(Ball[])”. This is known as casting.

Ball(float tempX, float tempY, float tempW) { x = tempX; y = tempY; w = tempW; speed = 0; } void gravity() { // Add gravity to speed speed = speed + gravity; } void move() { // Add speed to y location y = y + speed; // If square reaches the bottom // Reverse speed if (y > height) { speed = speed * –0.95; y = height; } }

void display() { // Display the circle fill(255); noStroke(); ellipse(x,y,w,w); } }

Another means of having a resizable array is through the use of a special object known as an ArrayList, which will be covered in Chapter 23.

160

Learning Processing

9.10 One Thousand and One Zoogs It is time to complete Zoog’s journey and look at how we move from one Zoog object to many. In the same way that we generated the Car array or Stripe array example, we can simply copy the exact Zoog class created in Example 8-3 and implement an array.

Example 9-12: 200 Zoog objects in an array Zoog[] zoogies = new Zoog[200];

The only difference between this example and the previous chapter (Example 8-3) is the use of an array for multiple Zoog objects.

void setup() { size(400,400); smooth(); for (int i = 0; i < zoogies.length; i++) { zoogies[i] = new Zoog(random(width),random(height),30,30,8); } } void draw() { background(255); // Draw a black background for (int i = 0; i < zoogies.length; i++) { zoogies[i].display(); zoogies[i].jiggle(); } } class Zoog { // Zoog's variables float x,y,w,h,eyeSize;

ﬁg. 9.10

// Zoog constructor Zoog(float tempX, float tempY, float tempW, float tempH, float tempEyeSize) { x = tempX; y = tempY; w = tempW; h = tempH; eyeSize = tempEyeSize; } // Move Zoog void jiggle() { // Change the location x = x + random(–1,1); y = y + random(–1,1);

For simplicity we have also removed the “speed” argument from the jiggle() function. Try adding it back in as an exercise.

// Constrain Zoog to window x = constrain(x,0,width); y = constrain(y,0,height); } // Display Zoog void display() { // Set ellipses and rects to CENTER mode ellipseMode(CENTER); rectMode(CENTER);

Arrays // Draw Zoog's arms with a for loop for (float i = y-h/3; i < y + h/2; i+=10) { stroke(0); line(x–w/4,i,x+w/4,i); } // Draw Zoog's body stroke(0); fill(175); rect(x,y,w/6,h); // Draw Zoog's head stroke(0); fill(255); ellipse(x,y-h,w,h); // Draw Zoog's eyes fill(0); ellipse(x–w/3,y–h,eyeSize,eyeSize*2); ellipse(x+w/3,y–h,eyeSize,eyeSize*2); // Draw Zoog's legs stroke(0); line(x–w/12,y+h/2,x-w/4,y+h/2+10); line(x+w/12,y+h/2,x+w/4,y+h/2+10); } }

161

162

Learning Processing

Lesson Four Project Step 1. Take the Class you made in Lesson Three and make an array of objects from that class. Step 2. Can you make the objects react to the mouse? Try using the dist( ) function to determine the object’s proximity to the mouse. For example, could you make each object jiggle more the closer it is to the mouse? How many objects can you make before the sketch runs too slow? Use the space provided below to sketch designs, notes, and pseudocode for your project.

Lesson Five Putting It All Together

10 Algorithms 11 Debugging 12 Libraries

This page intentionally left blank

Algorithms

165

10 Algorithms “Lather. Rinse. Repeat.” — Unknown

10.1 Where have we been? Where are we going? Our friend Zoog had a nice run. Zoog taught us the basics of the shape drawing libraries in Processing. From there, Zoog advanced to interacting with the mouse, to moving autonomously via variables, changing direction with conditionals, expanding its body with a loop, organizing its code with functions, encapsulating its data and functionality into an object, and ﬁnally duplicating itself with an array. It is a good story, and one that treated us well. Nonetheless, it is highly unlikely that all of the programming projects you intend to do after reading this book will involve a collection of alien creatures jiggling around the screen (if they do, you are one lucky programmer!). What we need to do is pause for a moment and consider what we have learned and how it can apply to what you want to do. What is your idea and how can variables, conditionals, loops, functions, objects, and arrays help you? In earlier chapters we focused on straightforward “one feature” programming examples. Zoog would jiggle and only jiggle. Zoog didn’t suddenly start hopping. And Zoog was usually all alone, never interacting with other alien creatures along the way. Certainly, we could have taken these early examples further, but it was important at the time to stick with basic functionality so that we could really learn the fundamentals. In the real world, software projects usually involve many moving parts. This chapter aims to demonstrate how a larger project is created out of many smaller “one feature” programs like the ones we are starting to feel comfortable making. You, the programmer, will start with an overall vision, but must learn how to break it down into individual parts to successfully execute that vision. We will start with an idea. Ideally, we would pick a sample “idea” that could set the basis for any project you want to create after reading this book. Sadly, there is no such thing. Programming your own software is terriﬁcally exciting because of the immeasurable array of possibilities for creation. Ultimately, you will have to make your own way. However, just as we picked a simple creature for learning the fundamentals, knowing we will not really be programming creatures all of our lives, we can attempt to make a generic choice, one that will hopefully serve for learning about the process of developing larger projects. Our choice will be a simple game with interactivity, multiple objects, and a goal. The focus will not be on good game design, but rather on good software design. How do you go from thought to code? How do you implement your own algorithm to realize your ideas? We will see how a larger project divides into four mini-projects and attack them one by one, ultimately bringing all parts together to execute the original idea. We will continue to emphasize object-oriented programming, and each one of these parts will be developed using a class. The payoﬀ will be seeing how easy it then is to create the ﬁnal program by

166

Learning Processing

bringing the self-contained, fully functional classes together. Before we get to the idea and its parts, let’s review the concept of an algorithm which we’ll need for steps 2a and 2b.

Our Process 1. Idea—Start with an idea. 2. Parts—Break the idea down into smaller parts. a. Algorithm Pseudocode—For each part, work out the algorithm for that part in pseudocode. b. Algorithm Code—Implement that algorithm with code. c. Objects—Take the data and functionality associated with that algorithm and build it into a class. 3. Integration—Take all the classes from Step 2 and integrate them into one larger algorithm.

10.2 Algorithm: Dance to the beat of your own drum. An algorithm is a procedure or formula for solving a problem. In computer programming, an algorithm is the sequence of steps required to perform a task. Every single example we have created so far in this book involved an algorithm. An algorithm is not too far oﬀ from a recipe. 1. 2. 3. 4.

Preheat oven to 400°F. Place four boneless chicken breasts in a baking dish. Spread mustard evenly over chicken. Bake at 400°F for 30 min.

The above is a nice algorithm for cooking mustard chicken. Clearly we are not going to write a Processing program to cook chicken. Nevertheless, if we did, the above pseudocode might turn into the following code. preheatOven(400); placeChicken(4,"baking dish"167); spreadMustard(); bake(400,30);

An example that uses an algorithm to solve a math problem is more relevant to our pursuits. Let’s describe an algorithm to evaluate the sum of a sequence of numbers 1 through N. SUM(N )  123 … N where N is any given whole number greater than zero. 1. 2.

3.

Set SUM  0 and a counter I  1 Repeat the following steps while I is less than or equal to N. a. Calculate SUM  I and save the result in SUM. b. Increase the value of I by 1. The solution is now the number saved in SUM.

Algorithms

167

Translating the preceding algorithm into code, we have: int sum = 0; int n = 10; int i = 0; while (i width || x < 0) { xspeed *= -1; } //Check vertical edges if (y > height || y < 0) { yspeed *= –1; } } // Draw the ball void display() { stroke(255); fill(100,50); ellipse(x,y,r*2,r*2); } }

From here, it is pretty easy to create a sketch with two ball objects. Ultimately, in the ﬁnal sketch, we’ll need an array for many raindrops, but for now, two ball variables will be simpler. Example 10-2 Catcher (Cont.): Two ball objects // Two ball variables Ball ball1; Ball ball2; void setup() { size(400,400); smooth(); // Initialize balls ball1 = new Ball(64); ball2 = new Ball(32); } void draw() { background(0);

ﬁg. 10.2

171

172

Learning Processing // Move and display balls ball1.move(); ball2.move(); ball1.display(); ball2.display(); }

Now that we have set up our system for having two circles moving around the screen, we need to develop an algorithm for determining if the circles intersect. In Processing, we know we can calculate the distance between two points using the dist( ) function (see Chapter 7). We also have access to the radius of each circle (the variable r inside each object). The diagram in Figure 10.3 shows how we can compare the distance between the circles and the sum of the radii to determine if the circles overlap.

DIST R1

DIST

DIST > (R1 + R2) NOT INTERSECTING

R

R2

2

R1

DIST < (R1 + R2) INTERSECTING

ﬁg. 10.3

OK, so assuming the following: • x1,y1: coordinates of circle one • x2,y2: coordinates of circle two • r1: radius of circle one • r2: radius of circle two We have the statement: If the distance between (x1 ,y1 ) and (x2 ,y2 ) is less than the sum of r1 and r2, circle one intersects circle two. Our job now is to write a function that returns true or false based on the above statement. // A function that returns true or false based on whether two circles intersect // If distance is less than the sum of radii the circles touch boolean intersect(float x1, float y1, float x2, float y2, float r1, float r2) { float distance = dist(x1,y2,x2,y2); // Calculate distance if (distance < r1 + r2) { // Compare distance to r1 + r2 return true; } else { return false; } }

Algorithms

173

Now that the function is complete, we can test it with data from ball1 and ball2. boolean intersecting = intersect(ball1.x,ball1.y,ball2.x,ball2.y,ball1.r,ball2.r); if (intersecting) { println("The circles are intersecting!");

} The above code is somewhat awkward and it will be useful to take the function one step further, incorporating it into the ball class itself. Let’s ﬁrst look at the entire main program as it stands. // Two ball variables Ball ball1; Ball ball2; void setup() { size(400,400); framerate(30); smooth(); // Initialize balls ball1 = new Ball(64); ball2 = new Ball(32); } void draw() { background(0); // Move and display balls ball1.move(); ball2.move(); ball1.display(); ball2.display(); boolean intersecting = intersect(ball1.x,ball1.y,ball2.x,ball2.y,ball1.r,ball2.r); if (intersecting) { println(“The circles are intersecting!”); } } // A function that returns true or false based on whether two circles intersect // If distance is less than the sum of radii the circles touch boolean intersect(float x1, float y1, float x2, float y2, float r1, float r2) { float distance = dist(x1,y2,x2,y2); // Calculate distance if (distance < r1 + r2) { // Compare distance to r1 + r2 return true; } else { return false; } }

Since we have programmed the balls in an object-oriented fashion, it is not terribly logical to suddenly have an intersect( ) function that lives outside of the ball class. A ball object should know how to test if it is intersecting another ball object. Our code can be improved by incorporating the intersect logic into the class itself, saying “ball1.intersect (ball2);” or, does Ball 1 intersect Ball 2? void draw() { background(0); // Move and display balls ball1.move(); ball2.move(); ball1.display(); ball2.display();

174

Learning Processing boolean intersecting = ball1.intersect(ball2); if (intersecting) { println("The circles are intersecting!"); }

Assumes a function intersect() inside the Ball class that returns true or false.

}

Following this model and the algorithm for testing intersection, here is a function for inside the ball class itself. Notice how the function makes use of both its own location (x and y) as well as the other ball’s location (b.x and b.y). // A function that returns true or false based on whether two Ball objects intersect // If distance is less than the sum of radii the circles touch boolean intersect(Ball b) { float distance = dist(x,y,b.x,b.y); // Calculate distance if (distance < r + b.r) { // Compare distance to sum of radii return true; } else { return false; } }

Putting it all together, we have the code in Example 10-3.

Example 10-3: Bouncing ball with intersection // Two ball variables Ball ball1; Ball ball2; void setup() { size(400,400); smooth(); // Initialize balls ball1 = new Ball(64); ball2 = new Ball(32); } void draw() { background(255); // Move and display balls ball1.move(); ball2.move(); if (ball1.intersect(ball2)) { ball1.highlight(); ball2.highlight(); } ball1.display(); ball2.display(); } class Ball { float r; // radius float x,y; float xspeed,yspeed; color c = color(100,50);

ﬁg. 10.4

New! An object can have a function that takes another object as an argument. This is one way to have objects communicate. In this case they are checking to see if they intersect.

Algorithms

175

// Constructor Ball(float tempR) { r = tempR; x = random(width); y = random(height); xspeed = random(–5,5); yspeed = random(–5,5); } void move() { x += xspeed; // Increment x y += yspeed; // Increment y // Check horizontal edges if (x > width || x < 0) { xspeed *= –1; } // Check vertical edges if (y > height || y < 0) { yspeed *= –1; } } void highlight() { c = color(0,150); } // Draw the ball void display() { stroke(0); fill(c); ellipse(x,y,r*2,r*2); c = color(100,50); }

Whenever the balls are touching, this highlight() function is called and the color is darkened.

After the ball is displayed, the color is reset back to a darker gray.

// A function that returns true or false based on whether two circles intersect // If distance is less than the sum of radii the circles touch boolean intersect(Ball b) { Objects can float distance = dist(x,y,b.x,b.y); // Calculate distance be passed into if (distance < r + b.r) { // Compare distance to functions as sum of radii arguments too! return true; } else { return false; } } }

10.6 Part 3: The Timer Our next task is to develop a timer that executes a function every N seconds. Again, we will do this in two steps, ﬁrst just using the main body of a program and second, taking the logic and putting it into a Timer class. Processing has the functions hour( ), second( ), minute( ), month( ), day( ), and year( ) to deal with time. We could conceivably use the second( ) function to determine how much time has passed. However, this is not terribly convenient, since second( ) rolls over from 60 to 0 at the end of every minute.

176

Learning Processing

For creating a timer, the function millis( ) is best. First of all, millis( ), which returns the number of milliseconds since a sketch started, allows for a great deal more precision. One millisecond is one onethousandth of a second (1,000 ms  1 s). Secondly, millis( ) never rolls back to zero, so asking for the milliseconds at one moment and subtracting it from the milliseconds at a later moment will always result in the amount of time passed. Let’s say we want an applet to change the background color to red 5 seconds after it started. Five seconds is 5,000 ms, so it is as easy as checking if the result of the millis( ) function is greater than 5,000. if (millis() > 5000) { background(255,0,0); }

Making the problem a bit more complicated, we can expand the program to change the background to a new random color every 5 seconds. Setup: • Save the time at startup (note this should always be zero, but it is useful to save it in a variable anyway). Call this “savedTime”. Draw: • Calculate the time passed as the current time (i.e., millis( )) minus savedTime. Save this as “passedTime”. • If passedTime is greater than 5,000, fill a new random background and reset savedTime to the current time. This step will restart the timer. Example 10-4 translates this into code.

Example 10-4: Implementing a timer int savedTime; int totalTime = 5000; void setup() { size(200,200); background(0); savedTime = millis(); } void draw() { // Calculate how much time has passed int passedTime = millis() - savedTime; // Has five seconds passed? if (passedTime > totalTime) { println("5 seconds have passed!"); background(random(255)); // Color a new background savedTime = millis(); // Save the current time to restart the timer! } }

Algorithms

177

With the above logic worked out, we can now move the timer into a class. Let’s think about what data is involved in the timer. A timer must know the time at which it started (savedTime) and how long it needs to run (totalTime). Data: • savedTime • totalTime The timer must also be able to start as well as check and see if it is ﬁnished. Functions: • start( ) • isFinished( )—returns true or false Taking the code from the non-object-oriented example and building it out with the above structure, we have the code shown in Example 10-5. Example 10-5: Object-oriented timer Timer timer; void setup() { size(200,200); background(0); timer = new Timer(5000); timer.start(); } void draw() { if (timer.isFinished()) { background(random(255)); timer.start(); } } class Timer { int savedTime; // When Timer started int totalTime; // How long Timer should last Timer(int tempTotalTime) { totalTime = tempTotalTime; } // Starting the timer void start() { savedTime = millis(); }

When the timer starts it stores the current time in milliseconds.

boolean isFinished() { // Check how much time has passed int passedTime = millis()- savedTime; if (passedTime > totalTime) { return true; } else { return false; } } }

The function isFinished() returns true if 5,000 ms have passed. The work of the timer is farmed out to this method.

178

Learning Processing

10.7 Part 4: Raindrops We are almost there. We have created a catcher, we know how to test for intersection, and we have completed the timer object. The ﬁnal piece of the puzzle is the raindrops themselves. Ultimately, we want an array of Raindrop objects falling from the top of the window to the bottom. Since this step involves creating an array of objects that move, it is useful to approach this fourth part as a series of even smaller steps, subparts of Part 4, thinking again of the individual elements and behaviors we will need. Part 4 Subparts: Part 4.1. A single moving raindrop. Part 4.2. An array of raindrop objects. Part 4.3. Flexible number of raindrops (appearing one at a time). Part 4.4. Fancier raindrop appearance. Part 4.1, creating the motion of a raindrop (a simple circle for now) is easy—Chapter 3 easy. • Increment raindrop y value. • Display raindrop. Translating into code we have Part 4.1—A single moving raindrop, shown in Example 10-6.

Example 10-6: Simple raindrop behavior float x,y; // Variables for drop location void setup() { size(400,400); background(0); x = width/2; y = 0; } void draw() { background(255); // Display the drop fill(50,100,150); noStroke(); ellipse(x,y,16,16); // Move the drop y++; }

Again, however, we need to go a step further and make a Drop class—after all we will ultimately want an array of drops. In making the class, we can add a few more variables, such as speed and size, as well as a function to test if the raindrop reaches the bottom of the screen, which will be useful later for scoring the game. class Drop { float float color float

x,y; // Variables for location of raindrop speed; // Speed of raindrop c; r; // Radius of raindrop

A raindrop object has a location, speed, color, and size.

Algorithms Drop() { r = 8; x = random(width); y = -r*4; speed = random(1,5); c = color(50,100,150); }

// // // // //

179

All raindrops are the same size Start with a random x location Start a little above the window Pick a random speed Color

//Move the raindrop down void move() { y += speed; // Increment by speed } // Check if it hits the bottom boolean reachedBottom() { // If we go a little past the bottom if (y > height+r*4) { return true; } else { return false; } }

Incrementing y is now in the move() function.

In addition, we have a function that determines if the drop leaves the window.

// Display the raindrop void display() { // Display the drop fill(50,100,150); noStroke(); ellipse(x,y,r*2,r*2); } }

Before we move on to Part 4.3, the array of drops, we should make sure that a singular Drop object functions properly. As an exercise, complete the code in Exercise 10-3 that would test a single drop object.

Exercise 10-3: Fill in the blanks below completing the “test Drop” sketch. Drop drop; void setup() { size(200,200); _________________________________; } void draw() { background(255); drop. _________________; _____________________________; }

180

Learning Processing

Now that this is complete, the next step is to go from one drop to an array of drops—Part 4.2. This is exactly the technique we perfected in Chapter 9. // An array of drops Drop[] drops = new Drop[50]; void setup() { size(400,400); smooth(); // Initialize all drops for (int i = 0; i < drops.length; i++) { drops[i] = new Drop(); } } void draw() { background(255); // Move and display all drops for (int i = 0; i < drops.length; i++) { drops[i].move(); drops[i].display(); } }

Instead of one Drop object, an array of 50.

Using a loop to initialize all drops.

Move and display all drops.

The problem with the above code is that the raindrops appear all at once. According to the speciﬁcations we made for our game, we want to have the raindrops appear one at a time, every N seconds—we are now at Part 4.3—Flexible number of raindrops (appearing one at a time). We can skip worrying about the timer for now and just have one new raindrop appear every frame. We should also make our array much larger, allowing for many more raindrops. To make this work, we need a new variable to keep track of the total number of drops—“totalDrops”. Most array examples involve walking through the entire array in order to deal with the entire list. Now, we want to access a portion of the list, the number stored in totalDrops. Let’s write some pseudocode to describe this process: Setup: • Create an array of drops with 1,000 spaces in it. • Set totalDrops = 0. Draw: • Create a new drop in the array (at the location totalDrops). Since totalDrops starts at 0, we will first create a new raindrop in the first spot of the array. • Increment totalDrops (so that the next time we arrive here, we will create a drop in the next spot in the array). • If totalDrops exceeds the array size, reset it to zero and start over. • Move and display all available drops (i.e., totalDrops). Example 10-7 translates the above pseudocode into code.

Algorithms

181

Example 10-7: Drops one at a time // An array of drops Drop[] drops = new Drop[1000]; int totalDrops = 0;

New variable to keep track of total number of drops we want to use!

void setup() { size(400,400); smooth(); background(0); } ﬁg. 10.5

void draw() { background(255); // Initialize one drop drops[totalDrops] = new Drop(); // Increment totalDrops totalDrops++; // If we hit the end of the array if (totalDrops >= drops.length) { totalDrops = 0; //Start over } // Move and display drops for (int i = 0; i < totalDrops; i++) { drops[i].move(); drops[i].display(); }

New! We no longer move and display all drops, but rather only the “totalDrops” that are currently present in the game.

}

We have taken the time to ﬁgure out how we want the raindrop to move, created a class that exhibits that behavior, and made an array of objects from that class. All along, however, we have just been using a circle to display the drop. The advantage to this is that we were able to delay worrying about the drawing code and focus on the motion behaviors and organization of data and functions. Now we can focus on how the drops look—Part 4.4—Finalize raindrop appearance. One way to create a more “drop-like” look is to draw a sequence of circles in the vertical direction, starting small, and getting larger as they move down.

Example 10-8: Fancier looking raindrop background(255); for (int i=2; i= drops.length) { totalDrops = 0; // Start over }

From Part 1. The Catcher!

From Part 3. The Timer!

From Part 4. The Raindrops!

// Move and display all drops for (int i = 0; i < totalDrops; i++) { drops[i].move(); drops[i].display(); } }

The next step is to take these concepts we have developed and have them work together. For example, we should only create a new raindrop whenever two seconds have passed (as indicated by the timer’s isFinished( ) function). // Check the timer if (timer.isFinished()) { // Deal with raindrops // Initialize one drop drops[totalDrops] = new Drop(); // Increment totalDrops totalDrops++; // If we hit the end of the array if (totalDrops >= drops.length) { totalDrops = 0; // Start over } timer.start(); }

Objects working together! Here when the timer “is ﬁnished,” a Drop object is added (by incrementing “totalDrops”).

We also need to ﬁnd out when the Catcher object intersects a Drop. In Section 10.5, we tested for intersection by calling the intersect( ) function we wrote inside the Ball class.

Algorithms

185

boolean intersecting = ball1.intersect(ball2); if (intersecting) { println("The circles are intersecting!"); }

We can do the same thing here, calling an intersect( ) function in the Catcher class and passing through every raindrop in the system. Instead of printing out a message, we will actually want to aﬀect the raindrop itself, telling it to disappear, perhaps. This code assumes that the caught( ) function will do the job. // Move and display all drops for (int i = 0; i < totalDrops; i++) { drops[i].move(); drops[i].display(); if (catcher.intersect(drops[i])) { drops[i].caught(); } }

Objects working together! Here, the Catcher object checks to see if it intersects any Drop object in the drops array.

Our Catcher object did not originally contain the function intersect( ), nor did Drop include caught( ). So these are some new functions we will need to write as part of the integration process. intersect( ) is easy to incorporate since we solved the problem already in Section 10.5 and can literally copy it into the Catcher class (changing the argument from a Ball object to a Drop object). // A function that returns true or false based if the catcher intersects a raindrop boolean intersect(Drop d) { // Calculate distance float distance = dist(x,y,d.x,d.y); // Compare distance to sum of radii In addition to calling functions, we can if (distance < r + d.r) { access variables inside of an object using return true; the dot syntax. } else { return false; } }

When the drop is caught, we will set its location to somewhere oﬀscreen (so that it can’t be seen, the equivalent of “disappearing”) and stop it from moving by setting its speed equal to 0. Although we did not work out this functionality in advance of the integration process, it is simple enough to throw in right now. // If the drop is caught void caught() { speed = 0; // Stop it from moving by setting speed equal to zero y = –1000; // Set the location to somewhere way off-screen }

And we are ﬁnished! For reference, Example 10-10 is the entire sketch. The timer is altered to execute every 300 ms, making the game ever so slightly more diﬃcult.

186

Learning Processing Example 10-10: The raindrop catching game Catcher catcher; Timer timer; Drop[] drops;

// One catcher object // One timer object // An array of drop objects

int totalDrops = 0; void setup() { size(400,400); smooth();

// totalDrops

catcher = new Catcher(32); drops = new Drop[1000]; timer = new Timer(300);

// Create the catcher with a radius of 32 // Create 1000 spots in the array // Create a timer that goes off every 2 seconds

timer.start();

// Starting the timer

} void draw() { background(255); catcher.setLocation(mouseX,mouseY); // Set catcher location catcher.display(); // Display the catcher // Check the timer if (timer.isFinished()) { // Deal with raindrops // Initialize one drop drops[totalDrops] = new Drop(); // Increment totalDrops totalDrops++; // If we hit the end of the array if (totalDrops >= drops.length) { totalDrops = 0; // Start over } timer.start(); } // Move and display all drops for (int i = 0; i < totalDrops; i++) { drops[i].move(); drops[i].display(); if (catcher.intersect(drops[i])) { drops[i].caught(); } } } class Catcher { float r; // radius color col; // color float x,y; // location Catcher(float tempR) { r = tempR; col = color(50,10,10,150); x = 0; y = 0; }

ﬁg. 10.9

Algorithms

187

void setLocation(float tempX, float tempY) { x = tempX; y = tempY; } void display() { stroke(0); fill(col); ellipse(x,y,r*2,r*2); } // A function that returns true or false based if the catcher intersects a raindrop boolean intersect(Drop d) { float distance = dist(x,y,d.x,d.y); // Calculate distance if (distance < r + d.r) { // Compare distance to sum of radii return true; } else { return false; } } } class Drop { float float color float

x,y; speed; c; r;

// Variables for location of raindrop // Speed of raindrop // Radius of raindrop

Drop() { r = 8; x = random(width); y = -r*4; speed = random(1,5); c = color(50,100,150); }

// // // // //

All raindrops are the same size Start with a random x location Start a little above the window Pick a random speed Color

// Move the raindrop down void move() { y += speed; // Increment by speed } // Check if it hits the bottom boolean reachedBottom() { if (y > height+r*4) { // If we go a little beyond the bottom return true; } else { return false; } } // Display the raindrop void display() { // Display the drop fill(c);

188

Learning Processing noStroke(); for (int i = 2; i < r; i++) { ellipse(x,y+i*4,i*2,i*2); } } // If the drop is caught void caught() { speed = 0; // Stop it from moving by setting speed equal to zero // Set the location to somewhere way off-screen y = –1000; } } class Timer { int savedTime; // When Timer started int totalTime; // How long Timer should last Timer(int tempTotalTime) { totalTime = tempTotalTime; } // Starting the timer void start() { savedTime = millis(); } boolean isFinished() { // Check out much time has passed int passedTime = millis()- savedTime; if (passedTime > totalTime) { return true; } else { return false; } } }

Exercise 10-4: Implement a scoring system for the game. Start the player oﬀ with 10 points. For every raindrop that reaches the bottom, decrease the score by 1. If all 1,000 raindrops fall without the score getting to zero, a new level begins and the raindrops appear faster. If 10 raindrops reach the bottom during any level, the player loses. Show the score onscreen as a rectangle that decreases in size. Do not try to implement all of these features at once. Do them one step at a time!

10.9 Getting Ready for Act II The point of this chapter is not to learn how to program a game of catching falling raindrops, rather it is to develop an approach to problem solving—taking an idea, breaking it down into parts, developing pseudocode for those parts, and implementing them one very small step at a time.

Algorithms

189

It is important to remember that getting used to this process takes time and it takes practice. Everyone struggles through it when ﬁrst learning to program. Before we embark on the rest of this book, let’s take a moment to consider what we have learned and where we are headed. In these 10 chapters, we have focused entirely on the fundamentals of programming. • Data—in the form of variables and arrays. • Control Flow—in the form of conditional statements and loops. • Organization—in the form of functions and objects. These concepts are not unique to Processing and will carry you through to any and all programming languages and environments, such as C, Actionscript (as in Flash), and server-side programming languages such as PHP. The syntax may change, but the fundamental concepts will not. Starting with Chapter 13 the book will focus on some advanced concepts available in Processing, such as three-dimensional translation and rotation, image processing and video capture, networking, and sound. Although these concepts are certainly not unique to Processing, the details of their implementation will be more speciﬁc to the environment we have chosen. Before we move on to these advanced topics we will take a quick look at basic strategies for ﬁxing errors in your code (Chapter 11: Debugging) as well as how to use Processing libraries (Chapter 12). Many of these advanced topics require importing libraries that come with Processing as well as libraries made for this book or by third parties. One of the strengths of Processing is its ability to be easily extended with libraries. We will see some hints of how to create your own libraries in the ﬁnal chapter of this book. Onward, ho!

190

Learning Processing

Lesson Five Project Step 1. Develop an idea for a project that can be created with Processing using simple shape drawing and the fundamentals of programming. If you feel stuck, try making a game such as Pong or Tic-Tac-Toe. Step 2. Follow the strategy outlined in this chapter and break the idea down into smaller parts, implementing the algorithm for each one individually. Make sure to use object-oriented programming for each part. Step 3. Bring the smaller parts together in one program. Did you forget any elements or features? Use the space provided below to sketch designs, notes, and pseudocode for your project.

Debugging

191

11 Debugging “ The diﬀerence between the right word and the almost right word is the diﬀerence between lightning and a lightning bug.” —Mark Twain “L’appétit vient en mangeant.” —The French

Bugs happen. Five minutes ago, your code was working perfectly and you swear, all you did was change the color of some object! But now, when the spaceship hits the asteroid, it doesn’t spin any more. But it was totally spinning ﬁve minutes ago! And your friend agrees: “ Yeah, I saw it spin. That was cool.” The rotate( ) function is there. What happened? It should work. This makes no sense at all! The computer is probably broken. Yeah. Yeah. It is deﬁnitely the computer’s fault. No matter how much time you spend studying computer science, reading programming books, or playing audio recordings of code while you sleep hoping it will soak in that way, there is just no way to avoid getting stuck on a bug. It can be really frustrating. A bug is any defect in a program. Sometimes it is obvious that you have a bug; your sketch will quit (or not run at all) and display an error in the message console. These types of bugs can be caused by simple typos, variables that were never initialized, looking for an element in an array that doesn’t exist, and so on. For some additional clues on “error” bugs, take a look at the Appendix on errors at the end of this book. Bugs can also be more sinister and mysterious. If your Processing sketch does not function the way you intended it to, you have a bug. In this case, your sketch might run without producing any errors in the message console. Finding this type of bug is more diﬃcult since it will not necessarily be as obvious where to start looking in the code. In this chapter, we will discuss a few basic strategies for ﬁxing bugs (“debugging”) with Processing.

11.1 Tip #1: Take a break. Seriously. Go away from your computer. Sleep. Go jogging. Eat an orange. Play scrabble. Do something other than working on your code. I can’t tell you how many times I have stared at my code for hours unable to ﬁx it, only to wake up the next morning and solve the problem in ﬁve minutes.

11.2 Tip #2: Get another human being involved. Talk through the problem with a friend. The process of showing your code to another programmer (or nonprogrammer, even) and walking through the logic out loud will often reveal the bug. In many cases, it is something obvious that you did not see because you know your code so well. The process of explaining it to someone else, however, forces you to go through the code more slowly. If you do not have a friend nearby, you can also do this out loud to yourself. Yes, you will look silly, but it helps.

192

Learning Processing

11.3 Tip #3: Simplify Simplify. Simplify! SIMPLIFY! In Chapter 10, we focused on the process of incremental development. The more you develop your projects step-by-step, in small, easy to manage pieces, the fewer errors and bugs you will end up having. Of course, there is no way to avoid problems completely, so when they do occur, the philosophy of incremental development can also be applied to debugging. Instead of building the code up piece by piece, debugging involves taking the code apart piece by piece. One way to accomplish this is to comment out large chunks of code in order to isolate a particular section. Following is the main tab of an example sketch. The sketch has an array of Snake objects, a Button object, and an Apple object. (The code for the classes is not included.) Let’s assume that everything about the sketch is working properly, except that the Apple is invisible. To debug the problem, everything is commented out except for the few lines of code that deal directly with initializing and displaying the Apple object. // Snake[] snakes = new Snake[100]; // Button button; Apple apple; void setup() { size(200,200); apple = new Apple(); /*for (int i = 0; i < snakes.length; i++) { snakes[i] = new Snake(); } button = new Button(10,10,100,50); smooth();*/ } void draw() { background(0); apple.display(); // apple.move();

/*for (int i = 0; i < snakes. length; i++) { snakes[i].display(); snakes[i].slither(); snakes[i].eat(apple); } if (button.pressed()) { applet.restart(); }*/ }

/*void mousePressed() { button.click(mouseX,mouseY); }*/

Only the code that makes the Apple object and displays the object is left uncommented. This way, we can be sure that none of the other code is the cause of the issue.

Large blocks of code can be commented out between /*and*/ /*All of this is commented out */

Debugging

193

Once all the code is commented out, there are two possible outcomes. Either the apple still does not appear or it does. In the former, the issue is most deﬁnitely caused by the apple itself, and the next step would be to investigate the insides of the display( ) function and look for a mistake. If the apple does appear, then the problem is caused by one of the other lines of code. Perhaps the move( ) function sends the apple oﬀscreen so that we do not see it. Or maybe the Snake objects cover it up by accident. To ﬁgure this out, I would recommend putting back lines of code, one at a time. Each time you add back in a line of code, run the sketch and see if the apple disappears. As soon as it does, you have found the culprit and can root out the cause. Having an object-oriented sketch as above (with many classes) can really help the debugging process. Another tactic you can try is to create a new sketch and just use one of the classes, testing its basic features. In other words, do not worry about ﬁxing your entire program just yet. First, create a new sketch that only does one thing with the relevant class (or classes) and reproduce the error. Let’s say that, instead of the apple, the snakes are not behaving properly. To simplify and ﬁnd the bug, we could create a sketch that just uses one snake (instead of an array) without the apple or the button. Without the bells and whistles, the code will be much easier to deal with. Snake snake; void setup() { size(200,200); snake = new Snake(); } void draw() { background(0); snakes.display(); snakes.slither(); //snakes.eat(apple); }

Since this version does not include an Apple object, we cannot use this line of code. As part of the debugging process, however, we might incrementally add back in the apple and uncomment this line.

Although we have not yet looked at examples that involve external devices (we will in many of the chapters that follow), simplifying your sketch can also involve turning oﬀ connections to these devices, such as a camera, microphone, or network connection and replacing them with “dummy ” information. For example, it is much easier to ﬁnd an image analysis problem if you just load a JPG, rather than use a live video source. Or load a local text ﬁle instead of connecting to a URL XML feed. If the problem goes away, you can then say deﬁnitively: “Aha, the web server is probably down” or “My camera must be broken.” If it does not, then you can dive into your code knowing the problem is there. If you are worried about worsening the problem by taking out sections of code, just make a copy of your sketch ﬁrst before you begin removing features.

11.4 Tip #4: println( ) is your friend. Using the message window to display the values of variables can be really helpful. If an object is completely missing on the screen and you want to know why, you can print out the values of its location variables. It might look something like this: println("x: " + thing.x + " y: " + thing.y);

194

Learning Processing

Let’s say the result is: x: x: x: x: x:

9000000 9000116 9000184 9000299 9000682

y: y: y: y: y:

–900000 –901843 –902235 –903720 –904903

It is pretty obvious that these values are not reasonable pixel coordinates. So something would be oﬀ in the way the object is calculating its (x,y) location. However, if the values were perfectly reasonable, then you would move on. Maybe the color is the problem? println("brightness: " + brightness(thing.col) + " alpha: " + alpha(thing.col));

Resulting in: brightness: 150.0 alpha: 0.0

Well, if the alpha value of the object’s color is zero, that would explain why you can’t see it! We should take a moment here to remember Tip #3: Simplify. This process of printing variable values will be much more eﬀective if we are doing it in a sketch that only deals with the Thing object. This way, we can be sure that it is not another class which is, say, drawing over the top of the Thing by accident. You may have also noticed that the above print statements concatenate actual text with the variables. (See Chapter 17 for more on concatenation.) It is generally a good idea to do this. The following line of code only prints the value of x, with no explanation. println(x);

This can be confusing to follow in the message window, especially if you are printing diﬀerent values in diﬀerent parts of the code. How do you know what is x and what is y? If you include your own notes in println( ), there can’t be any confusion: println("The x value of the thing I’m looking for is: " + x);

In addition, println( ) can be used to indicate whether or not a certain part of the code has been reached. For example, what if in our “ bouncing ball” example, the ball never bounces oﬀ of the right-hand side of the window? The problem could be (a) you are not properly determining when it hits the edge, or (b) you are doing the wrong thing when it hits the edge. To know if your code correctly detects when it hits the edge, you could write: if (x > width) { println("X is greater than width. This code is happening now!"); xspeed *= –1; }

If you run the sketch and never see the message printed, then something is probably ﬂawed with your boolean expression. Admittedly, println( ) is not a perfect debugging tool. It can be hard to track multiple pieces of information with the message window. It can also slow your sketch down rather signiﬁcantly (depending on how much printing you are doing). More advanced development environments usually oﬀer debugging tools which allow you to track speciﬁc variables, pause the program, advance line by line in the code, and so on. This is one of the trade-oﬀs we get using Processing. It is much simpler to use, but it does not have all of the advanced features. Still, in terms of debugging, some sleep, a little common sense, and println( ) can get you pretty far.

Libraries

195

12 Libraries “If truth is beauty, how come no one has their hair done in the library?” —Lily Tomlin

Many of the chapters that follow require the use of Processing libraries. This chapter will cover how to download, install, and use these libraries. I recommend that you read the chapter for a basic sense of libraries now (we will start talking about them immediately in Chapter 14: Translation and Rotation) and, if necessary, refer back to it when you suddenly ﬁnd yourself downloading one (which ﬁrst occurs in Chapter 15: Video).

12.1 Libraries Whenever we call a Processing function, such as line( ), background( ), stroke( ), and so on, we are calling a function that we learned about from the Processing reference page (or perhaps even from this book!). That reference page is a list of all the available functions in the core Processing library. In computer science, a library refers to a collection of “helper” code. A library might consist of functions, variables, and objects. The bulk of things we do are made possible by the core Processing library. In most programming languages, you are required to specify which libraries you intend to use at the top of your code. This tells the compiler (see Chapter 2) where to look things up in order to translate your source code into machine code. If you were to investigate the ﬁles inside of your Processing application directory, you would ﬁnd a ﬁle named core.jar inside of the folder lib. That jar ﬁle contains the compiled code for just about everything we do in Processing. Since it is used in every program, Processing just assumes that it should be imported and does not require that you explicitly write an import statement. However, if this were not the case, you would have the following line of code at the top of every single sketch: import processing.core.*;

“Import ” indicates we are going to make use of a library, and the library we are going to use is “processing. core.” The “.*” is a wildcard, meaning we would like access to everything in the library. The naming of the library using the dot syntax (processing dot core) has to do with how collections of classes are organized into “packages” in the Java programming language. As you get more comfortable with Processing and programming, this is likely a topic you will want to investigate further. For now, all we need to know is that “processing.core” is the name of the library. While the core library covers all the basics, for other more advanced functionality, you will have to import speciﬁc libraries that are not assumed. Our ﬁrst encounter with this will come in Chapter 14, where in order to make use of the OpenGL renderer, the OpenGL library will be required: import processing.opengl.*;

196

Learning Processing

Many of the chapters that follow will require the explicit use of external Processing libraries, such as video, networking, serial, and so on. Documentation for these libraries can be found on the Processing web site at http://www.processing.org/reference/libraries/. There, you will ﬁnd a list of libraries that come with Processing, as well as links to third party libraries available for download on the web.

12.2 Built-in Libraries Using a built-in library is easy because there is no installation required. These libraries come with your Processing application. The list of built-in libraries (full list available at above URL) is not terribly long and all but a few are covered in this book as listed below. • Video—For capturing images from a camera, playing movie files, and recording movie files. Covered in Chapters 16 and 21. • Serial—For sending data between Processing and an external device via serial communication. Covered in Chapter 19. • OpenGL—For rendering a sketch with graphics acceleration. Covered in Chapter 14. • Network—For creating client and server sketches that can communicate across the internet. Covered in Chapter 19. • PDF—For creating high resolution PDFs of graphics generated in Processing. Covered in Chapter 21. • XML—For importing data from XML documents. Covered in Chapter 18. Examples speciﬁcally tailored toward using the above libraries are found in the chapters listed. The Processing web site also has superb documentation for these libraries (found on the “libraries” page). The only generic knowledge you need regarding Processing built-in libraries is that you must include the appropriate import statement at the top of your program. This statement will automatically be added to the sketch if you select SKETCH→IMPORT LIBRARY. Or, you can simply type the code in manually (using the import library menu option does not do anything other than just add the text for the import statement). import import import import import import

processing.video.*; processing.serial.*; processing.opengl.*; processing.net.*; processing.pdf.*; processing.xml.*;

12.3 Contributed Libraries The world of third party (also known as “contributed”) libraries for Processing resembles the wild west. As of the writing of this book, there are 47 contributed libraries, with capabilities ranging from sound generation and analysis, to packet sniﬃng, to physics simulations, to GUI controls. Several of these contributed libraries will be demonstrated over the course of the remainder of this book. Here, we will take a look at the process of downloading and installing a contributed library. The ﬁrst thing you need to do is ﬁgure out where you installed Processing. On a Mac, the application is most likely found in the “Applications” directory, on a PC, “Program Files.” We will make this assumption, but have no fear if you installed it somewhere else (Processing can be installed in any directory and will work just ﬁne), just replace the path listed below with your own ﬁle path! Once you have determined where you installed Processing, take a look inside the Processing folder. See Figure 12.1.

Libraries

197

/Applications/Processing 0135/ or c:/Program Files/Processing 0135/

ﬁg. 12.1

Inside the libraries directory, you will ﬁnd folders for each of the built-in libraries, along with a “howto.txt ” ﬁle that provides tips and instructions related to making your own library (a topic beyond the scope of this book). See Figure 12.2.

ﬁg. 12.2

The libraries directory is where you will install contributed libraries. The ﬁrst use of a third party library can be found in Chapter 18 of this book. The “simpleML” library, designed to make HTML and XML data retrieval simple, is available for download at the book’s web site, http://www.learningprocessing.com/libraries. If you want to get a jump start on Chapter 18, download the ﬁle simpleML.zip and follow the instructions below, and illustrated in Figure 12.3. The process for installing other contributed libraries will be identical, with the exception of ﬁlenames. Step 1. Extract the ZIP ﬁle. This can usually be accomplished by double-clicking the ﬁle or with any decompression application, such as Winzip on a PC.

198

Learning Processing

ﬁg. 12.3

Step 2. Copy the extracted ﬁles to the Processing libraries folder. Most libraries you download will automatically unpack with the right directory structure. The full directory structure should look like this: /Processing 0135/libraries/simpleML/library/simpleML.jar More generically: /Processing 0135/libraries/libraryName/library/libraryName.jar Some libraries may include additional ﬁles in the “ library ” folder, as well as the source code (which is commonly stored one directory up, in the “ libraryName” folder). If the library does not automatically unpack itself with the above directory structure, you can manually create these folders (using the ﬁnder or explorer) and place the libraryName.jar ﬁle in the appropriate location yourself. Step 3. Restart Processing. If Processing was running while you performed Step 2, you will need to quit Processing and restart it in order for the library to be recognized. Once you have restarted, if everything has gone according to plan, the library will appear under the “Sketch→Import Library ” option shown in Figure 12.4.

ﬁg. 12.4

The newly installed library will now appear in the list! What to do once you have installed the library really depends on which library you have installed. Examples that make use in code of a contributed library can be found in Chapter 18 (simpleML, Yahoo API) and Chapter 20 (Sonia, Minim).

Lesson Six The World Revolves Around You

13 Mathematics 14 Translation and Rotation (in 3D!)

This page intentionally left blank

Mathematics

201

13 Mathematics “If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is.” —John von Neumann “If you were cosine squared, I’d be sine squared, because together we’d be one.” —Anonymous In this chapter: – Probability. – Perlin noise. – Trigonometry. – Recursion.

Here we are. The fundamentals are ﬁnished and we are going to start looking at some more sophisticated topics in Processing. You may ﬁnd there is less of a story to follow from chapter to chapter. Nonetheless, although the concepts do not necessarily build on each other as ﬂuidly as they did previously, the chapters are ordered with a step-by-step learning approach in mind. Everything we do from here on out will still employ the same ﬂow structure of setup( ) and draw( ). We will continue to use functions from the Processing library and algorithms made of conditional statements and loops, and organize sketches with an object-oriented approach in mind. At this point, however, the descriptions will assume a knowledge of these essential topics and I encourage you to return to earlier chapters to review as needed.

13.1 Mathematics and Programming Did you ever start to feel the sweat beading on your forehead the moment your teacher called you up to the board to write out the solution to the latest algebra assignment? Does the mere mention of the word “calculus” cause a trembling sensation in your extremities? Relax, there is no need to be afraid. There is nothing to fear, but the fear of mathematics itself. Perhaps at the beginning of reading this book, you feared computer programming. I certainly hope that, by now, any terriﬁed sensations associated with code have been replaced with feelings of serenity. This chapter aims to take a relaxed and friendly approach to a few useful topics from mathematics that will help us along the journey of developing Processing sketches. You know, we have been using math all along. For example, we have likely had an algebraic expression on almost every single page since learning variables. x = x + 1;

202

Learning Processing

And most recently, in Chapter 10, we tested intersection using the Pythagorean Theorem. float d = dist(x1,x2,y1,y2);

These are just a few examples we have seen so far and as you get more and more advanced, you may even ﬁnd yourself online, late at night, googling “Sinusoidal Spiral Inverse Curve.” For now, we will start with a selection of useful mathematical topics.

13.2 Modulus We begin with a discussion of the modulo operator, written as a percent sign, in Processing. Modulus is a very simple concept (one that you learned without referring to it by name when you ﬁrst studied division) that is incredibly useful for keeping a number within a certain boundary (a shape on the screen, an index value within the range of an array, etc.) The modulo operator calculates the remainder when one number is divided by another. It works with both integers and ﬂoats. 20 divided by 6 equals 3 remainder 2. (In other words: 6*3 ⴙ 2 ⴝ 18 ⴙ 2 ⴝ 20.) therefore: 20 modulo 6 equals 2

or

20 % 6 ⴝ 2

Here are a few more, with some blanks for you to ﬁll in. 17 divided by 4 equals 4 remainder 1

17 % 4  1

3 divided by 5 equals 0 remainder 3

3%53

10 divided by 3.75 equals 2 remainder 2.5

10.0 % 3.75  2.5

100 divided by 50 equals ___________ remainder _______________

100 % 40  ____________

9.25 divided by 0.5 equals ___________ remainder _______________

9.25 % 0.5  ___________

You will notice that if A  B % C, A can never be larger than C. The remainder can never be larger than the divisor. 0%30 1%31 2%32 3%30 4%31 etc.

Mathematics

203

Therefore, modulo can be used whenever you need to cycle a counter variable back to zero. The following lines of code: x = x + 1; if (x >= limit) { x = 0; }

can be replaced by: x = (x + 1) % limit;

This is very useful if you want to count through the elements of an array one at a time, always returning to 0 when you get to the length of the array. Example 13-1: Modulo // 4 random numbers float[] randoms = new float[4]; int index = 0; // Which number are we using void setup() { size(200,200); // Fill array with random values for (int i = 0; i < randoms.length; i++) { randoms[i] = random(0,256); } frameRate(1); } void draw() { // Every frame we access one element of the array background(randoms[index]); // And then go on to the next one index = (index + 1) % randoms.length; Using the modulo operator }

to cycle a counter back to 0.

13.3 Random Numbers In Chapter 4, we were introduced to the random( ) function, which allowed us to randomly ﬁll variables. Processing’s random number generator produces what is known as a “uniform” distribution of numbers. For example, if we ask for a random number between 0 and 9, 0 will come up 10% of the time, 1 will come up 10% of the time, 2 will come up 10% of the time, and so on. We could write a simple sketch using an array to prove this fact. See Example 13-2.

Pseudo-Random Numbers The random numbers we get from the random( ) function are not truly random and are known as “pseudo-random.” They are the result of a mathematical function that simulates randomness. This function would yield a pattern over time, but that time period is so long that for us, it is just as good as pure randomness!

204

Learning Processing Example 13-2: Random number distribution // An array to keep track of how often random numbers are picked. float[] randomCounts; void setup() { size(200,200); randomCounts = new float[20]; } void draw() { background(255);

ﬁg. 13.1

// Pick a random number and increase the count int index = int(random(randomCounts.length)); randomCounts[index]++; // Draw a rectangle to graph results stroke(0); fill(175); for (int x = 0; x < randomCounts.length; x++) { rect(x*10,0,9,randomCounts[x]); } }

With a few tricks, we can change the way we use random( ) to produce a nonuniform distribution of random numbers and generate probabilities for certain events to occur. For example, what if we wanted to create a sketch where the background color had a 10% chance of being green and a 90% chance of being blue?

13.4 Probability Review Let’s review the basic principles of probability, ﬁrst looking at single event probability, that is, the likelihood of something to occur. Given a system with a certain number of possible outcomes, the probability of any given event occurring is the number of outcomes which qualify as that event divided by total number of possible outcomes. The simplest example is a coin toss. There are a total of two possible outcomes (heads or tails). There is only one way to ﬂip heads, therefore the probability of heads is one divided by two, that is, 1/2 or 50%. Consider a deck of 52 cards. The probability of drawing an ace from that deck is: number of aces/number of cards ⴝ 4/52 ⴝ 0.077 ⴝ ⬃8% The probability of drawing a diamond is: number of diamonds/number of cards ⴝ 13/52 ⴝ 0.25 ⴝ 25% We can also calculate the probability of multiple events occurring in sequence as the product of the individual probabilities of each event.

Mathematics

205

The probability of a coin ﬂipping up heads three times in a row is: (1/2) * (1/2) * (1/2) ⴝ 1/8 (or 0.125). In other words, a coin will land heads three times in a row one out of eight times (with each “time” being three tosses).

Exercise 13-1: What is the probability of drawing two aces in a row from the deck of cards? ______________________________________

13.5 Event Probability in Code There are few diﬀerent techniques for using the random( ) function with probability in code. For example, if we ﬁll an array with a selection of numbers (some repeated), we can randomly pick from that array and generate events based on what we select. int[] stuff = new int[5]; stuff[0] = 1; stuff[1] = 1; stuff[2] = 2; stuff[3] = 3; stuff[4] = 3; int index = int(random(stuff.length)); if (stuff[index] == 1) { // do something }

Picking a random element from an array.

If you run this code, there will be a 40% chance of selecting the value 1, a 20% chance of selecting the value 2, and a 40% chance of selecting the value 3. Another strategy is to ask for a random number (for simplicity, we consider random ﬂoating point values between 0 and 1) and only allow the event to happen if the random number we pick is within a certain range. For example: float prob = 0.10; float r = random(l); if (r < prob) {

// A probability of 10% // A random floating point value between 0 and 1 // If our random is less than .1

/*INSTIGATE THE EVENT HERE*/ }

This code will only be executed 10% of the time.

This same technique can also be applied to multiple outcomes. Outcome A — 60% | Outcome B — 10% | Outcome C — 30%

206

Learning Processing

To implement this in code, we pick one random ﬂoat and check where it falls. • Between 0.00 and 0.60 (10%) → outcome A. • Between 0.60 and 0.70 (60%) → outcome B. • Between 0.70 and 1.00 (30%) → outcome C. Example 13-3 draws a circle with a three diﬀerent colors, each with the above probability (red: 60%, green: 10%, blue: 30%). This example is displayed in Figure 13.2.

Example 13-3: Probabilities void setup() { size(200,200); background(255); smooth(); noStroke(); } void draw() { // Probabilities for 3 different cases // These need to add up to 100%! float red_prob = 0.60; // 60% chance of red color float green_prob = 0.10; // 10% chance of green color float blue_prob = 0.30; // 30% chance of blue color float num = random(1);

ﬁg. 13.2

// pick a random number between 0 and 1

// If random number is less than .6 if (num < red_prob) { fill(255,53,2,150); // If random number is between .6 and .7 } else if (num < green_prob + red_prob) { fill(156,255,28,150); // All other cases (i.e. between .7 and 1.0) } else { fill(10,52,178,150); } ellipse(random(width),random(height),64,64); }

Exercise 13-2: Fill in the blanks in the following code so that the circle has a 10% chance of moving up, a 20% chance of moving down, and a 70% chance of doing nothing. float y = 100; void setup() { size(200,200); smooth(); }

Mathematics

207

void draw() { background(0); float r = random(1); ____________________________________________________ ____________________________________________________ ____________________________________________________ ____________________________________________________ ____________________________________________________ ____________________________________________________ ellipse(width/2,y,16,16); }

13.6 Perlin Noise One of the qualities of a good random number generator is that the numbers produced appear to have no relationship. If they exhibit no discernible pattern, they are considered random. In programming behaviors that have an organic, almost lifelife quality, a little bit of randomness is a good thing. However, we do not want too much randomness. This is the approach taken by Ken Perlin, who developed a function in the early 1980’s entitled “Perlin noise” that produces a naturally ordered (i.e., “smooth”) sequence of pseudo-random numbers. It was originally designed to create procedural textures, for which Ken Perlin won an Academy Award for Technical Achievement. Perlin noise can be used to generate a variety of interesting eﬀects including clouds, landscapes, marble textures, and so on. Figure 13.3 shows two graphs,—a graph of Perlin noise over time (the x-axis represents time; note how the curve is smooth) compared to a graph of pure random numbers over time. (Visit this book’s web site for the code that generated these graphs.)

ﬁg. 13.3

Perlin Noise

Random

208

Learning Processing

Noise Detail If you visit the Processing.org noise reference, you will ﬁnd that noise is calculated over several “octaves.” You can change the number of octaves and their relative importance by calling the noiseDetail( ) function. This, in turn, can change how the noise function behaves. See http://processing.org/reference/noiseDetail_.html. You can read more about how noise works from Ken Perlin himself: http://www.noisemachine.com/talk1/.

Processing has a built-in implementation of the Perlin noise algorithm with the function noise( ). The noise( ) function takes one, two, or three arguments (referring to the “space” in which noise is computed: one, two, or three dimensions). This chapter will look at one-dimensional noise only. Visit the Processing web site for further information about two-dimensional and three-dimensional noise. One-dimensional Perlin noise produces as a linear sequence of values over time. For example: 0.364, 0.363, 0.363, 0.364, 0.365 Note how the numbers move up or down randomly, but stay close to the value of their predecessor. Now, in order to get these numbers out of Processing, we have to do two things: (1) call the function noise( ), and (2) pass in as an argument the current “time.” We would typically start at time t  0 and therefore call the function like so: “noise(t);” float t = 0.0; float noisevalue = noise(t); // Noise at time 0

We can also take the above code and run it looping in draw( ).

float t = 0.0; void draw() { float noisevalue = noise(t); println(noisevalue); }

Output: 0.28515625 0.28515625 0.28515625 0.28515625

The above code results in the same value printed over and over. This is because we are asking for the result of the noise( ) function at the same point in “time”—0.0—over and over. If we increment the “time” variable t, however, we will get a diﬀerent result.

float t = 0.0; void draw() { float noisevalue = noise(t); println(noisevalue); t += 0.01; }

Time moves forward!

Output: 0.12609221 0.12697512 0.12972163 0.13423012 0.1403218

Mathematics

209

How quickly we increment t also aﬀects the smoothness of the noise. Try running the code several times, incrementing t by 0.01, 0.02, 0.05, 0.1, 0.0001, and so on. By now, you may have noticed that noise( ) always returns a ﬂoating point value between 0 and 1. This detail cannot be overlooked, as it aﬀects how we use Perlin noise in a Processing sketch. Example 13-4 assigns the result of the noise( ) function to the size of a circle. The noise value is scaled by multiplying by the width of the window. If the width is 200, and the range of noise( ) is between 0.0 and 1.0, the range of noise( ) multiplied by the width is 0.0 to 200.0. This is illustrated by the table below and by Example 13-4.

Noise Value

Multiplied by

Equals

0

200

0

0.12

200

24

0.57

200

114

0.89

200

178

1

200

200

Example 13-4: Perlin noise float time = 0.0; float increment = 0.01;

void setup() { size(200,200); smooth(); {

void draw() { background(255);

float n = noise(time)*width;

ﬁg. 13.4

Get a noise value at “time” and scale it according to the window’s width.

// With each cycle, increment the "time" time += increment;

// Draw the ellipse with size determined by Perlin noise fill(0); ellipse(width/2,height/2,n,n); }

210

Learning Processing

Exercise 13-3: Complete the following code which uses Perlin noise to set the location of a circle. Run the code. Does the circle appear to be moving “naturally”? // Noise "time" variables float xtime = 0.0; float ytime = 100.0; float increment = 0.01; void setup() {

In this sketch, we want to use noise for two different values. So that the output of the noise function is not identical, we start at two different points in time.

size(200,200); smooth(); } void draw() { background(0); float x = ____________________________________; float y = ____________________________________; ____________________________________; ____________________________________; // Draw the ellipse with size determined by Perlin noise fill(200); ellipse(__________,__________,__________,__________); }

13.7 Angles Some of the examples in this book will require a basic understanding of how angles are deﬁned in Processing. In Chapter 14, for example, we will need to know about angles in order to feel comfortable using the rotate( ) function to rotate and spin objects. In order to get ready for these upcoming examples, we need to learn about radians and degrees. It is likely you are familiar with the concept of an angle in degrees. A full rotation goes from zero to 360°. An angle of 90° (a right angle) is one-fourth of 360°, shown in Figure 13.5 as two perpendicular lines.

90° 45 ° ﬁg. 13.5

180° 0°

360°

Mathematics

211

It is fairly intuitive for us to think angles in terms of degrees. For example, the rectangle in Figure 13.6 is rotated 45° around its center. Processing, however, requires angles to be speciﬁed in radians. A radian is a unit of measurement for angles deﬁned by the ratio of the length of the arc of a circle to the radius of that circle. One radian is the angle at which that ratio equals one (see Figure 13.7). An angle of 180°  PI radians. An angle of 360°  2*PI radians, and 90°  PI/2 radians, and so on. ﬁg. 13.6

arc length  radius

angle  1 radian

radius ﬁg. 13.7

The formula to convert from degrees to radians is: Radians  2 * PI * (degrees/360) Fortunately for us, if we prefer to think in degrees but code with radians, Processing makes this easy. The radians( ) function will automatically convert values from degrees to radians. In addition, the constants PI and TWO_PI are available for convenient access to these commonly used numbers (equivalent to 180° and 360°, respectively). The following code, for example, will rotate shapes by 60° (rotation will be fully explored in the next chapter). float angle = radians(60); rotate(angle);

PI, What Is It? The mathematical constant PI (or π) is a real number deﬁned as the ratio of a circle’s circumference (the distance around the perimeter) to its diameter (a straight line that passes through the circle center). It is equal to approximately 3.14159.

212

Learning Processing

Exercise 13-4: A dancer spins around two full rotations. How many degrees did the dancer rotate? How many radians?

Degrees: _____________________

Radians: _____________________

13.8 Trigonometry Sohcahtoa. Strangely enough, this seemingly nonsense word, sohcahtoa, is the foundation for a lot of computer graphics work. Any time you need to calculate an angle, determine the distance between points, deal with circles, arcs, lines, and so on, you will ﬁnd that a basic understanding of trigonometry is essential. Trigonometry is the study of the relationships between the sides and angles of triangles and sohcahtoa is a mnemonic device for remembering the deﬁnitions of the trigonometric functions, sine, cosine, and tangent. See Figure 13.8.

hy

po

ten

us

e

• soh: sine  opposite/hypotenuse • cah: cosine  adjacent/hypotenuse • toa: tangent  opposite/adjacent

opposite

angle adjacent

right angle  90°  π/2 radians

ﬁg. 13.8

Any time we display a shape in Processing, we have to specify a pixel location, given as x and y coordinates. These coordinates are known as Cartesian coordinates, named for the French mathematician René Descartes who developed the ideas behind Cartesian space. Another useful coordinate system, known as polar coordinates, describes a point in space as an angle of rotation around the origin and a radius from the origin. We can’t use polar coordinates as arguments to a function in Processing. However, the trigonometric formulas allow us to convert those coordinates to Cartesian, which can then be used to draw a shape. See Figure 13.9.

Mathematics

213

y-axis Polar coordinate (r,θ) Cartesian coordinate (x ,y)

r sin(θ) = y/r cos(θ) = x/r

y

The Greek letter θ (theta) is often used as a symbol for an angle.

θ x-axis

x ﬁg. 13.9

sine(theta)  y/r → y  r * sine(theta) cosine(theta)  x/r → x  r * cosine(theta) For example, if r is 75 and theta is 45° (or PI/4 radians), we can calculate x and y as follows. The functions for sine and cosine in Processing are sin( ) and cos( ), respectively. They each take one argument, a ﬂoating point angle measured in radians. float float float float

r = 75; theta = PI / 4; // We could also say: float theta = radians(45); x = r * cos(theta); y = r * sin(theta);

This type of conversion can be useful in certain applications. For example, how would you move a shape along a circular path using Cartesian coordinates? It would be tough. Using polar coordinates, however, this task is easy. Simply increment the angle! Here is how it is done with global variables r and theta.

Example 13-5: Polar to Cartesian // A Polar coordinate float r = 75; float theta = 0; void setup() { size(200,200); background(255); smooth(); }

Polar coordinates (r, theta) are converted to Cartesian (x,y) for use in the ellipse() function.

void draw() { // Polar to Cartesian conversion float x = r * cos(theta); float y = r * sin(theta);

ﬁg. 13.10

214

Learning Processing // Draw an ellipse at x,y noStroke(); fill(0); ellipse(x+width/2, y+height/2, 16, 16); // Adjust for center of window // Increment the angle theta += 0.01; }

Exercise 13-5: Using Example 13-5, draw a spiral path. Start in the center and move outward. Note that this can be done by changing only one line of code and adding one line of code!

13.9 Oscillation Trigonometric functions can be used for more than geometric calculations associated with right triangles. Let’s take a look at Figure 13.11, a graph of the sine function where y  sin(x).

4

y

2 x

0 0

1π

1π

2π

2 4 ﬁg. 13.11

You will notice that the output of sine is a smooth curve alternating between –1 and 1. This type of behavior is known as oscillation, a periodic movement between two points. A swinging pendulum, for example, oscillates. We can simulate oscillation in a Processing sketch by assigning the output of the sine function to an object’s location. This is similar to how we used noise( ) to control the size of a circle (see Example 13-4), only with sin( ) controlling a location. Note that while noise( ) produces a number between 0 and 1.0, sin( ) outputs a range between –1 and 1. Example 13-6 shows the code for an oscillating pendulum.

Mathematics

215

Example 13-6: Oscillation float theta = 0.0; void setup() { size(200,200); smooth(); } void draw() { background(255); // Get the result of the sine function // Scale so that values oscillate between 0 and width float x = (sin(theta) + 1) * width/2; // With each cycle, increment theta theta += 0.05; // Draw the ellipse at the value produced by sine fill(0); stroke(0); line(width/2,0,x,height/2); ellipse(x,height/2,16,16);

ﬁg. 13.12

The output of the sin() function oscillates smoothly between 1 and 1. By adding 1 we get values between 0 and 2. By multiplying by 100, we get values between 0 and 200 which can be used as the ellipse’s x location.

}

Exercise 13-6: Encapsulate the above functionality into an Oscillator object. Create an array of Oscillators, each moving at diﬀerent rates along the x and y axes. Here is some code for the Oscillator class to help you get started. class Oscillator { float xtheta; float ytheta; ___________________________________________ Oscillator() { xtheta = 0; ytheta = 0; __________________________________________ } void oscillate() { __________________________________________ __________________________________________ } void display() { float x = ____________________________________________ float y = ____________________________________________ ellipse(x,y,16,16); } }

216

Learning Processing

Exercise 13-7: Use the sine function to create a “breathing” shape, that is, one whose size oscillates.

We can also produce some interesting results by drawing a sequence of shapes along the path of the sine function. See Example 13–7. Example 13-7: Wave // Starting angle float theta = 0.0; void setup() { size(200,200); smooth(); } void draw() { background(255);

ﬁg. 13.13 // Increment theta (try different values for "angular velocity" here) theta += 0.02; noStroke(); fill(0);

float x = theta; // A simple way to draw the wave with an ellipse at each location for (int i = 0; i 2) { radius *= 0.75f; drawCircle(x, y, radius); } }

ﬁg. 13.16

What does drawCircle( ) do? It draws an ellipse based on a set of parameters received as arguments, and then calls itself with the same parameters (adjusting them slightly). The result is a series of circles each drawn inside the previous circle. Notice that the above function only recursively calls itself if the radius is greater than two. This is a crucial point. All recursive functions must have an exit condition! This is identical to iteration. In Chapter 6, we learned that all for and while loops must include a boolean test that eventually evaluates to false, thus exiting the loop. Without one, the program would crash, caught inside an inﬁnite loop. The same can be

Mathematics

219

said about recursion. If a recursive function calls itself forever and ever, you will most likely be treated to a nice frozen screen. The preceding circles example is rather trivial, since it could easily be achieved through simple iteration. However, in more complex scenarios where a method calls itself more than once, recursion becomes wonderfully elegant. Let’s revise drawCircle( ) to be a bit more complex. For every circle displayed, draw a circle half its size to the left and right of that circle. See Example 13–8.

Example 13-8: Recursion void setup() { size(200,200); smooth(); } void draw() { background(255); stroke(0); noFill(); drawCircle(width/2,height/2,100); }

ﬁg. 13.17

void drawCircle(float x, float y, float radius) { ellipse(x, y, radius, radius); if(radius > 2) { drawCircle(x + radius/2, y, radius/2); drawCircle(x – radius/2, y, radius/2); drawCircle() calls itself twice, creating a } branching effect. For every circle, a smaller }

circle is drawn to the left and right.

With a teeny bit more code, we could add a circle above and below. This result is shown in Figure 13.18.

void drawCircle(float x, float y, float radius) { ellipse(x, y, radius, radius); if(radius > 8) { drawCircle(x + radius/2, y, radius/2); drawCircle(x – radius/2, y, radius/2); drawCircle(x, y + radius/2, radius/2); drawCircle(x, y – radius/2, radius/2); } }

Just try recreating this sketch with iteration instead of recursion! I dare you!

ﬁg. 13.18

220

Learning Processing

Exercise 13-9: Complete the code which generates the following pattern (Note: the solution uses lines, although it would also be possible to create the image using rotated rectangles, which we will learn how to do in Chapter 14).

void setup() { size(400,200); } void draw() { background(255); stroke(0); branch(width/2,height,100); } void branch(float x, float y, float h) { ________________________________________; ________________________________________; if (__________________) { ________________________________________; ________________________________________; } }

13.11 Two-Dimensional Arrays In Chapter 9, we learned that an array keeps track of multiple pieces of information in linear order, a one-dimensional list. However, the data associated with certain systems (a digital image, a board game, etc.) lives in two dimensions. To visualize this data, we need a multi-dimensional data structure, that is, a multi-dimensional array.

Mathematics

221

A two-dimensional array is really nothing more than an array of arrays (a three-dimensional array is an array of arrays of arrays). Think of your dinner. You could have a one-dimensional list of everything you eat: (lettuce, tomatoes, salad dressing, steak, mashed potatoes, string beans, cake, ice cream, coﬀee) Or you could have a two-dimensional list of three courses, each containing three things you eat: (lettuce, tomatoes, salad dressing) and (steak, mashed potatoes, string beans) and (cake, ice cream, coﬀee) In the case of an array, our old-fashioned one-dimensional array looks like this: int[] myArray = {0,1,2,3};

And a two-dimensional array looks like this: int[][] myArray = {{0,1,2,3},{3,2,1,0},{3,5,6,1},{3,8,3,4}};

For our purposes, it is better to think of the two-dimensional array as a matrix. A matrix can be thought of as a grid of numbers, arranged in rows and columns, kind of like a bingo board. We might write the two-dimensional array out as follows to illustrate this point: int[][] myArray = { {0, {3, {3, {3,

1, 2, 5, 8,

2, 1, 6, 3,

3}, 0}, 1}, 4} };

We can use this type of data structure to encode information about an image. For example, the grayscale image in Figure 13.19 could be represented by the following array: int[][] myArray = { {236, 189, 189, 0}, {236, 80, 189, 189}, {236, 0, 189, 80}, {236, 189, 189, 80} };

ﬁg. 13.19

To walk through every element of a one-dimensional array, we use a for loop, that is: int[] myArray = new int[10]; for (int i = 0; i < myArray.length; i++) { myArray[i] = 0; }

For a two-dimensional array, in order to reference every element, we must use two nested loops. This gives us a counter variable for every column and every row in the matrix. See Figure 13.20. int cols = 10; int rows = 10; int[][] myArray = new int[cols][rows];

222

Learning Processing columns 0 1 2 3 4 5 6 7 8 9

ni for every colum & for every row j

0 1 2 3 4 rows 5 6 7 8 9 ﬁg. 13.20

for (int i = 0; i < cols; i++) { for (int j = 0; j < rows; j++) { myArray[i][j] = 0; } }

Two nested loops allow us to visit every spot in a two-dimensional array. For every column i, visit every row j.

For example, we might write a program using a two-dimensional array to draw a grayscale image as in Example 13–9.

Example 13-9: Two-dimensional array // Set up dimensions size(200,200); int cols = width; int rows = height; // Declare 2D array int[][] myArray = new int[cols][rows]; // Initialize 2D array values for (int i = 0; i < cols; i++) { for (int j = 0; j < rows; j++) { myArray[i][j] = int(random(255)); } }

ﬁg. 13.21

// Draw points for (int i = 0; i < cols; i++) { for (int j = 0; j < rows; j++) { stroke(myArray[i][j]); point(i,j); } }

A two-dimensional array can also be used to store objects, which is especially convenient for programming sketches that involve some sort of “grid” or “ board.” Example 13-10 displays a grid of Cell objects stored in a two-dimensional array. Each cell is a rectangle whose brightness oscillates from 0–255 with a sine function.

Mathematics

223

Example 13-10: Two-dimensional array of objects

// 2D Array of objects Cell[][] grid;

A two-dimensional array can be used to store objects.

// Number of columns and rows in the grid int cols = 10; int rows = 10; void setup() { size(200,200); grid = new Cell[cols][rows]; for (int i = 0; i < cols; i++) { for (int j = 0; j < rows; j++) { // Initialize each object grid[i][j] = new Cell(i*20,j*20,20,20,i+j); } } } void draw() { background(0); for (int i = 0; i < cols; i++) { for (int j = 0; j < rows; j++) { // Oscillate and display each object grid[i][j].oscillate(); grid[i][j].display(); } } } // A Cell object class Cell { float x,y; // x,y location float w,h; // width and height float angle; // angle for oscillating brightness

ﬁg. 13.22

The counter variables i and j are also the column and row numbers, and are used as arguments to the constructor for each object in the grid.

A cell object knows about its location in the grid as well as its size with the variables x, y, w, h.

// Cell Constructor Cell(float tempX, float tempY, float tempW, float tempH, float tempAngle) { x = tempX; y = tempY; w = tempW; h = tempH; angle = tempAngle; } // Oscillation means increase angle void oscillate() { angle += 0.02; } void display() { stroke(255); // Color calculated using sine wave fill(127+127*sin(angle)); rect(x,y,w,h); } }

224

Learning Processing

Exercise 13-10: Develop the beginnings of a Tic-Tac-Toe game. Create a Cell object that can exist in one of two states: O or nothing. When you click on the cell, its state changes from nothing to “O”. Here is a framework to get you started. Cell[][] board; int cols = 3; int rows = 3; void setup() { // FILL IN } void draw() { background(0); for (int i = 0; i < cols; i++) { for (int j = 0; j < rows; j++) { board[i][j].display(); } } } void mousePressed() { // FILL IN } // A Cell object class Cell { float x,y; float w,h; int state; // Cell Constructor Cell(float tempX, float tempY, float tempW, float tempH) { // FILL IN } void click(int mx, int my) { // FILL IN }

Mathematics

void display() { // FILL IN } }

Exercise 13-11: If you are feeling saucy, go ahead and complete the Tic-Tac-Toe game adding X and alternating player turns with mouse clicks.

225

This page intentionally left blank

Translation and Rotation (in 3D!)

227

14 Translation and Rotation (in 3D!) “ What is the Matrix?” —Neo

In this chapter: – 2D and 3D translation. – Using P3D and OPENGL. – Vertex shapes. – 2D and 3D rotation. – Saving the transformation state in the stack: pushMatrix() and popMatrix().

14.1 The Z-Axis As we have seen throughout this book, pixels in a two-dimensional window are described using Cartesian coordinates: an X (horizontal) and a Y (vertical) point. This concept dates all the way back to Chapter 1, when we began thinking of the screen as a digital piece of graph paper. In three-dimensional space (such as the actual, real-world space where you are reading this book), a third axis (commonly referred to as the Z-axis) refers to the depth of any given point. In a Processing sketch’s window, a coordinate along this Z-axis indicates how far in front or behind the window a pixel lives. Scratching your head is a perfectly reasonable response here. After all, a computer window is only two dimensional. There are no pixels ﬂoating in the air in front of or behind your LCD monitor! In this chapter, we will examine how using the theoretical Z-axis will create the illusion of three-dimensional space in your Processing window. We can, in fact, create a three-dimensional illusion with what we have learned so far. For example, if you were to draw a rectangle in the middle of the window and slowly increase its width and height, it might appear as if it is moving toward you. See Example 14-1. Example 14-1: A growing rectangle, or a rectangle moving toward you? float r = 8; void setup() { size(200,200); } void draw() { background(255); // Display a rectangle in the middle of the screen stroke(0); fill(175); rectMode(CENTER); rect(width/2,height/2,r,r); // Increase the rectangle size r++; }

ﬁg. 14.1

228

Learning Processing

Is this rectangle ﬂying oﬀ of the computer screen about to bump into your nose? Technically, this is of course not the case. It is simply a rectangle growing in size. But we have created the illusion of the rectangle moving toward you. Fortunately for us, if we choose to use 3D coordinates, Processing will create the illusion for us. While the idea of a third dimension on a ﬂat computer monitor may seem imaginary, it is quite real for Processing. Processing knows about perspective, and selects the appropriate two-dimensional pixels in order to create the three-dimensional eﬀect. We should recognize, however, that as soon as we enter the world of 3D pixel coordinates, a certain amount of control must be relinquished to the Processing renderer. You can no longer control exact pixel locations as you might with 2D shapes, because XY locations will be adjusted to account for 3D perspective. In order to specify points in three dimensions, the coordinates are speciﬁed in the order you would expect: x, y, z. Cartesian 3D systems can be described as “ left-handed” or “right-handed.” If you use your right hand to point your index ﬁnger in the positive y direction (up) and your thumb in the positive x direction (to the right), the rest of your ﬁngers will point toward the positive z direction. It is left-handed if you use your left hand and do the same. In Processing, the system is left-handed, as shown in Figure 14.2. –Z

(0,0)

+Y ﬁg. 14.2

+X

(0,0)

+X

+Y

Our ﬁrst goal is to rewrite Example 14-1 using the 3D capabilities of Processing. Assume the following variables: int int int int

x y z r

= = = =

width/2; height/2; 0; 10;

In order to specify the location for a rectangle, the rect( ) function takes four arguments: an x location, a y location, a width, and a height. rect(x,y,w,h);

Translation and Rotation (in 3D!)

229

Our ﬁrst instinct might be to add another argument to the rect( ) function.

rect(x,y,z,w,h);

Incorrect! We cannot use an (x,y,z) coordinate in Processing’s shape functions such as rect(), ellipse(), line(), and so on. Other functions in Processing can take three arguments for x,y,z and we will see this later in the chapter.

The Processing reference page for rect( ), however, does not allow for this possibility. In order to specify 3D coordinates for shapes in the Processing world, we must learn to use a new function, called translate( ). The translate( ) function is not exclusive to 3D sketches, so let’s return to two dimensions to see how it works. The function translate( ) moves the origin point—(0,0)—relative to its previous state. We know that when a sketch ﬁrst starts, the origin point lives on the top left of the window. If we were to call the function translate( ) with the arguments (50,50), the result would be as shown in Figure 14.3.

Where is the origin? The “origin” in a Processing sketch is the point (0,0) in two dimensions or (0,0,0) in three dimensions. It is always at the top left corner of the window unless you move it using translate( ).

(0,0)

(50,50)

(-50,-50) (0,0) (50,50)

⇒ translate (50,50)⇒ (100,100) Before

After

ﬁg. 14.3

You can think of it as moving a pen around the screen, where the pen indicates the origin point. In addition, the origin always resets itself back to the top left corner at the beginning of draw( ). Any calls to translate( ) only apply to the current cycle through the draw( ) loop. See Example 14-2.

230

Learning Processing Example 14-2: Multiple translations void setup() { size(200,200); smooth(); } void draw() { background(255); stroke(0); fill(175); // Grab mouse coordinates, constrained to window int mx = constrain(mouseX,0,width); int my = constrain(mouseY,0,height);

ﬁg. 14.4

// Translate to the mouse location translate(mx,my); ellipse(0,0,8,8); // Translate 100 pixels to the right translate(100,0); ellipse(0,0,8,8); // Translate 100 pixels down translate(0,100); ellipse(0,0,8,8); // Translate 100 pixels left translate(–100,0); ellipse(0,0,8,8); }

Now that we understand how translate( ) works, we can return to the original problem of specifying 3D coordinates. translate( ), unlike rect( ), ellipse( ), and other shape functions, can accept a third argument for a Z coordinate. // Translation along the z-axis translate(0,0,50); rectMode(CENTER); rect(100,100,8,8);

The above code translates 50 units along the Z-axis, and then draws a rectangle at (100,100). While the above is technically correct, when using translate( ), it is a good habit to specify the (x,y) location as part of the translation, that is: // Translation along the z-axis II translate(100,100,50); rectMode(CENTER); rect(0,0,8,8); When using translate(), the rectangle’s location

is (0,0) since translate() moved us to the location for the rectangle.

Finally, we can use a variable for the Z location and animate the shape moving toward us.

Translation and Rotation (in 3D!)

231

Example 14-3: A rectangle moving along the z-axis float z = 0; // a variable for the Z (depth) coordinate void setup() { size(200,200,P3D); } void draw() { background(0); stroke(255); fill(100);

When using (x,y,z) coordinates, we must tell Processing we want a 3D sketch. This is done by adding a third argument “P3D” to the size() function. See Section 14.2 for more details.

// Translate to a point before displaying a shape there translate(width/2,height/2,z); rectMode(CENTER); rect(0,0,8,8); z++; // Increment Z (i.e. move the shape toward the viewer) }

Although the result does not look diﬀerent from Example 14-1, it is quite diﬀerent conceptually as we have opened the door to creating a variety of three-dimensional eﬀects on the screen with Processing’s 3D engine.

Exercise 14-1: Fill in the appropriate translate( ) functions to create this pattern. Once you are ﬁnished, try adding a third argument to translate( ) to move the pattern into three dimensions. size(200,200); background(0); stroke(255); fill(255,100); translate(_______,_______); rect(0,0,100,100); translate(_______,_______); rect(0,0,100,100); translate(_______,_______); line(0,0,-50,50);

The translate( ) function is particularly useful when you are drawing a collection of shapes relative to a given centerpoint. Harking back to a Zoog from the ﬁrst 10 chapters of this book, we saw code like this: void display() { // Draw Zoog's body fill(150); rect(x,y,w/6,h*2); // Draw Zoog's head fill(255); ellipse(x,y-h/2,w,h); }

232

Learning Processing

The display( ) function above draws all of Zoog’s parts (body and head, etc.) relative to Zoog’s x,y location. It requires that x and y be used in both rect( ) and ellipse( ). translate( ) allows us to simply set Processing’s origin (0,0) at Zoog’s (x,y) location and therefore draw the shapes relative to (0,0). void display() { // Move origin (0,0) to (x,y) translate(x,y); // Draw Zoog's body fill(150); rect(0,0,w/6,h*2);

translate() can be used to draw a collection of shapes relative to a given point.

// Draw Zoog's head fill(255); ellipse(0,-h/2,w,h); }

14.2 P3D vs. OPENGL If you look closely at Example 14-3, you will notice that we have added a third argument to the size( ) function. Traditionally, size( ) has served one purpose: to specify the width and height of our Processing window. The size( ) function, however, also accepts a third parameter indicating a drawing mode. The mode tells Processing what to do behind the scenes when rendering the display window. The default mode (when none is speciﬁed) is “JAVA2D,” which employs existing Java 2D libraries to draw shapes, set colors, and so on. We do not have to worry about how this works. The creators of Processing took care of the details. If we want to employ 3D translation (or rotation as we will see later in this chapter), the JAVA2D mode will no longer suﬃce. Running the example in the default mode results in the following error: “translate(x, y, z) can only be used with OPENGL or P3D, use translate(x, y) instead.” Instead of switching to translate(x,y), we want to select a diﬀerent mode. There are two options: • P3D—P3D is a 3D renderer developed by the creators of Processing. It should also be noted that anti-aliasing (enabled with the smooth( ) function) is not available with P3D. • OPENGL—OPENGL is a 3D renderer that employs hardware acceleration. If you have an OpenGL compatible graphics card installed on your computer (which is pretty much every computer), you can use this mode. Although at the time of the writing of this book, there are still a few, minor kinks to be worked out with this mode (you may find things look slightly different between P3D and OPENGL), it may prove exceptionally useful in terms of speed. If you are planning to display large numbers of shapes onscreen in a high-resolution window, this mode will likely have the best performance. To specify a mode, add a third argument in all caps to the size( ) function. size(200,200);

// using the default JAVA2D mode

size(200,200,P3D);

// using P3D

size(200,200,OPENGL); // using OPENGL

Translation and Rotation (in 3D!)

233

When using the OPENGL mode, you must also import the OPENGL library. This can be done by selecting the SKETCH ➝ IMPORT LIBRARY menu option or by manually adding the following line of code to the top of your sketch (see Chapter 12 for a detailed explanation on libraries): import processing.opengl.*;

Exercise 14-2: Run any Processing sketch in P3D, then switch to OPENGL. Notice any diﬀerence?

14.3 Vertex Shapes Up until now, our ability to draw to the screen has been limited to a small list of primitive twodimensional shapes: rectangles, ellipses, triangles, lines, and points. For some projects, however, creating your own custom shapes is desirable. This can be done through the use of the functions beginShape( ), endShape( ), and vertex( ). Consider a rectangle. A rectangle in Processing is deﬁned as a reference point, as well as a width and height. rect(50,50,100,100);

But we could also consider a rectangle to be a polygon (a closed shape bounded by line segments) made up of four points. The points of a polygon are called vertices (plural) or vertex (singular). The following code draws exactly the same shape as the rect( ) function by setting the vertices of the rectangle individually. See Figure 14.5. beginShape(); vertex(50,50); vertex(150,50); vertex(150,150); vertex(50,150); endShape(CLOSE); ﬁg. 14.5 beginShape( ) indicates that we are going to create a custom shape made up of some number of vertex points: a single polygon. vertex( ) speciﬁes the points for each vertex in the polygon and endShape( ) indicates that we are ﬁnished adding vertices. The argument “CLOSE” inside of endShape(CLOSE) declares that the shape should be closed, that is, that the last vertex point should connect to the ﬁrst.

The nice thing about using a custom shape over a simple rectangle is ﬂexibility. For example, the sides are not required to be perpendicular. See Figure 14.6. stroke(0); fill(175); beginShape(); vertex(50,50); vertex(150,25); vertex(150,175); vertex(25,150); endShape(CLOSE);

ﬁg. 14.6

234

Learning Processing

We also have the option of creating more than one shape, for example, in a loop, as shown in Figure 14.7. stroke(0); for (int i = 0; i < 10; i++) { beginShape(); fill(175); vertex(i*20,10-i); vertex(i*20+15,10+i); vertex(i*20+15,180+i); vertex(i*20,180-i); endShape(CLOSE); }

ﬁg. 14.7

You can also add an argument to beginShape( ) specifying exactly what type of shape you want to make. This is particularly useful if you want to make more than one polygon. For example, if you create six vertex points, there is no way for Processing to know that you really want to draw two triangles (as opposed to one hexagon) unless you say beginShape(TRIANGLES). If you do not want to make a polygon at all, but want to draw points or lines, you can by saying beginShape(POINTS) or beginShape(LINES). See Figure 14.8. stroke(0); beginShape(LINES); for (int i = 10; i < width; i+=20) { vertex(i,10); vertex(i,height–10); } endShape();

ﬁg. 14.8

Note that LINES is meant for drawing a series of individual lines, not a continous loop. For a continuous loop, do not use any argument. Instead, simply specify all the vertex points you need and include noFill( ). See Figure 14.9. noFill(); stroke(0); beginShape(); for (int i = 10; i < width; i+=20) { vertex(i,10); vertex(i,height–10); } endShape(); ﬁg. 14.9

The full list of possible arguments for beginShape( ) is available in the Processing reference http://processing.org/reference/beginShape_.html POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, QUAD_STRIP

Translation and Rotation (in 3D!)

235

In addition, vertex( ) can be replaced with curveVertex( ) to join the points with curves instead of straight lines. With curveVertex( ), note how the ﬁrst and last points are not displayed. This is because they are required to deﬁne the curvature of the line as it begins at the second point and ends at the second to last point. See Figure 14.10. noFill(); stroke(0); beginShape(); for (int i = 10; i < width; i+=20) { curveVertex(i,10); curveVertex(i,height-10); } endShape();

ﬁg. 14.10

Exercise 14-3: Complete the vertices for the shape pictured. size(200,200); background(255); stroke(0); fill(175); beginShape(); vertex(20, 20); vertex(_______,_______); vertex(_______,_______); vertex(_______,_______); vertex(_______,_______); endShape(_______);

14.4 Custom 3D Shapes Three-dimensional shapes can be created using beginShape( ), endShape( ), and vertex( ) by placing multiple polygons side by side in the proper conﬁguration. Let’s say we want to draw a four-sided pyramid made up of four triangles, all connected to one point (the apex) and a ﬂat plane (the base). If your shape is simple enough, you might be able to get by with just writing out the code. In most cases, however, it is best to start sketching it out with pencil and paper to determine the location of all the vertices. One example for our pyramid is shown in Figure 14.11. Example 14-4 takes the vertices from Figure 14.11 and puts them in a function that allows us to draw the pyramid with any size. (As an exercise, try making the pyramid into an object.)

236

Learning Processing (10,10,10)

(10,10,10)

x

(0,0,10)

y

(10,10,10)

(10,10,10) BASE at z = 10

vertex(–10,–10,–10); vertex( 10,–10,–10); vertex( 0, 0, 10); ﬁg. 14.11

vertex(10,–10,–10); vertex(10, 10,–10); vertex( 0, 0, 10);

Connected to

APEX at z = 10

vertex( 10,10,–10); vertex(–10,10,–10); vertex( 0, 0, 10);

vertex(–10, 10,–10); vertex(–10,–10,–10); vertex( 0, 0, 10);

Example 14-4: Pyramid using beginShape(TRIANGLES)

void setup() { size(200,200,P3D); } void draw() { background(255); translate(100,100,0); drawPyramid(150); } void drawPyramid(int t) { stroke(0);

Since the pyramid’s vertices are drawn relative to a centerpoint, we must call translate() to place the pyramid properly in the window.

The function sets the vertices for the pyramid around the centerpoint at a ﬂexible distance, depending on the number passed in as an argument.

// this pyramid has 4 sides, each drawn as a separate triangle // each side has 3 vertices, making up a triangle shape // the parameter "t" determines the size of the pyramid beginShape(TRIANGLES); fill(255,150); vertex(–t,–t,–t); vertex( t,-t,–t); vertex( 0, 0, t);

Note that each polygon can have its own color.

fill(150,150); vertex( t,–t,–t); vertex( t, t,–t); vertex( 0, 0, t); fill(255,150); vertex( t, t,–t); vertex(–t, t,–t); vertex( 0, 0, t);

ﬁg. 14.12

Translation and Rotation (in 3D!)

237

fill(150,150); vertex(–t, t,–t); vertex(–t,–t,–t); vertex( 0, 0, t); endShape(); }

Exercise 14-4: Create a pyramid with only three sides. Include the base (for a total of four triangles). Use the space below to sketch out the vertex locations as in Figure 14.11.

Exercise 14-5: Create a three-dimensional cube using eight quads—beginShape(QUADS). (Note that a simpler way to make a cube in Processing is with the box( ) function.)

14.5 Simple Rotation There is nothing particularly three dimensional about the visual result of the pyramid example. The image looks more like a ﬂat rectangle with two lines connected diagonally from end to end. Again, we have to remind ourselves that we are only creating a three-dimensional illusion, and it is not a particularly eﬀective one without animating the pyramid structure within the virtual space. One way for us to demonstrate the diﬀerence would be to rotate the pyramid. So let’s learn about rotation. For us, in our physical world, rotation is a pretty simple and intuitive concept. Grab a baton, twirl it, and you have a sense of what it means to rotate an object. Programming rotation, unfortunately, is not so simple. All sorts of questions come up. Around what axis should you rotate? At what angle? Around what origin point? Processing oﬀers several functions related to rotation, which we will explore slowly, step by step. Our goal will be to program a solar system simulation with multiple planets rotating around a star at diﬀerent rates (as well as to rotate our pyramid in order to better experience its three dimensionality). But ﬁrst, let’s try something simple and attempt to rotate one rectangle around its center. We should be able to get rotation going with the following three principles: 1. 2. 3.

Shapes are rotated in Processing with the rotate( ) function. The rotate( ) function takes one argument, an angle measured in radians. rotate( ) will rotate the shape in the clockwise direction (to the right).

238

Learning Processing

OK, armed with this knowledge, we should be able to just call the rotate( ) function and pass in an angle. Say, 45° (or PI/4 radians) in Processing. Here is our ﬁrst (albeit ﬂawed) attempt, with the output shown in Figure 14.13. rotate(radians(45)); rectMode(CENTER); rect(width/2,height/2,100,100);

Shoot. What went wrong? The rectangle looks rotated, but it is in the wrong place! ﬁg. 14.13

The single most important fact to remember about rotation in Processing is that shapes always rotate around the point of origin. Where is the point of origin in this example? The top left corner! The origin has not been translated. The rectangle therefore will not spin around its own center. Instead, it rotates around the top left corner. See Figure 14.14.

origin 45 ° rotation from origin

rectangle rotating around top left origin ﬁg. 14.14

Sure, there may come a day when all you want to do is rotate shapes around the top left corner, but until that day comes, you will always need to ﬁrst move the origin to the proper location before rotating, and then display the rectangle. translate( ) to the rescue! translate(width/2,height/2); rotate(radians(45)); rectMode(CENTER); rect(0,0,100,100);

Because we translated in order to rotate, the rectangle now lives at the point (0,0).

We can expand the above code using the mouseX location to calculate an angle of rotation and thus animate the rectangle, allowing it to spin. See Example 14-5.

Translation and Rotation (in 3D!)

239

Example 14-5: Rectangle rotating around center void setup() { size(200,200); } void draw() { background(255); stroke(0); fill(175); // Translate origin to center translate(width/2,height/2);

ﬁg. 14.15

// theta is a common name of a variable to store an angle float theta = PI*mouseX / width; // Rotate by the angle theta rotate(theta);

The angle ranges from 0 to PI, based on the ratio of mouseX location to the sketch’s width.

// Display rectangle with CENTER mode rectMode(CENTER); rect(0,0,100,100); }

Exercise 14-6: Create a line that spins around its center (like twirling a baton). Draw a circle at both endpoints.

14.6 Rotation Around Different Axes Processing window

Now that we have basic rotation out of the way, we can begin to ask the next important rotation question: Around what axis do we want to rotate? In the previous section, our square rotated around the Z-axis. This is the default axis for two-dimensional rotation. See Figure 14.16.

Z-axis

ﬁg. 14.16

240

Learning Processing

Processing will also allow for rotation around the x or y-axis with the functions rotateX( ) and rotateY( ), which each require P3D or OPENGL mode. The function rotateZ( ) also exists and is the equivalent of rotate( ). See Examples 14-6, 14-7 and 14-8.

ﬁg. 14.17

ﬁg. 14.18

ﬁg. 14.19

Example 14-6: rotateZ

Example 14-7: rotateX

Example 14-8: rotateY

float theta = 0.0;

float theta = 0.0;

float theta = 0.0;

void setup() { size(200,200,P3D); }

void setup() { size(200,200,P3D); }

}

void draw() { background(255); stroke(0); fill(175);

void draw() { background(255); stroke(0); fill(175);

void draw() { background(255); stroke(0); fill(175);

translate(width/2, height/2); rotateZ(theta); rectMode(CENTER); rect(0,0,100,100);

translate(width/2, height/2); rotateX(theta); rectMode(CENTER); rect(0,0,100,100);

theta += 0.02; }

void setup() { size(200,200,P3D);

translate(width/2, height/2); rotateY(theta); rectMode(CENTER); rect(0,0,100,100);

theta += 0.02; }

theta += 0.02; }

The rotate functions can also be used in combination. The results of Example 14-9 are shown in Figure 14.20. Example 14-9: Rotate around more than one axis void setup() { size(200,200,P3D); } void draw() { background(255); stroke(0); fill(175); translate(width/2,height/2); rotateX(PI*mouseY/height); rotateY(PI*mouseX/width); rectMode(CENTER); rect(0,0,100,100); }

ﬁg. 14.20

Translation and Rotation (in 3D!)

Returning to the pyramid example, we will see how rotating makes the three-dimensional quality of the shape more apparent. The example is also expanded to include a second pyramid that is oﬀset from the ﬁrst pyramid using translate. Note, however, that it rotates around the same origin point as the ﬁrst pyramid (since rotateX( ) and rotateY( ) are called before the second translate( ) ).

Example 14-10: Pyramid float theta = 0.0; void setup() { size(200,200,P3D); } void draw() { background(144); theta += 0.01; translate(100,100,0); rotateX(theta); rotateY(theta); drawPyramid(50);

ﬁg. 14.21

// translate the scene again translate(50,50,20); // call the pyramid drawing function drawPyramid(10); } void drawPyramid(int t) { stroke(0); // this pyramid has 4 sides, each drawn as a separate triangle // each side has 3 vertices, making up a triangle shape // the parameter "t" determines the size of the pyramid fill(150,0,0,127); beginShape(TRIANGLES); vertex(–t,–t,–t); vertex( t,–t,–t); vertex( 0, 0, t); fill(0,150,0,127); vertex( t,–t,–t); vertex( t, t,–t); vertex( 0, 0, t); fill(0,0,150,127); vertex( t, t,–t); vertex(–t, t,–t); vertex( 0, 0, t); fill(150,0,150,127); vertex(–t, t,–t); vertex(–t,–t,–t); vertex( 0, 0, t); endShape(); }

241

242

Learning Processing

Exercise 14-7: Rotate the 3D cube you made in Exercise 14-5. Can you rotate it around the corner or center? You can also use the Processing function box( ) to make the cube. Exercise 14-8: Make a Pyramid class.

14.7 Scale In addition to translate( ) and rotate( ), there is one more function, scale( ), that aﬀects the way shapes are oriented and drawn onscreen. scale( ) increases or decreases the size of objects onscreen. Just as with rotate( ), the scaling eﬀect is performed relative to the origin’s location. scale( ) takes a ﬂoating point value, a percentage at which to scale: 1.0 is 100%. For example, scale(0.5) draws an object at 50% of its size and scale(3.0) increases the object’s size to 300%. Following is a re-creation of Example 14-1 (the growing square) using scale( ). Example 14-11: A growing rectangle, using scale() float r = 0.0; void setup() { size(200,200); } void draw() { background(0); // Translate to center of window translate(width/2,height/2); // Scale any shapes according to value of r scale(r); // Display a rectangle in the middle of the screen stroke(255); fill(100); rectMode(CENTER); rect(0,0,10,10);

ﬁg. 14.22

scale() increases the dimensions of an object relative to the origin by a percentage (1.0  100%). Notice how in this example the scaling effect causes the outline of the shape to become thicker.

// Increase the scale variable r += 0.02; }

scale( ) can also take two arguments (for scaling along the x and y-axes with diﬀerent values) or three arguments (for the x-, y-, and z-axes).

14.8 The Matrix: Pushing and Popping What is the matrix? In order to keep track of rotations and translations and how to display the shapes according to diﬀerent transformations, Processing (and just about any computer graphics software) uses a matrix.

Translation and Rotation (in 3D!)

243

How matrix transformations work is beyond the scope of this book; however, it is useful to simply know that the information related to the coordinate system is stored in what is known as a transformation matrix. When a translation or rotation is applied, the transformation matrix changes. From time to time, it is useful to save the current state of the matrix to be restored later. This will ultimately allow us to move and rotate individual shapes without them aﬀecting others.

What is the matrix? A matrix is a table of numbers with rows and columns. In Processing, a transformation matrix is used to describe the window orientation—is it translated or rotated? You can view the current matrix at any time by calling the function printMatrix( ). This is what the matrix looks like in its “normal” state, with no calls to translate( ) or rotate( ). 1.0000 0.0000 0.0000 0.0000 1.0000 0.0000

This concept is best illustrated with an example. Let’s give ourselves an assignment: Create a Processing sketch where two rectangles rotate at diﬀerent speeds in diﬀerent directions around their respective centerpoints. As we start developing this example, we will see where the problems arise and how we will need to implement the functions pushMatrix( ) and popMatrix( ). Starting with essentially the same code from Section 14.4, we can rotate a square around the Z-axis in the top left corner of the window. See Example 14-12. Example 14-12: Rotating one square float theta1 = 0; void setup() { size(200,200,P3D); } void draw() { background (255); stroke(0); fill(175); rectMode(CENTER); translate(50,50); rotateZ(theta1); rect(0,0,60,60); theta1 += 0.02; }

ﬁg. 14.23

244

Learning Processing

Making some minor adjustments, we now implement a rotating square in the bottom right-hand corner. Example 14-13: Rotating another square float theta2 = 0; void setup() { size(200,200,P3D); } void draw() { background (255); stroke(0); fill(175); rectMode(CENTER);

ﬁg. 14.24

translate(150,150); rotateY(theta2); rect(0,0,60,60); theta2 += 0.02; }

Without careful consideration, we might think to simply combine the two programs. The setup( ) function would stay the same, we would incorporate two globals, theta1 and theta2, and call the appropriate translation and rotation for each rectangle. We would also adjust translation for the second square from translate(150,150) to translate(100,100), since we have already translated to (50,50) with the ﬁrst square.

float theta1 = 0; float theta2 = 0; void setup() { size(200,200,P3D); } void draw() { background(255); stroke(0); fill(175); rectMode(CENTER); translate(50,50); rotateZ(theta1); rect(0,0,60,60); theta1 += 0.02; translate(100,100); rotateY(theta2); rect(0,0,60,60); theta2 += 0.02; }

ﬁg. 14.25

This ﬁrst call to rotateZ() affects all shapes drawn afterward. Both squares rotate around the center of the ﬁrst square.

Translation and Rotation (in 3D!)

245

Running this example will quickly reveal a problem. The ﬁrst (top left) square rotates around its center . However, while the second square does rotate around its center, it also rotates around the ﬁrst square! Remember, all calls to translate and rotate are relative to the coordinate system’s previous state. We need a way to restore the matrix to its original state so that individual shapes can act independently. Saving and restoring the rotation/translation state is accomplished with the functions pushMatrix( ) and popMatrix( ). To get started, let’s think of them as saveMatrix( ) and restoreMatrix( ). (Note there are no such functions.) Push  save. Pop  restore. For each square to rotate on its own, we can write the following algorithm (with the new parts bolded). 1. 2. 3. 4. 5. 6.

Save the current transformation matrix. This is where we started, with (0,0) in the top left corner of the window and no rotation. Translate and rotate the ﬁrst rectangle. Display the ﬁrst rectangle. Restore matrix from Step 1 so that it isn’t aﬀected by Steps 2 and 3! Translate and rotate the second rectangle. Display the second rectangle.

Rewriting our code in Example 14-14 gives the correct result as shown in Figure 14.26.

Example 14-14: Rotating both squares float theta1 = 0; float theta2 = 0; void setup() { size(200,200,P3D); } void draw() { background(255); stroke(0); fill(175); rectMode(CENTER); pushMatrix();

1

translate(50,50); rotateZ(theta1);

2

rect(0,0,60,60);

3

popMatrix();

4

pushMatrix(); translate(150,150); rotateY(theta2);

5

rect(0,0,60,60); popMatrix();

6

theta1 += 0.02; theta2 += 0.02; }

ﬁg. 14.26

246

Learning Processing

Although technically not required, it is a good habit to place pushMatrix( ) and popMatrix( ) around the second rectangle as well (in case we were to add more to this code). A nice rule of thumb when starting is to use pushMatrix( ) and popMatrix( ) before and after translation and rotation for all shapes so that they can be treated as individual entities. In fact, this example should really be object oriented, with every object making its own calls to pushMatrix( ), translate( ), rotate( ), and popMatrix( ). See Example 14-5.

Example 14-15: Rotating many things using objects // An array of Rotater objects Rotater[] rotaters; void setup() { size(200,200); rotaters = new Rotater[20]; // Rotaters are made randomly for (int i = 0; i < rotaters.length; i++) { rotaters[i] = new Rotater(random(width),random(height),random(–0.1,0.1),random(48)); } } void draw() { background(255); // All Rotaters spin and are displayed for (int i = 0; i < rotaters.length; i++) { rotaters[i].spin(); rotaters[i].display(); } } // A Rotater class class Rotater { float x,y; // x,y location float theta; // angle of rotation float speed; // speed of rotation float w; // size of rectangle

ﬁg. 14.27

Rotater(float tempX, float tempY, float tempSpeed, float tempW) { x = tempX; y = tempY; theta = 0; // Angle is always initialized to 0 speed = tempSpeed; w = tempW; } // Increment angle void spin() { theta += speed; } // Display rectangle void display() { rectMode(CENTER); stroke(0);

Translation and Rotation (in 3D!)

247

fill(0,100); // Note the use of pushMatrix() // and popMatrix() inside the object's // display method! pushMatrix(); pushMatrix() and popMatrix() are called translate(x,y); inside the class’ display() method. This rotate(theta); way, every Rotater object is rendered rect(0,0,w,w); with its own independent translation popMatrix();

and rotation!

} }

Interesting results can also be produced from nesting multiple calls to pushMatrix( ) and popMatrix( ). There must always be an equal amount of calls to both pushMatrix( ) and popMatrix( ), but they do not always have to come one right after the other. To understand how this works, let’s take a closer look at the meaning of “push” and “pop.” “Push” and “pop” refer to a concept in computer science known as a stack. Knowledge of how a stack works will help you use pushMatrix( ) and popMatrix( ) properly. A stack is exactly that: a stack. Consider an English teacher getting settled in for a night of grading papers stored in a pile on a desk, a stack of papers. The teacher piles them up one by one and reads them in reverse order of the pile. The ﬁrst paper placed on the stack is the last one read. The last paper added is the ﬁrst one read. Note this is the exact opposite of a queue. If you are waiting in line to buy tickets to a movie, the ﬁrst person in line is the ﬁrst person to get to buy tickets, the last person is the last. See Figure 14.28.

First one out

First one in & out

Tick

ets

First one in INBOX STACK

QUEUE

ﬁg. 14.28

Pushing refers to the process of putting something in the stack, popping to taking something out. This is why you must always have an equal number of pushMatrix( ) and popMatrix( ) calls. You can’t pop something if it does not exist! (If you have an incorrect number of pushes and pops, Processing will say: “ Too many calls to popMatrix() (and not enough to pushMatrix).” Using the rotating squares program as a foundation, we can see how nesting pushMatrix( ) and popMatrix( ) is useful. The following sketch has one circle in the center (let’s call it the sun) with another circle rotating it (let’s call it earth) and another two rotating around it (let’s call them moon #1 and moon #2).

248

Learning Processing Example 14-16: Simple solar system // Angle of rotation around sun and planets float theta = 0; void setup() { size(200,200); smooth(); } void draw() { background(255); stroke(0);

ﬁg. 14.29

// Translate to center of window // to draw the sun. translate(width/2,height/2); fill(255,200,50); ellipse(0,0,20,20); // The earth rotates around the sun pushMatrix(); rotate(theta); translate(50,0); fill(50,200,255); ellipse(0,0,10,10); // Moon #1 rotates around the earth pushMatrix(); pushMatrix() is called to save the transformation rotate(–theta*4); state before drawing moon #1. This way we can translate(15,0); pop and return to earth before drawing moon #2. fill(50,255,200); Both moons rotate around the earth (which itself ellipse(0,0,6,6); is rotating around the sun). popMatrix(); // Moon #2 also rotates around the earth pushMatrix(); rotate(theta*2); translate(25,0); fill(50,255,200); ellipse(0,0,6,6); popMatrix(); popMatrix(); theta += 0.01; }

pushMatrix( ) and popMatrix( ) can also be nested inside for or while loops with rather unique and interesting results. The following example is a bit of a brainteaser, but I encourage you to play around with it.

Translation and Rotation (in 3D!)

249

Example 14-17: Nested push and pop // Global angle for rotation float theta = 0; void setup(){ size(200, 200); smooth(); } void draw(){ background(100); stroke(255); // Translate to center of window translate(width/2,height/2); // Loop from 0 to 360 degrees (2*PI radians) for(float i=0; i < TWO_PI; i+=0.2) { // Push, rotate and draw a line! pushMatrix(); rotate(theta+i); line(0,0,100,0); // Loop from 0 to 360 degrees (2*PI radians) for(float j=0; j < TWO_PI; j+=0.5) { // Push, translate, rotate and draw a line! pushMatrix(); translate(100,0); rotate(–theta–j); line(0,0,50,0); // We're done with the inside loop, pop! popMatrix(); } // We're done with the outside loop, pop! popMatrix(); } endShape();

ﬁg. 14.30

The transformation state is saved at the beginning of each cycle through the for loop and restored at the end. Try commenting out these lines to see the difference!

// Increment theta theta+=0.01; }

Exercise 14-9: Take either your pyramid or your cube shape and make it into a class. Have each object make its own call to pushMatrix( ) and popMatrix( ). Can you make an array of objects all rotating independently in 3D?

14.9 A Processing Solar System Using all the translation, rotation, pushing, and popping techniques in this chapter, we are ready to build a Processing solar system. This example will be an updated version of Example 14-16 in the previous section (without any moons), with two major changes: • Every planet will be an object, a member of a Planet class. • An array of planets will orbit the sun.

250

Learning Processing Example 14-18: Object-oriented solar system // An array of 8 planet objects Planet[] planets = new Planet[8]; void setup() { size(200,200); smooth(); // The planet objects are initialized using the counter variable for (int i = 0; i < planets.length; i++) { ﬁg. 14.31 planets[i] = new Planet(20+i*10,i+8); } } void draw() { background(255); // Drawing the Sun pushMatrix(); translate(width/2,height/2); stroke(0); fill(255); ellipse(0,0,20,20); // Drawing all Planets for (int i = 0; i < planets.length; i++) { planets[i].update(); planets[i].display(); } popMatrix(); } class Planet { float float float float

theta; diameter; distance; orbitspeed;

Planet(float distance = diameter = theta = 0; orbitspeed }

// // // //

Rotation around sun Size of planet Distance from sun Orbit speed

Each planet object keeps track of its own angle of rotation.

distance_, float diameter_) { distance_; diameter_; = random(0.01,0.03);

void update() { // Increment the angle to rotate theta += orbitspeed; } void display() {

Before rotation and translation, the state of the matrix is saved with pushMatrix().

pushMatrix(); rotate(theta); // rotate orbit translate(distance,0); // translate out distance

Translation and Rotation (in 3D!)

251

stroke(0); fill(175); ellipse(0,0,diameter,diameter); // Afer we are done, restore matrix! popMatrix(); } }

Once the planet is drawn, the matrix is restored with popMatrix() so that the next planet is not affected.

Exercise 14-10: How would you add moons to the planets? Hint: Write a Moon class that is virtually identical to the Planet. Then, incorporate a Moon variable into the Planet class. (In Chapter 22, we will see how this could be made more eﬃcient with advanced OOP techniques.)

Exercise 14-11: Extend the solar system example into three dimensions. Try using sphere( ) or box( ) instead of ellipse( ). Note sphere( ) takes one argument, the sphere’s radius. box( ) can take one argument (size, in the case of a cube) or three arguments (width, height, and depth.)

252

Learning Processing

Lesson Six Project Create a virtual ecosystem. Make a class for each “creature” in your world. Using the techniques from Chapters 13 and 14, attempt to infuse your creatures with personality. Some possibilities: • • • • •

Use Perlin noise to control the movements of creatures. Make the creatures look like they are breathing with oscillation. Design the creatures using recursion. Design the custom polygons using beginShape( ). Use rotation in the creatures’ behaviors.

Use the space provided below to sketch designs, notes, and pseudocode for your project.

Lesson Seven Pixels Under a Microscope

15 Images 16 Video

This page intentionally left blank

Images

255

15 Images “Politics will eventually be replaced by imagery. The politician will be only too happy to abdicate in favor of his image, because the image will be much more powerful than he could ever be.” —Marshall McLuhan “ When it comes to pixels, I think I’ve had my ﬁll. There are enough pixels in my ﬁngers and brains that I probably need a few decades to digest all of them.” —John Maeda

In this chapter: – The PImage class. – Displaying images. – Changing image color. – The pixels of an image. – Simple image processing. – Interactive image processing.

A digital image is nothing more than data—numbers indicating variations of red, green, and blue at a particular location on a grid of pixels. Most of the time, we view these pixels as miniature rectangles sandwiched together on a computer screen. With a little creative thinking and some lower level manipulation of pixels with code, however, we can display that information in a myriad of ways. This chapter is dedicated to breaking out of simple shape drawing in Processing and using images (and their pixels) as the building blocks of Processing graphics.

15.1 Getting Started with Images By now, we are quite comfortable with the idea of data types. We specify them often—a ﬂoat variable called speed, an int named x, perhaps even a char entitled letterGrade. These are all primitive data types, bits sitting in the computer’s memory ready for our use. Though perhaps a bit trickier, we are also beginning to feel at ease with objects, complex data types that store multiple pieces of data (along with functionality)—our Zoog class, for example, included ﬂoating point variables for location, size, and speed as well as methods to move, display itself, and so on. Zoog, of course, is a user-deﬁned class; we brought Zoog into this programming world, deﬁning what it means to be a Zoog, and deﬁning the data and functions associated with a Zoog object. In addition to user-deﬁned objects, Processing has a bunch of handy classes all ready to go without us writing any code. (Later, in Chapter 23, we will ﬁnd out that we also have access to a vast library of Java classes.) The ﬁrst Processing-deﬁned class we will examine is PImage, a class for loading and displaying an image such as the one shown in Figure 15.1.

ﬁg. 15.1

256

Learning Processing Example 15-1: “Hello World” images // Declaring a variable of type PImage PImage img;

Declaring a variable of type PImage, a class available to us from the Processing core library.

void setup() { size(320,240); // Make a new instance of a PImage by loading an image file img = loadImage("mysummervacation.jpg"); } void draw() { background(0); image(img,0,0); }

The image() function displays the image at a location—in this case the point (0,0).

Using an instance of a PImage object is no diﬀerent than using a user-deﬁned class. First, a variable of type PImage, named “img,” is declared. Second, a new instance of a PImage object is created via the loadImage( ) method. loadImage( ) takes one argument, a String (Strings are explored in greater detail in Chapter 17) indicating a ﬁle name, and loads the that ﬁle into memory. loadImage( ) looks for image ﬁles stored in your Processing sketch’s data folder.

The Data Folder: How do I get there? Images can be added to the data folder automatically via: Sketch → Add File… or manually: Sketch → Show Sketch Folder This will open up the sketch folder as shown in Figure 15.2. If there is no data directory, create one. Otherwise, place your image ﬁles inside. Processing accepts the following ﬁle formats for images: GIF, JPG, TGA, and PNG.

ﬁg. 15.2

In Example 15-1, it may seem a bit peculiar that we never called a “constructor” to instantiate the PImage object, saying “new PImage( )”. After all, in all the object-related examples to date, a constructor is a must for producing an object instance. Spaceship ss = new Spaceship(); Flower flr = new Flower(25);

Images

257

And yet: PImage img = loadImage("ﬁle.jpg");

In fact, the loadImage( ) function performs the work of a constructor, returning a brand new instance of a PImage object generated from the speciﬁed ﬁlename. We can think of it as the PImage constructor for loading images from a ﬁle. For creating a blank image, the createImage( ) function is used. // Create a blank image, 200X200 pixels with RGB color PImage img = createImage(200,200,RGB);

We should also note that the process of loading the image from the hard drive into memory is a slow one, and we should make sure our program only has to do it once, in setup( ). Loading images in draw( ) may result in slow performance, as well as “Out of Memory ” errors. Once the image is loaded, it is displayed with the image( ) function. The image( ) function must include three arguments—the image to be displayed, the x location, and the y location. Optionally, two arguments can be added to resize the image to a certain width and height. image(img,10,20,90,60);

Exercise 15-1: Load and display an image. Control the image’s width and height with the mouse.

15.2 Animation with an Image From here, it is easy to see how you can use images to further develop examples from previous chapters.

Example 15-2: Image “sprite” PImage head; // A variable for the image file float x,y; // Variables for image location float rot; // A variable for image rotation void setup() { size(200,200); // load image, initialize variables head = loadImage("face.jpg"); x = 0.0f; y = width/2.0f; rot = 0.0f; }

ﬁg. 15.3

void draw() { background(255); // Translate and rotate translate(x,y); rotate(rot); image(head,0,0); // Draw image

Images can be animated just like regular shapes using variables, translate(), rotate(), and so on.

258

Learning Processing // Adjust variables to create animation x += 1.0; rot += 0.01; if (x > width) { x = 0; } }

Exercise 15-2: Rewrite this example in an object-oriented fashion where the data for the image, location, size, rotation, and so on is contained in a class. Can you have the class swap images when it hits the edge of the screen? class Head ________ ________ ________

{ // Avariable for the image file // Variables for image location // A variable for image rotation

Head(String filename, ________, ________) { // Load image, initialize variables ________ = loadImage(________); __________________________________ __________________________________ __________________________________ } void display() { __________________________________ __________________________________ __________________________________ } void move() { __________________________________ __________________________________ __________________________________ __________________________________ __________________________________ __________________________________ } }

String is also a class we get for free and will be explored further in Chapter 17.

Images

259

15.3 My Very First Image Processing Filter Every now and then, when displaying an image, we choose to alter its appearance. Perhaps we would like the image to appear darker, transparent, bluish, and so on. This type of simple image ﬁltering is achieved with Processing’s tint( ) function. tint( ) is essentially the image equivalent of shape’s ﬁll( ), setting the color and alpha transparency for displaying an image on screen. An image, nevertheless, is not usually all one color. The arguments for tint( ) simply specify how much of a given color to use for every pixel of that image, as well as how transparent those pixels should appear. For the following examples, we will assume that two images (a sunﬂower and a dog) have been loaded and the dog is displayed as the background (which will allow us to demonstrate transparency). See Figure 15.4. For color versions of these images visit: http://www.learningprocessing.com) PImage sunﬂower = loadImage("sunﬂower.jpg"); PImage dog = loadImage("dog.jpg"); background(dog);

A

B

C

D

E

ﬁg. 15.4

If tint( ) receives one argument, only the brightness of the image is aﬀected. tint(255); image(sunflower,0,0);

A The image retains its original state.

tint(100); image(sunflower,0,0);

B The image appears darker.

A second argument will change the image’s alpha transparency. tint(255,127); image(sunflower,0,0);

C The image is at 50% opacity.

Three arguments aﬀect the brightness of the red, green, and blue components of each color. tint(0,200,255) image(sunflower,0,0);

D None of it is red, most of it is green, and all of it is blue.

Finally, adding a fourth argument to the method manipulates the alpha (same as with two arguments). Incidentally, the range of values for tint( ) can be speciﬁed with colorMode( ) (see Chapter 1). tint(255,0,0,100); image(sunflower,0,0);

E The image is tinted red and transparent.

260

Learning Processing

Exercise 15-3: Display an image using tint( ). Use the mouse location to control the amount of red, green, and blue tint. Also try using the distance of the mouse from the corners or center. Exercise 15-4: Using tint( ), create a montage of blended images. What happens when you layer a large number of images, each with diﬀerent alpha transparency, on top of each other? Can you make it interactive so that diﬀerent images fade in and out?

15.4 An Array of Images One image is nice, a good place to start. It will not be long, however, until the temptation of using many images takes over. Yes, we could keep track of multiple images with multiple variables, but here is a magniﬁcent opportunity to rediscover the power of the array. Let’s assume we have ﬁve images and want to display a new background image each time the user clicks the mouse. First, we set up an array of images, as a global variable. // Image Array PImage[] images = new PImage[5];

Second, we load each image ﬁle into the appropriate location in the array. This happens in setup( ). // Loading Images into an Array images[0] = loadImage("cat.jpg"); images[1] = loadImage("mouse.jpg"); images[2] = loadImage("dog.jpg"); images[3] = loadImage("kangaroo.jpg"); images[4] = loadImage("porcupine.jpg");

Of course, this is somewhat awkward. Loading each image individually is not terribly elegant. With ﬁve images, sure, it is manageable, but imagine writing the above code with 100 images. One solution is to store the ﬁlenames in a String array and use a for statement to initialize all the array elements. // Loading Images into an Array from an array of ﬁlenames String[] ﬁlenames = {"cat.jpg","mouse.jpg","dog.jpg","kangaroo.jpg","porcupine.jpg"); for (int i = 0; i < ﬁlenames.length; i++) { images[i] = loadImage(ﬁlenames[i]); }

Concatenation: A New Kind of Addition Usually, a plus sign () means, add. 2  2  4, right? With text (as stored in a String, enclosed in quotes),  means concatenate, that is, join two Strings together. “Happy”  “ Trails”  “Happy Trails” “2”  “2”  “22” See more about Strings in Chapter 17.

Images

261

Even better, if we just took a little time out of our hectic schedules to plan ahead, numbering the image ﬁles (“animal1.jpg”, “animal2.jpg”, “animal3.jpg”, etc.), we can really simplify the code: // Loading images with numbered ﬁles for (int i = 0; i < images.length; i++) { images[i] = loadImage("animal" + i + ".jpg"); }

Once the images are loaded, it’s on to draw( ). There, we choose to display one particular image, picking from the array by referencing an index (“0” below). image(images[0],0,0);

Of course, hard-coding the index value is foolish. We need a variable in order to dynamically display a diﬀerent image at any given moment in time. image(images[imageindex],0,0);

The “imageindex” variable should be declared as a global variable (of type integer). Its value can be changed throughout the course of the program. The full version is shown in Example 15-3. Example 15-3: Swapping images int maxImages = 10; // Total # of images int imageIndex = 0; // Initial image to be displayed is the ﬁrst PImage[] images = new PImage[maxImages]; // The image array void setup() { size(200,200); // Loading the images into the array // Don't forget to put the JPG ﬁles in the data folder! for (int i = 0; i < images.length; i++) { images[i] = loadImage("animal" + i + ".jpg"); } } void draw() { image(images[imageIndex],0,0); // Displaying one image } void mousePressed() { // A new image is picked randomly when the mouse is clicked // Note the index to the array must be an integer! imageIndex = int(random(images.length)); }

Declaring an array of images.

Loading an array of images.

Displaying one image from the array.

Picking a new image to display by changing the index variable!

To play the images in sequence as an animation, follow Example 15-4. Example 15-4: Image sequence void draw() { background(0); image(images[imageIndex],0,0); // increment image index by one each cycle // use modulo "%" to return to 0 once the size //of the array is reached imageIndex = (imageIndex + 1) % images.length; }

Remember modulus? The % sign? It allows us to cycle a counter back to 0. See Chapter 13 for a review.

262

Learning Processing

Exercise 15-5: Create multiple instances of an image sequence onscreen. Have them start at diﬀerent times within the sequence so that they are out of sync. Hint: Use object-oriented programming to place the image sequence in a class.

15.5 Pixels, Pixels, and More Pixels If you have been diligently reading this book in precisely the prescribed order, you will notice that so far, the only oﬀered means for drawing to the screen is through a function call. “Draw a line between these points” or “Fill an ellipse with red ” or “ load this JPG image and place it on the screen here.” But somewhere, somehow, someone had to write code that translates these function calls into setting the individual pixels on the screen to reﬂect the requested shape. A line does not appear because we say line( ), it appears because we color all the pixels along a linear path between two points. Fortunately, we do not have to manage this lower-level-pixel-setting on a day-to-day basis. We have the developers of Processing (and Java) to thank for the many drawing functions that take care of this business. Nevertheless, from time to time, we do want to break out of our mundane shape drawing existence and deal with the pixels on the screen directly. Processing provides this functionality via the pixels array. We are familiar with the idea of each pixel on the screen having an X and Y position in a twodimensional window. However, the array pixels has only one dimension, storing color values in linear sequence. See Figure 15.5.

0

1

2

3

4

5

6

7

8

9

10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

How the pixels look

How the pixels are stored.

0 1 2 34 567 8 9 . . . ﬁg. 15.5

Take the following example. This sketch sets each pixel in a window to a random grayscale value. The pixels array is just like an other array, the only diﬀerence is that we do not have to declare it since it is a Processing built-in variable.

Example 15-5: Setting pixels size(200,200); // Before we deal with pixels loadPixels(); // Loop through every pixel for (int i = 0; i < pixels.length; i++) { // Pick a random number, 0 to 255 float rand = random(255);

We can get the length of the pixels array just like with any array. ﬁg. 15.6

Images

263

// Create a grayscale color based on random number color c = color(rand); // Set pixel at that location to random color pixels[i] = c;

We can access individual elements of the pixels array via an index, just like with any other array.

} // When we are finished dealing with pixels updatePixels();

First, we should point out something important in the above example. Whenever you are accessing the pixels of a Processing window, you must alert Processing to this activity. This is accomplished with two functions: • loadPixels( )—This function is called before you access the pixel array, saying “ load the pixels, I would like to speak with them!” • updatePixels( )—This function is called after you finish with the pixel array, saying “Go ahead and update the pixels, I’m all done!” In Example 15-5, because the colors are set randomly, we did not have to worry about where the pixels are onscreen as we access them, since we are simply setting all the pixels with no regard to their relative location. However, in many image processing applications, the XY location of the pixels themselves is crucial information. A simple example of this might be, set every even column of pixels to white and every odd to black. How could you do this with a one-dimensional pixel array? How do you know what column or row any given pixel is in? When programming with pixels, we need to be able to think of every pixel as living in a two-dimensional world, but continue to access the data in one dimension (since that is how it is made available to us). We can do this via the following formula: 1. 2. 3.

Assume a window or image with a given WIDTH and HEIGHT. We then know the pixel array has a total number of elements equaling WIDTH * HEIGHT. For any given X, Y point in the window, the location in our one-dimensional pixel array is: LOCATION  X  Y * WIDTH

0

1

2

3

4

0

0

1

2

3

4

1

5

6

7

8

9

2

10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

3 4 rows

width = 5

Columns

Pixel 13 is in Column 3, row 2. x + y * width 3+2*5 3 + 10 13

ﬁg. 15.7

This may remind you of two-dimensional arrays in Chapter 13. In fact, we will need to use the same nested for loop technique. The diﬀerence is that, although we want to use for loops to think about the pixels in two dimensions, when we go to actually access the pixels, they live in a one-dimensional array, and we have to apply the formula from Figure 15.7. Let’s look at how it is done, completing the even/odd column problem. See Figure 15.8.

264

Learning Processing Example 15-6: Setting pixels according to their 2D location size(200,200); loadPixels(); // Loop through every pixel column for (int x = 0; x < width; x++) { // Loop through every pixel row for (int y = 0; y < height; y++){

Two loops allow us to visit every column (x ) and every row (y ).

ﬁg. 15.8

// Use the formula to find the 1D location int loc = x + y * width;

if (x % 2 == 0){ // If we are an even column pixels[loc] = color(255); } else { // If we are an odd column pixels[loc] = color(0); } } } updatePixels();

The location in the pixel array is calculated via our formula: 1D pixel location  x  y * width

We use the column number (x) to determine whether the color should be black or white.

Exercise 15-6: Complete the code to match the corresponding screenshots.

size(255,255); ___________________; for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { int loc = ___________________; float distance = ___________________); pixels[loc] = ___________________; } } ___________________; size(255,255); ___________________; for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { ___________________; if (___________________) { ___________________; } else { ___________________; } } } ___________________;

Images

265

15.6 Intro to Image Processing The previous section looked at examples that set pixel values according to an arbitrary calculation. We will now look at how we might set pixels according to those found in an existing PImage object. Here is some pseudocode. 1. 2.

Load the image ﬁle into a PImage object. For each pixel in the PImage, retrieve the pixel’s color and set the display pixel to that color.

The PImage class includes some useful ﬁelds that store data related to the image—width, height, and pixels. Just as with our user-deﬁned classes, we can access these ﬁelds via the dot syntax. PImage img = createImage(320,240,RGB); // Make a PImage object println(img.width); // Yields 320 println(img.height); // Yields 240 img.pixels[0] = color(255,0,0); // Sets the first pixel of the image to red

Access to these ﬁelds allows us to loop through all the pixels of an image and display them onscreen.

Example 15-7: Displaying the pixels of an image PImage img; void setup() { size(200,200); img = loadImage("sunflower.jpg"); } void draw() { loadPixels(); // Since we are going to access the image's pixels too img.loadPixels(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { int loc = x + y*width; // Image Processing Algorithm would go here float r = red (img.pixels [loc]); float g = green(img.pixels[loc]); float b = blue (imq.pixels[loc];

// Image Processing would go here // Set the display pixel to the image pixel pixels[loc] = color(r,g,b); } } updatePixels();

ﬁg. 15.9

We must also call loadPixels() on the PImage since we are going to read its pixels.

The functions red(), green(), and blue() pull out the three color components from a pixel. If we were to change the RGB values, we would do it here, before setting the pixel in the display window.

}

Now, we could certainly come up with simpliﬁcations in order to merely display the image (e.g., the nested loop is not required, not to mention that using the image( ) function would allow us to skip all this

266

Learning Processing

pixel work entirely). However, Example 15-7 provides a basic framework for getting the red, green, and blue values for each pixel based on its spatial orientation (XY location); ultimately, this will allow us to develop more advanced image processing algorithms. Before we move on, I should stress that this example works because the display area has the same dimensions as the source image. If this were not the case, you would simply need to have two pixel location calculations, one for the source image and one for the display area. int imageLoc = x + y*img.width; int displayLoc = x + y*width;

Exercise 15-7: Using Example 15-7, change the values of r, g, and b before displaying them.

15.7 Our Second Image Processing Filter, Making Our Own Tint( ) Just a few paragraphs ago, we were enjoying a relaxing coding session, colorizing images and adding alpha transparency with the friendly tint( ) method. For basic ﬁltering, this method did the trick. The pixel by pixel method, however, will allow us to develop custom algorithms for mathematically altering the colors of an image. Consider brightness—brighter colors have higher values for their red, green, and blue components. It follows naturally that we can alter the brightness of an image by increasing or decreasing the color components of each pixel. In the next example, we dynamically increase or decrease those values based on the mouse’s horizontal location. (Note that the next two examples include only the image processing loop itself, the rest of the code is assumed.)

Example 15-8: Adjusting image brightness for (int x = 0; x < img.width; x++) { for (int y = 0; y < img.height; y++) { // Calculate the 1D pixel location int loc = x + y*img.width; // Get the R,G,B values from image float r = red (img.pixels[loc]); float g = green (img.pixels[loc]); float b = blue (img.pixels[loc]); ﬁg. 15.10 // Change brightness according to the mouse here float adjustBrightness = ((float) mouseX / width) * 8.0; r *= adjustBrightness; g *= adjustBrightness; b *= adjustBrightness; // Constrain RGB to between 0-255 r = constrain(r,0,255); g = constrain(g,0,255); b = constrain(b,0,255); // Make a new color and set pixel in the window color c = color(r,g,b); pixels[loc] = c; } }

We calculate a multiplier ranging from 0.0 to 8.0 based on mouseX position. That multiplier changes the RGB value of each pixel. The RGB values are constrained between 0 and 255 before being set as a new color.

Images

267

Since we are altering the image on a per pixel basis, all pixels need not be treated equally. For example, we can alter the brightness of each pixel according to its distance from the mouse. Example 15-9: Adjusting image brightness based on pixel location for (int x = 0; x < img.width; x++) { for (int y = 0; y < img.height; y++) { // Calculate the 1D pixel location int loc = x + y*img.width; // Get the R,G,B values from image float r = red (img.pixels[loc]); float g = green (img.pixels[loc]); float b = blue (img.pixels[loc]); // Calculate an amount to change brightness // based on proximity to the mouse float distance = dist(x,y,mouseX,mouseY); float adjustBrightness = (50-distance)/50; r *= adjustBrightness; g *= adjustBrightness; b *= adjustBrightness; // Constrain RGB to between 0-255 r = constrain(r,0,255); g = constrain(g,0,255); b = constrain(b,o,255); // Make a new color and set pixel in the window color c = color(r,g,b); pixels[loc] = c; } }

ﬁg. 15.11 The closer the pixel is to the mouse, the lower the value of “distance” is. We want closer pixels to be brighter, however, so we invert the value with the formula: adjustBrightness  (50-distance)/50 Pixels with a distance of 50 (or greater) have a brightness of 0.0 (or negative which is equivalent to 0 here) and pixels with a distance of 0 have a brightness of 1.0.

Exercise 15-8: Adjust the brightness of the red, green, and blue color components separately according to mouse interaction. For example, let mouseX control red, mouseY green, distance blue, and so on.

15.8 Writing to Another PImage Object’s Pixels All of our image processing examples have read every pixel from a source image and written a new pixel to the Processing window directly. However, it is often more convenient to write the new pixels to a destination image (that you then display using the image( ) function). We will demonstrate this technique while looking at another simple pixel operation: threshold. A threshold ﬁlter displays each pixel of an image in only one of two states, black or white. That state is set according to a particular threshold value. If the pixel’s brightness is greater than the threshold, we color the pixel white, less than, black. Example 15-10 uses an arbitrary threshold of 100.

ﬁg. 15.12

268

Learning Processing Example 15-10: Brightness threshold PImage source; // Source image PImage destination; // Destination image

We need two images, a source (original ﬁle) and destination (to be displayed) image.

void setup() { size(200,200); source = loadImage("sunflower.jpg"); destination = createImage(source.width, source.height, RGB); } void draw() { float threshold = 127;

The destination image is created as a blank image the same size as the source.

// We are going to look at both image's pixels source.loadPixels(); destination.loadPixels(); for (int x = 0; x < source.width; x++) { for (int y = 0; y < source.height; y++) { int loc = x + y*source.width; // Test the brightness against the threshold if (brightness(source.pixels[loc]) > threshold){ destination.pixels[loc] = color(255); // White } else { destination.pixels[loc] = color(0); // Black } }

brightness( ) returns a value between 0 and 255, the overall brightness of the pixel’s color. If it is more than 100, make it white, less than 100, make it black. Writing to the destination image’s pixels.

} // We changed the pixels in destination destination.updatePixels(); // Display the destination image(destination,0,0);

We have to display the destination image!

}

Exercise 15-9: Tie the threshold to mouse location.

This particular functionality is available without per pixel processing as part of Processing’s ﬁlter( ) function. Understanding the lower level code, however, is crucial if you want to implement your own image processing algorithms, not available with ﬁlter( ). If all you want to do is threshold, Example 15-11 is much simpler.

Example 15-11: Brightness threshold with ﬁlter // Draw the image image(img,0,0); // Filter the window with a threshold effect // 0.5 means threshold is 50% brightness filter(THRESHOLD,0.5);

Images

269

More on ﬁlter( ): ﬁlter(mode); ﬁlter(mode,level); The ﬁlter( ) function oﬀers a set of prepackaged ﬁlters for the display window. It is not necessary to use a PImage, the ﬁlter will alter the look of whatever is drawn in the window at the time it is executed. Other available modes besides THRESHOLD are GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, and DILATE. See the Processing reference (http://processing.org/reference/ﬁlter_.html) for examples of each.

15.9 Level II: Pixel Group Processing In previous examples, we have seen a one-to-one relationship between source pixels and destination pixels. To increase an image’s brightness, we take one pixel from the source image, increase the RGB values, and display one pixel in the output window. In order to perform more advanced image processing functions, however, we must move beyond the one-to-one pixel paradigm into pixel group processing. Let’s start by creating a new pixel out of two pixels from a source image—a pixel and its neighbor to the left. If we know the pixel is located at (x,y): int loc = x + y*img.width; color pix = img.pixels[loc];

Then its left neighbor is located at (x  1,y): int leftLoc = (x-1) + y*img.width; color leftPix = img.pixels[leftLoc];

We could then make a new color out of the difference between the pixel and its neighbor to the left. float diff = abs(brightness(pix) - brightness(leftPix)); pixels[loc] = color(diff);

Example 15-12 shows the full algorithm, with the results shown in Figure 15.13. Example 15-12: Pixel neighbor differences (edges) // Since we are looking at left neighbors // We skip the first column for (int x = 1; x < width; x++) { for (int y = 0; y < height; y++) { // Pixel location and color int loc = x + y*img.width; color pix = img.pixels[loc]; Reading the pixel to the left. // Pixel to the left location and color int leftLoc = (x–1) + y*img.width; color leftPix = img.pixels[leftLoc];

ﬁg. 15.13

270

Learning Processing // New color is difference between pixel and left neighbor float diff = abs(brightness(pix) - brightness(leftPix)); pixels[loc] = color(diff); } }

Example 15-12 is a simple vertical edge detection algorithm. When pixels diﬀer greatly from their neighbors, they are most likely “edge” pixels. For example, think of a picture of a white piece of paper on a black tabletop. The edges of that paper are where the colors are most diﬀerent, where white meets black. In Example 15-12, we look at two pixels to ﬁnd edges. More sophisticated algorithms, however, usually involve looking at many more neighboring pixels. After all, each pixel has eight immediate neighbors: top left, top, top right, right, bottom right, bottom, bottom left, and left. See Figure 15.14.

d its

el an

A pix

dly Frien

s

hbor

Neig

a pixel at x, y

its neighbor ( x  1, y)

its neighbor (x + 1, y + 1) ﬁg. 15.14

These image processing algorithms are often referred to as a “spatial convolution.” The process uses a weighted average of an input pixel and its neighbors to calculate an output pixel. In other words, that new pixel is a function of an area of pixels. Neighboring areas of diﬀerent sizes can be employed, such as a 3  3 matrix, 5  5, and so on. Diﬀerent combinations of weights for each pixel result in various eﬀects. For example, we “sharpen” an image by subtracting the neighboring pixel values and increasing the centerpoint pixel. A blur is achieved by taking the average of all neighboring pixels. (Note that the values in the convolution matrix add up to 1.) For example, Sharpen: –1 –1 –1 9 –1 –1

–1 –1 –1

Blur: 1/9 1/9 1/9 1/9 1/9 1/9

1/9 1/9 1/9

Images

271

Example 15-13 performs a convolution using a 2D array (see Chapter 13 for a review of 2D arrays) to store the pixel weights of a 3  3 matrix. This example is probably the most advanced example we have encountered in this book so far, since it involves so many elements (nested loops, 2D arrays, PImage pixels, etc.).

Example 15-13: Sharpen with convolution PImage img; int w = 80; // It's possible to perform a convolution // the image with different matrices float[][] matrix = { { { {

–1, –1, –1 }, –1, 9, –1 }, –1, –1, –1 } };

void setup() { size(200,200); img = loadImage("sunflower.jpg"); }

The convolution matrix for a “sharpen” effect stored as a 3  3 twodimensional array.

void draw() { // We're only going to process a portion of the image // so let's set the whole image as the background first image(img,0,0); // Where is the small rectangle we will process int xstart = constrain(mouseX-w/2,0,img.width); int ystart = constrain(mouseY-w/2,0,img.height); int xend = constrain(mouseX+w/2,0,img.width); int yend = constrain(mouseY+w/2,0,img.height); int matrixsize = 3; loadPixels(); // Begin our loop for every pixel for (int x = xstart; x < xend; x++) { for (int y = ystart; y < yend; y++) { color c = convolution(x,y,matrix,matrixsize,img); int loc = x + y*img.width; pixels[loc] = c; } } updatePixels();

ﬁg. 15.15

In this example we are only processing a section of the image—an 80  80 rectangle around the mouse location.

Each pixel location (x,y) gets passed into a function called convolution( ) which returns a new color value to be displayed.

stroke(0); noFill(); rect(xstart,ystart,w,w); } color convolution(int x, int y, float[][] matrix, int matrixsize, PImage img) { float rtotal = 0.0; float gtotal = 0.0; float btotal = 0.0; int offset = matrixsize / 2; // Loop through convolution matrix for (int i = 0; i < matrixsize; i++) { for (int j= 0; j < matrixsize; j++) { // What pixel are we testing

272

Learning Processing int xloc = x+i-offset; int yloc = y+j-offset; int loc = xloc + img.width*yloc; // Make sure we haven't walked off the edge of the loc = constrain(loc,0,img.pixels.length-1); // Calculate the convolution rtotal += (red(img.pixels[loc]) * matrix[i][j]); gtotal += (green(img.pixels[loc]) * matrix[i][j]); btotal += (blue(img.pixels[loc]) * matrix[i][j]);

pixel array

It is often good when looking at neighboring pixels to make sure we have not gone off the edge of the pixel array by accident.

} } // Make sure RGB is within range rtotal = constrain(rtotal,0,255); gtotal = constrain(gtotal,0,255); btotal = constrain(btotal,0,255); // Return the resulting color return color(rtotal,gtotal,btotal); }

We sum all the neighboring pixels multiplied by the values in the convolution matrix.

After the sums are constrained within a range of 0–255, a new color is made and returned.

}

Exercise 15-10: Try diﬀerent values for the convolution matrix.

Exercise 15-11: Using the framework established by our image processing examples, create a ﬁlter that takes two images as input and generates one output image. In other words, each pixel displayed should be a function of the color values from two pixels, one from one image and one from another. For example, can you write the code to blend two images together (without using tint( ))?

15.10 Creative Visualization You may be thinking: “Gosh, this is all very interesting, but seriously, when I want to blur an image or change its brightness, do I really need to write code? I mean, can’t I use Photoshop?” Indeed, what we have achieved here is merely an introductory understanding of what highly skilled programmers at Adobe do. The power of Processing, however, is the potential for real-time, interactive graphics applications. There is no need for us to live within the conﬁnes of “pixel point ” and “pixel group” processing. Following are two examples of algorithms for drawing Processing shapes. Instead of coloring the shapes randomly or with hard-coded values as we have in the past, we select colors from the pixels of a PImage object. The image itself is never displayed; rather, it serves as a database of information that we can exploit for our own creative pursuits. In this ﬁrst example, for every cycle through draw( ), we ﬁll one ellipse at a random location onscreen with a color taken from its corresponding location in the source image. The result is a “pointillist-like” eﬀect. See Figure 15.16.

Images Example 15-14: “Pointillism” PImage img; int pointillize = 16; void setup() { size(200,200); img = loadImage("sunﬂower.jpg"); background(0); smooth(); } void draw() { // Pick a random point int x = int(random(img.width)); int y = int(random(img.height)); int loc = x + y*img.width;

ﬁg. 15.16

// Look up the RGB color in the source image loadPixels(); float r = red(img.pixels[loc]); float g = green(img.pixels[loc]); float b = blue(img.pixels[loc]); noStroke();

}

// Draw an ellipse at that location with that color fill(r,g,b,100); ellipse(x,y,pointillize,pointillize); Back to shapes! Instead of setting a pixel, we

use the color from a pixel to draw a circle.

In this next example, we take the data from a two-dimensional image and, using the 3D translation techniques described in Chapter 14, render a rectangle for each pixel in three-dimensional space. The z location is determined by the brightness of the color. Brighter colors appear closer to the viewer and darker ones further away.

ﬁg. 15.17 Example 15-15: 2D image mapped to 3D PImage img; // The source image int cellsize = 2; // Dimensions of each cell in the grid int cols, rows; // Number of columns and rows in our system void setup() { size(200,200,P3D);
